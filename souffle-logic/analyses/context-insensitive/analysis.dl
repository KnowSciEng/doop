// Context-insensitive pointer analysis with on-the-fly call graph discovery

#include "../../main/single-phase-analysis.dl"
#include "../../main/configuration.dl"
 
// This analysis has no context for either method calls or heap objects.
// This is emulated by creating a single Context object and a single HContext
// object, which are used everywhere.


.comp ContextInsensitiveConfiguration : AbstractConfiguration {

  .type Context
  .type HContext
         
  ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
    ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
    ?calleeCtx = ?callerCtx.

  StaticContextResponse(?callerCtx, ?invo, ?calleeCtx) :-
    StaticContextRequest(?callerCtx, ?invo),
    ?calleeCtx = ?callerCtx.
      
   /**
    * Some library modules are generically defined, and need the macro
    * definitions for the context-sensitive pointer analysis they are
    * used in. For a context-insensitive pointer analysis we just
    * generate constant contexts.
    */

  #define UNIQUE_CONTEXT  "<<unique-context>>"
  #define UNIQUE_HCONTEXT "<<unique-hcontext>>"

  RecordContextResponse(?ctx, ?value, ?var, ?hctx) :-
    RecordContextRequest(?ctx, ?value, ?var),
    ?hctx = UNIQUE_HCONTEXT.

  // MergeThreadStart, MergeStartup, and MergeFinalizerRegisterContext
  // have the same logic as plain Merge for this analysis.
  ThreadStartContextResponse(?callerCtx, ?hctx, ?value, ?newCtx) :-
    ThreadStartContextRequest(?callerCtx, ?hctx, ?value),
    ?newCtx = UNIQUE_CONTEXT.

  StartupContextResponse(?hctx, ?value, ?calleeCtx) :-
    StartupContextRequest(?hctx, ?value),
    ?calleeCtx = UNIQUE_CONTEXT.
              
  FinalizerRegisterContextResponse(?callerCtx, ?inmethod, ?value, ?calleeCtx) :-
    FinalizerRegisterContextRequest(?callerCtx, ?inmethod, ?value),
    ?calleeCtx = UNIQUE_CONTEXT.

  InitContextResponse(?s, ?ctx) :-
    ?ctx = UNIQUE_CONTEXT,
    InitContextRequest(?s).

  InitHContextResponse(?s, ?hctx) :-
    ?hctx = UNIQUE_HCONTEXT,
    InitHContextRequest(?s).

  #ifdef HEAPDL
    DynamicContextToHContext(?hctx, ?dynCtx) :-
      isDynamicContext(?dynCtx),
      isImmutableHContext(?hctx).

    DynamicContextToContext(?ctx, ?dynCtx) :-
      isDynamicContext(?dynCtx),
      isImmutableContext(?ctx).
  #endif

/** Utility rule: Value points to another value directly or indirectly **/
.decl ValuePointsTo(?baseValue:Value, ?value:Value)

ValuePointsTo(?baseValue, ?value) :-
  InstanceFieldPointsTo(_, ?value, _, _, ?baseValue).

ValuePointsTo(?baseValue, ?value) :-
  ValuePointsTo(?value1, ?value),
  InstanceFieldPointsTo(_, ?value1, _, _, ?baseValue).

.decl InOutFlowDirectValuePerClass(?inMethod:Method, ?outMethod:Method, ?class:Type, ?value:Value)

/** Direct in out flow:
 *
 *   arg -> value
 *   ret -> value
 */
InOutFlowDirectValuePerClass(?inMethod, ?outMethod, ?class, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  VarPointsTo(_, ?value, _, ?arg),
  basic.MethodsOfSameType(?inMethod, ?outMethod, ?class),
  ReturnVar(?returnArg, ?outMethod),
  VarPointsTo(_, ?value, _, ?returnArg).

.decl InOutFlowDirectTwoValuesPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowDirectTwoValuesPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowDirectValuePerClass(?inMethod, ?outMethod, ?class, ?value1),
  InOutFlowDirectValuePerClass(?inMethod, ?outMethod, ?class, ?value2),
  ?value1 != ?value2.

/**
 * Wrapped in out flow:
 *
 * arg -> value
 * ret -> ... -> ... -> value
 */
.decl InOutFlowWrappedValuePerClass(?inMethod:Method, ?outMethod:Method, ?class:Type, ?value:Value) 

InOutFlowWrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  basic.MethodsOfSameType(?inMethod, ?outMethod, ?class),
  ReturnVar(?returnArg, ?outMethod),
  VarPointsTo(_, ?value, _, ?arg),
  VarPointsTo(_, ?baseValue, _, ?returnArg),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowWrappedTwoValuesPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowWrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowWrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value1),
  InOutFlowWrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value2),
  ?value1 != ?value2.

/**
 * Unwrapped in out flow:
 *
 * arg -> ... -> ... -> ... -> value
 * ret -> value
 */
.decl InOutFlowUnwrappedValuePerClass(?inMethod:Method, ?outMethod:Method, ?class:Type, ?value:Value) 

InOutFlowUnwrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  basic.MethodsOfSameType(?inMethod, ?outMethod, ?class),
  ReturnVar(?returnArg, ?outMethod),
  VarPointsTo(_, ?baseValue, _, ?arg),
  VarPointsTo(_, ?value, _, ?returnArg),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowUnwrappedTwoValuesPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowUnwrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowUnwrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value1),
  InOutFlowUnwrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value2),
  ?value1 != ?value2.

.decl InOutFlowPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowDirectTwoValuesPerClass(?inMethod, ?outMethod, ?class).

InOutFlowPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowWrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class).

InOutFlowPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowUnwrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class).


.decl ClassToRefine(?class:Type)
.decl ClassToNotRefine(?class:Type)
      
ClassToRefine(?class) :-
  InOutFlowPerClass(_, _, ?class),
  !ClassToNotRefine(?class).
.output ClassToRefine
//.input ClassToRefine(IO="file", filename="/home/anantoni/Development/doop-nexgen/ClassToRefine.facts")
.input ClassToNotRefine(IO="file", filename="/home/anantoni/Development/doop-nexgen/ClassToNotRefine.facts")

}
