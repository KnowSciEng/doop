// Context-insensitive with an enhancement for low-hanging fruit:
// methods that have their params flow to their return value get a
// 1-obj treatment (or 1-call for static calls).

#include "../../main/single-phase-analysis.dl"
#include "../../main/configuration.dl"
#include "../../main/in-out-flow.dl"

.type UniqueContext
.type UniqueHContext
.type Component = MethodInvocation | Value | UniqueContext | UniqueHContext 
.type Context  = [ c:Component ] 
.type HContext = [ c:Component ]

.decl UContext(?ctx:UniqueContext)
.decl UHContext(?hctx:UniqueHContext)

#define UNIQUE_CONTEXT  "<<unique-context>>"
#define UNIQUE_HCONTEXT "<<unique-hcontext>>"

UContext(UNIQUE_CONTEXT).
UHContext(UNIQUE_HCONTEXT).

.comp ContextInsensitivePlusPlusConfiguration : AbstractConfiguration {

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invo, ?tomethod),
  InOutFlowMethod(_, ?tomethod),
  ?calleeCtx = [?value].

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invo, ?tomethod),
  !InOutFlowMethod(_, ?tomethod),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp].

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  isSpecialMethodInvocation_Insn(?invo),
  MethodInvocation_Method(?invo, ?tomethod),
  InOutFlowMethod(_, ?tomethod),
  ?calleeCtx = [?value].

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  isSpecialMethodInvocation_Insn(?invo),
  MethodInvocation_Method(?invo, ?tomethod),
  !InOutFlowMethod(_, ?tomethod),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp].

StaticContextResponse(?callerCtx, ?invo, ?calleeCtx) :-
  StaticContextRequest(?callerCtx, ?invo),
  MethodInvocation_Method(?invo, ?tomethod),
  InOutFlowMethod(_, ?tomethod),
  ?calleeCtx = [?invo].

StaticContextResponse(?callerCtx, ?invo, ?calleeCtx) :-
  StaticContextRequest(?callerCtx, ?invo),
  MethodInvocation_Method(?invo, ?tomethod),
  !InOutFlowMethod(_, ?tomethod),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp].

RecordContextResponse(?ctx, ?value, ?var, ?hctx) :-                  
  RecordContextRequest(?ctx, ?value, ?var),      
  ?ctx = [?component],
  ?hctx = [?component].

// MergeThreadStart, MergeStartup, and MergeFinalizerRegisterContext
// have the same logic as plain Merge for this analysis.
ThreadStartContextResponse(?callerCtx, ?hctx, ?value, ?newCtx) :-
  ThreadStartContextRequest(?callerCtx, ?hctx, ?value),
  UContext(?newCtxComp),
  ?newCtx = [?newCtxComp].

StartupContextResponse(?hctx, ?value, ?calleeCtx) :-
  StartupContextRequest(?hctx, ?value),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp].

FinalizerRegisterContextResponse(?callerCtx, ?inmethod, ?value, ?calleeCtx) :-
  FinalizerRegisterContextRequest(?callerCtx, ?inmethod, ?value),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp].

InitContextResponse(?s, ?ctx) :-
  ?ctx = [?comp],
  UContext(?comp),                   
  InitContextRequest(?s).

InitHContextResponse(?s, ?hctx) :-
  ?hctx = [?comp],                  
  UHContext(?comp),
  InitHContextRequest(?s).

#ifdef HEAPDL
  DynamicContextToContext(?ctx, ?dctx) :-
    isDynamicContext(?dctx),
    isImmutableContext(?ctx).

  DynamicContextToHContext(?hctx, ?dctx) :-
    isDynamicContext(?dctx),
    isImmutableHContext(?hctx).
#endif
}
