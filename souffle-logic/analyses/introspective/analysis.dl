#include "../context-insensitive/analysis.dl"

#define UNIQUE_VALUE  "<<unique-value>>"
#define UNIQUE_HCONTEXT "<<unique-hcontext>>"

.init preAnalysis = BasicContextSensitivity<ContextInsensitiveConfiguration>


.comp IntrospectiveConfiguration : AbstractConfiguration {
           
.type Context  = [ c1:mainAnalysis.Value, c2:mainAnalysis.Value ]
.type HContext = [ value:mainAnalysis.Value ]
                    
ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invo, ?tomethod),
  Method_DeclaringType(?tomethod, ?class),
  !ClassToRefine(?class),
  isImmutableContext(?calleeCtx).

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invo, ?tomethod),
  Method_DeclaringType(?tomethod, ?class),
  ClassToRefine(?class),
  ?hctx = [?hctxValue],
  ?calleeCtx = [?hctxValue, ?value].

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  isSpecialMethodInvocation_Insn(?invo),
  MethodInvocation_Method(?invo, ?tomethod),
  Method_DeclaringType(?tomethod, ?class),
  !ClassToRefine(?class),
  isImmutableContext(?calleeCtx).

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  isSpecialMethodInvocation_Insn(?invo),
  MethodInvocation_Method(?invo, ?tomethod),
  Method_DeclaringType(?tomethod, ?class),
  ClassToRefine(?class),  
  ?hctx = [?hctxValue],
  ?calleeCtx = [?hctxValue, ?value].

StaticContextResponse(?callerCtx, ?invo, ?calleeCtx) :-
  StaticContextRequest(?callerCtx, ?invo),
  ?calleeCtx = ?callerCtx.

RecordContextResponse(?ctx, ?value, ?arg, ?hctx) :-
  RecordContextRequest(?ctx, ?value, ?arg),      
  ?ctx = [?ctxValue1, ?ctxValue2],
  ?hctx = [?ctxValue2],
  ?ctxValue1 = ?ctxValue1.

// MergeThreadStart, MergeStartup, and MergeFinalizerRegisterContext
// have the same logic as plain Merge for this analysis.
ThreadStartContextResponse(?callerCtx, ?hctx, ?value, ?newCtx) :-
  ThreadStartContextRequest(?callerCtx, ?hctx, ?value),
  ?hctx = [?hctxValue],
  ?newCtx = [?hctxValue, ?value].

StartupContextResponse(?hctx, ?value, ?newCtx) :-
  StartupContextRequest(?hctx, ?value),
  ?hctx = [?hctxValue],
  ?newCtx = [?hctxValue, ?value].

FinalizerRegisterContextResponse(?callerCtx, ?inmethod, ?value, ?newCtx) :-
  FinalizerRegisterContextRequest(?callerCtx, ?inmethod, ?value),
  ?callerCtx = [?callerCtxValue1, ?callerCtxValue2],
  ?newCtx = [?callerCtxValue2, ?value],
  ?callerCtxValue1 = ?callerCtxValue1.

InitContextResponse(?value, ?ctx) :-
  InitContextRequest(?value),
  ?ctx = [?value, ?value].

InitHContextResponse(?value, ?hctx) :-
  InitHContextRequest(?value),
  ?hctx = [?value].
         

/** Utility rule: Value points to another value directly or indirectly **/
.decl ValuePointsTo(?baseValue:Value, ?value:Value)

ValuePointsTo(?baseValue, ?value) :-
  preAnalysis.InstanceFieldPointsTo(_, ?value, _, _, ?baseValue).

ValuePointsTo(?baseValue, ?value) :-
  ValuePointsTo(?value1, ?value),
  preAnalysis.InstanceFieldPointsTo(_, ?value1, _, _, ?baseValue).

.decl InOutFlowDirectValuePerClass(?inMethod:Method, ?outMethod:Method, ?class:Type, ?value:Value)

/** Direct in out flow:
 *
 *   arg -> value
 *   ret -> value
 */
InOutFlowDirectValuePerClass(?inMethod, ?outMethod, ?class, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  preAnalysis.VarPointsTo(_, ?value, _, ?arg),
  basic.Methods_Type(?inMethod, ?outMethod, ?class),
  ReturnVar(?returnArg, ?outMethod),
  preAnalysis.VarPointsTo(_, ?value, _, ?returnArg).

.decl InOutFlowDirectTwoValuesPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowDirectTwoValuesPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowDirectValuePerClass(?inMethod, ?outMethod, ?class, ?value1),
  InOutFlowDirectValuePerClass(?inMethod, ?outMethod, ?class, ?value2),
  ?value1 != ?value2.

/**
 * Wrapped in out flow:
 *
 * arg -> value
 * ret -> ... -> ... -> value
 */
.decl InOutFlowWrappedValuePerClass(?inMethod:Method, ?outMethod:Method, ?class:Type, ?value:Value) 

InOutFlowWrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  basic.Methods_Type(?inMethod, ?outMethod, ?class),
  ReturnVar(?returnArg, ?outMethod),
  preAnalysis.VarPointsTo(_, ?value, _, ?arg),
  preAnalysis.VarPointsTo(_, ?baseValue, _, ?returnArg),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowWrappedTwoValuesPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowWrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowWrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value1),
  InOutFlowWrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value2),
  ?value1 != ?value2.

/**
 * Unwrapped in out flow:
 *
 * arg -> ... -> ... -> ... -> value
 * ret -> value
 */
.decl InOutFlowUnwrappedValuePerClass(?inMethod:Method, ?outMethod:Method, ?class:Type, ?value:Value) 

InOutFlowUnwrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  basic.Methods_Type(?inMethod, ?outMethod, ?class),
  ReturnVar(?returnArg, ?outMethod),
  preAnalysis.VarPointsTo(_, ?baseValue, _, ?arg),
  preAnalysis.VarPointsTo(_, ?value, _, ?returnArg),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowUnwrappedTwoValuesPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowUnwrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowUnwrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value1),
  InOutFlowUnwrappedValuePerClass(?inMethod, ?outMethod, ?class, ?value2),
  ?value1 != ?value2.

/**
 * Any in out flow:
 *
 * arg -> ... -> ... -> ... -> value
 * ret -> ... -> ... -> ... -> value
 */
// The following refinement logic is too expensive

// .decl InOutFlowAnyValuePerClass(?inMethod:Method, ?outMethod:Method, ?class:Type, ?value:Value) 

// InOutFlowAnyValuePerClass(?inMethod, ?outMethod, ?class, ?value) :-
//   FormalParam(_, ?inMethod, ?arg),
//   basic.Methods_Type(?inMethod, ?outMethod, ?class),
//   ReturnVar(?returnArg, ?outMethod),
//   preAnalysis.VarPointsTo(_, ?baseValue1, _, ?arg),
//   preAnalysis.VarPointsTo(_, ?baseValue2, _, ?returnArg),
//   ValuePointsTo(?baseValue1, ?value),
//   ValuePointsTo(?baseValue2, ?value),
//   ?baseValue1 != ?baseValue2.
             
// .decl InOutFlowAnyTwoValuesPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)
      
// InOutFlowAnyTwoValuesPerClass(?inMethod, ?outMethod, ?class) :-
//   InOutFlowAnyValuePerClass(?inMethod, ?outMethod, ?class, ?value1),
//   InOutFlowAnyValuePerClass(?inMethod, ?outMethod, ?class, ?value2),
//   ?value1 != ?value2.

.decl InOutFlowPerClass(?inMethod:Method, ?outMethod:Method, ?class:Type)

InOutFlowPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowDirectTwoValuesPerClass(?inMethod, ?outMethod, ?class).

InOutFlowPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowWrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class).

InOutFlowPerClass(?inMethod, ?outMethod, ?class) :-
  InOutFlowUnwrappedTwoValuesPerClass(?inMethod, ?outMethod, ?class).

// InOutFlowPerClass(?inMethod, ?outMethod, ?class) :-
//   InOutFlowAnyTwoValuesPerClass(?inMethod, ?outMethod, ?class).

.decl ClassToRefine(?class:Type)
.decl ClassToNotRefine(?class:Type)
      
ClassToRefine(?class) :-
  InOutFlowPerClass(_, _, ?class),
  !ClassToNotRefine(?class).

.input ClassToRefine(IO="file", filename="/home/anantoni/Development/doop-nexgen/ClassToRefine.facts")
.input ClassToNotRefine(IO="file", filename="/home/anantoni/Development/doop-nexgen/ClassToNotRefine.facts")
       
.decl MethodToRefine(?method:Method)

MethodToRefine(?method) :-      
  (InOutFlowPerClass(?method, _, _);
   InOutFlowPerClass(_, ?method, _)).


.decl InOutFlowDirectValue(?inMethod:Method, ?outMethod:Method, ?value:Value)

/** Direct in out flow:
 *
 *   arg -> value
 *   ret -> value
 */
InOutFlowDirectValue(?inMethod, ?outMethod, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  preAnalysis.VarPointsTo(_, ?value, _, ?arg),
  ReturnVar(?returnArg, ?outMethod),
  preAnalysis.VarPointsTo(_, ?value, _, ?returnArg).

.decl InOutFlowDirectTwoValues(?inMethod:Method, ?outMethod:Method)

InOutFlowDirectTwoValues(?inMethod, ?outMethod) :-
  InOutFlowDirectValue(?inMethod, ?outMethod, ?value1),
  InOutFlowDirectValue(?inMethod, ?outMethod, ?value2),
  ?value1 != ?value2.

/**
 * Wrapped in out flow:
 *
 * arg -> value
 * ret -> ... -> ... -> value
 */
.decl InOutFlowWrappedValue(?inMethod:Method, ?outMethod:Method, ?value:Value) 

InOutFlowWrappedValue(?inMethod, ?outMethod, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  ReturnVar(?returnArg, ?outMethod),
  preAnalysis.VarPointsTo(_, ?value, _, ?arg),
  preAnalysis.VarPointsTo(_, ?baseValue, _, ?returnArg),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowWrappedTwoValues(?inMethod:Method, ?outMethod:Method)

InOutFlowWrappedTwoValues(?inMethod, ?outMethod) :-
  InOutFlowWrappedValue(?inMethod, ?outMethod, ?value1),
  InOutFlowWrappedValue(?inMethod, ?outMethod, ?value2),
  ?value1 != ?value2.

/**
 * Unwrapped in out flow:
 *
 * arg -> ... -> ... -> ... -> value
 * ret -> value
 */
.decl InOutFlowUnwrappedValue(?inMethod:Method, ?outMethod:Method, ?value:Value) 

InOutFlowUnwrappedValue(?inMethod, ?outMethod, ?value) :-
  FormalParam(_, ?inMethod, ?arg),
  ReturnVar(?returnArg, ?outMethod),
  preAnalysis.VarPointsTo(_, ?baseValue, _, ?arg),
  preAnalysis.VarPointsTo(_, ?value, _, ?returnArg),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowUnwrappedTwoValues(?inMethod:Method, ?outMethod:Method)

InOutFlowUnwrappedTwoValues(?inMethod, ?outMethod) :-
  InOutFlowUnwrappedValue(?inMethod, ?outMethod, ?value1),
  InOutFlowUnwrappedValue(?inMethod, ?outMethod, ?value2),
  ?value1 != ?value2.

.decl InOutFlow(?inMethod:Method, ?outMethod:Method)

InOutFlow(?inMethod, ?outMethod) :-
  InOutFlowDirectTwoValues(?inMethod, ?outMethod).

InOutFlow(?inMethod, ?outMethod) :-
  InOutFlowWrappedTwoValues(?inMethod, ?outMethod).

InOutFlow(?inMethod, ?outMethod) :-
  InOutFlowUnwrappedTwoValues(?inMethod, ?outMethod).

// MethodToRefine(?method) :-      
//   (InOutFlow(?method, _);
//    InOutFlow(_, ?method)).

//.printsize InOutFlowDirectTwoValues
//.printsize InOutFlowWrappedTwoValues
//.printsize InOutFlowUnwrappedTwoValues
//.printsize isType
//.printsize isMethod           
//.printsize InOutFlowClass
}
