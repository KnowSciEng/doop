/*************************************************************
 * Special objects
 *
 * Some objects are so common that they heavily impact performance if
 * every allocation is distinguished or a context-sensitive heap
 * abstraction is used. In many cases, this precision is not actually
 * useful for a points-to analysis, so handling them in a less precise
 * way is beneficial.
 *************************************************************/

/**
 * Join with AssignHeapAllocation for performance.
 */
.decl HeapAllocation_Special(?heap:HeapAllocation)

HeapAllocation_Special(?heap) :-
    HeapAllocation_ContextInsensitive(?heap).

HeapAllocation_Special(?heap) :-
    HeapAllocation_Merge(?heap, _).


/**
 * Objects that should use a context-insensitive heap abstraction.
 */
.decl HeapAllocation_ContextInsensitive(?heap:HeapAllocation)

/**
 * Objects that should be merged to some heap abstraction
 * (will overlap with merely context-insensitive objects)
 */
.decl HeapAllocation_Merge(?heap:HeapAllocation, ?mergeHeap:HeapAllocation) output

// The ones that absolutely have to be kept distinct
.decl HeapAllocation_Keep(?heap:HeapAllocation)

/**
 * This is the handling for objects that are explicitly allocated in
 * the program text. There will also be other objects: pseudo objects
 * (null, string-constant), reified reflection objects, string
 * constants that the analysis thought are safe to merge, yet they do
 * arise reflectively, etc.
 */
AssignNormalHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  ! HeapAllocation_Special(?heap).

AssignContextInsensitiveHeapAllocation(?mergeHeap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_Merge(?heap, ?mergeHeap).

AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_ContextInsensitive(?heap),
  !(HeapAllocation_Merge(?heap, _)). // should be mostly unnecessary, but has bitten us many times


/*************************************************************
 * Special handling for all sorts of objects. All potential
 * representatives of an object are examined, and one is picked
 * for merging. The idea is to make the rest of the logic flexible:
 * signal as many reasons as apply for merging an object with
 * others and then have a single point in the code that decides
 * which merging is best.
 *************************************************************/

// If the object is a string that should be merged, ignore other
// representatives and merge with that.
.decl HeapRepresentative(?heap:HeapAllocation, ?heapRepr:symbol)

HeapAllocation_Merge(?heap, ?heapRepr) :-
  HeapRepresentative(?heapRepr, ?heap),
  ?heapRepr = "<<string-constant>>",
  isHeapAllocation(?heapRepr).

.decl HeapIsMergedStringFactory(?heap:HeapAllocation)

HeapIsMergedStringFactory(?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  (isHeapAllocation(?heapRepr),
     ?heapRepr = "<<string-buffer>>";
     isHeapAllocation(?heapRepr),
     ?heapRepr = "<<string-buffer>>").

HeapAllocation_Merge(?heap, ?heapRepr) :-
  HeapRepresentative(?heapRepr, ?heap),
  (isHeapAllocation(?heapRepr),
   ?heapRepr = "<<string-buffer>>";
   isHeapAllocation(?heapRepr),
   ?heapRepr = "<<string-buffer>>").

.decl _RepresentativesToPickFrom(?heapRepr:symbol, ?heap:HeapAllocation) output

_RepresentativesToPickFrom(?heapRepr, ?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  !isStringConstant(?heap),
  !HeapIsMergedStringFactory(?heap),
  !HeapAllocation_Keep(?heap).

// If none of the special cases applies, just pick the lowest-id potential
// representative.
.decl _HeapAllocation_AggMerge(?heap:HeapAllocation, ?mergeHeap:symbol) output
.decl _MinHeapRepr(?heapRepr:symbol)

//_MinHeapRepr(minHeapRepr) :-
//    minHeapRepr = min a: _RepresentativesToPickFrom(a, _).

//_HeapAllocation_AggMerge(?heap, ?mergeHeap) :-
//  isHeapAllocation(?heap),
//  ?mergeHeap =

HeapAllocation_Merge(?heap, ?mergeHeap) :-
  _RepresentativesToPickFrom(?heap, ?mergeHeap).

/*************************************************************
 * String constants
 *************************************************************/

.decl ReflectionStringConstant(?heap:HeapAllocation)
.decl ReflectionSubstringObject(?heap:HeapAllocation)

#ifndef DISTINGUISH_ALL_STRING_CONSTANTS
#ifndef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS
#define DISTINGUISH_NO_STRING_CONSTANTS
HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  ?constant = "<<string-constant>>",
  isHeapAllocation(?constant),
  !HeapAllocation_Keep(?heap).
#endif
#endif // DISTINGUISH_NO_STRING_CONSTANTS mode

#ifdef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS
ReflectionStringConstant(?heap) :-
  ClassNameMatchingStringConstant(?heap);
  MethodNameMatchingStringConstant(?heap);
  FieldNameMatchingStringConstant(?heap).

ReflectionSubstringObject(?heap) :-
  ClassNameMatchingStringConstantInexact:Type(_,?heap);
  MethodNameMatchingStringConstantInexact:Signature(_,?heap);
  FieldNameMatchingStringConstantInexact:Signature(_,?heap).

HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  !ReflectionStringConstant(?heap),
  HeapAllocation_byId["<<string-constant>>"] = ?constant,
  !HeapAllocation_Keep(?heap).
#endif // DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS

HeapAllocation_ContextInsensitive(?heap) :-
  isStringConstant(?heap),
  !HeapRepresentative(_, ?heap).



/*************************************************************
 * Class constants
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  isClassHeap(?heap).

/*************************************************************
 * Merging allocation sites per method, per class, or per package.
 *************************************************************/

// Per-method merging: auto-merge allocation sites for method that
// allocates many objects of same type. Also, enable other rules to
// explicitly ask for per-method merging, beyond the above heuristic
// (by setting "...ShouldBeMerged...").

.decl MethodAllocationMergeThreshold(?t:number)
MethodAllocationMergeThreshold(50).

.decl ExceptionType(?type:Type)

ExceptionType(?type) :-
  ?throw = "java.lang.Throwable",
  isType(?throw),
  SubtypeOf(?type, ?throw).

.decl OptAssignHeapAllocation(?inmethod:Method, ?heap:HeapAllocation)

OptAssignHeapAllocation(?inmethod, ?heap) :-
  AssignHeapAllocation(?heap, _, ?inmethod).

// There are objects, like strings, null, and class objects, that
// don't have a unique allocation site.
.decl ObjectMultipleAllocated(?heap:HeapAllocation)

ObjectMultipleAllocated(?heap) :-
  OptAssignHeapAllocation(?inmethod1, ?heap),
  OptAssignHeapAllocation(?inmethod2, ?heap),
  ?inmethod1 != ?inmethod2.

.decl MethodAndTypeToHeap(?heap:HeapAllocation, ?heapType:Type, ?method:Method)
.decl StringFactoryHeap(?heap:HeapAllocation)

MethodAndTypeToHeap(?heap, ?heaptype, ?meth) :-
  AssignHeapAllocation(?heap, _, ?meth),
  HeapAllocation_Type(?heap, ?heaptype),
  !isStringConstant(?heap),
  !StringFactoryHeap(?heap),
  !HeapAllocation_EmptyArray(?heap),
  !ObjectMultipleAllocated(?heap),
  !HeapAllocation_Keep(?heap).

.decl AllocationsPerMethodAndType(?type:Type, ?meth:Method, ?n:number)

AllocationsPerMethodAndType(?type, ?meth, ?n) :-
  ?n = count : {MethodAndTypeToHeap(_, ?type, ?meth)}.

.decl AllocationShouldBeMergedPerMethod(?heaptype:Type, ?meth:Method)

AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  ?n > ?t,
  MethodAllocationMergeThreshold(?t).

.decl MethodAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?meth:Method)

MethodAndTypeToMergedHeap(?heap, ?heaptype, ?meth) :-
  AllocationShouldBeMergedPerMethod(?heaptype, ?meth),
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth).

.decl MethodAndTypeToRepresentative(?type:Type, ?meth:Method, ?reprHeap:HeapAllocation)
/*
MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap) :-
  ?representativeHeap = min ?heap: {(MethodAndTypeToMergedHeap(?heap, ?type, ?meth))}.
*/
HeapRepresentative(?representativeHeap, ?heap) :-
  MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap),
  MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

/*************************************************************
 * Coarse-grained allocation policy
 *************************************************************/

#ifdef COARSE_GRAINED_ALLOCATION
// Very coarse-grained allocation policy
// AllocationShouldBeMergedPerPackage(?type, ?packageName) <-
//   AllocationsPerPackageAndType[?type, ?packageName] > 1.

// Coarse-grained allocation policy
//AllocationShouldBeMergedPerClass(?type, ?class) <-
//  AllocationsPerClassAndType[?type, ?class] > 1.
#endif // COARSE_GRAINED_ALLOCATION


/*************************************************************
 * Library class that should be treated specially
 *************************************************************/

#ifndef CONTEXT_SENSITIVE_LIBRARY_ANALYSIS
#include "special-library.dl"
HeapAllocation_ContextInsensitive(?heap) :-
  SpecialLibraryObject(?heap),
  !HeapRepresentative(_, ?heap).

#ifdef MERGE_LIBRARY_OBJECTS_PER_METHOD
AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  ?n > 1,
  Method_DeclaringType(?meth, ?class),
  SpecialLibraryClass(?class).
#endif
#endif

/*************************************************************
 * String buffers and builders
 *************************************************************/
.decl StringFactoryType(?type:Type)

StringFactoryType(?type) :-
  isType(?type),
  ?type = "java.lang.StringBuffer" ;
  isType(?type),
  isType = "java.lang.StringBuilder".

StringFactoryHeap(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  StringFactoryType(?heaptype).

HeapRepresentative(?mergeHeap, ?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isType(?type),
  ?type = "java.lang.StringBuffer",
  ?mergeHeap = "<<string-buffer>>",
  isHeapAllocation(?mergeHeap),
  !HeapAllocation_Keep(?heap).

HeapRepresentative(?mergeHeap, ?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isType(?type),
  ?type = "java.lang.StringBuilder",
  ?mergeHeap = "<<string-builder>>",
  isHeapAllocation(?mergeHeap),
  !HeapAllocation_Keep(?heap).


/*************************************************************
 * Primitive arrays
 *
 * char[] or int[] don't have object elements, so it's useless to
 * allocate them context-sensitively.
 *
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isArrayType(?type),
  ComponentType(?type, ?componentType),
  isPrimitiveType(?componentType).

/*************************************************************
 * Class without reference fields
 *
 * Treat context-insensitively always? It doesn't matter much,
 * but doesn't hurt much either.
 *************************************************************/
/*
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation:Type(?heap, ?heaptype),
  Type_HasNoReferenceField(?heaptype),
  !HeapRepresentative(_, ?heap).
  // The rules have become complex enough that they overlap.

decl Type_HasNoReferenceField(?type:Type)
decl Type_DeclaresReferenceField(?type:Type)

Type_HasNoReferenceField(?type) :-
  ?type = "java.lang.Object",
  isType(?type).

Type_HasNoReferenceField(?class) :-
  isClassType(?class),
  DirectSuperclass(?class, ?super),
  Type_HasNoReferenceField(?super),
  ! Type_DeclaresReferenceField(?class).

Type_DeclaresReferenceField(?class) :-
  isClassType(?class),
  Field_DeclaringType(?signature, ?class),
  Field_Type(?signature, ?type),
  ReferenceType(?type),
  !FieldIsStatic(?signature).

FieldIsStatic(?sig) :-
  ?static = "static",
  Modifier(?static),
  Field_Modifier(?static, ?sig).

//// Quite risky: even final fields hold interesting state.
//FieldIsStaticOrFinal?sig) <-
//  Modifier:Id(?final:"final"),
//  Field:Modifier(?final, ?sig).
*/
