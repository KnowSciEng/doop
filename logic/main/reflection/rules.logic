/*************************************************************
 * Reflection analysis
 *************************************************************
 * Implementation of points-to propagation for concrete actions that
 * have been discovered using reflection. Basically, the rest of the
 * reflection logic sets things up, and the logic in this file actually
 * does the invocations, field set/gets, etc. that affect points-to info.
 *************************************************************
 *
 * NOTE
 * This analysis currently does not support reflective use of reflection. If
 * you really want to, you can hide uses of reflection in this way. The issue
 * here is that the current code does not consider reflective method
 * invocations, only virtual method invocations. For example:
 *      
 *   Method:Id(?getClass:"<java.lang.Object: java.lang.Class getClass()>"),
 *   VirtualMethodInvocation:Insn(?invocation),
 *   MethodInvocation:Signature[?invocation] = ?getClass,
 *
 * Only checks for invocations of getClass in source code, not in method
 * invocations discovered during reflection analysis.
 *************************************************************/

#include "java.lang.Class.logic"
#include "java.lang.reflect.Array.logic"
#include "java.lang.reflect.Constructor.logic"
#include "java.lang.reflect.Field.logic"
#include "java.lang.reflect.Method.logic"

/*************************************************************
 * Reflection objects: don't merge them, no matter what!
 *************************************************************/
HeapAllocation:Keep(?heap) <-
  ReifiedClass[_] = ?heap;
  ReifiedConstructor[_] = ?heap;
  ReifiedMethod[_] = ?heap;
  ReifiedField[_] = ?heap.

/*************************************************************
 * Give an arbitrary containing type for every reflection object,
 * so that analyses that need it (e.g., type-sens) are covered.
 *************************************************************/

// // REVIEW: the problem is that currently reflective allocations are not
// // uniquely identified. This would produce way too many facts. So instead we
// // cheat and use the type of the reflective allocation as the type *containing*
// // the reflective allocation.  If we are to fix this in the future, it will
// // look like this:

// Value:DeclaringType[?value] = ?type <-
//   ReflectiveAllocation[?invocation, _] = ?heap,
//   Value:byHeap[?heap] = ?value,
//   Instruction:Method[?invocation] = ?inmethod,
//   Method:DeclaringType[?inmethod] = ?type,
//   !StringConstant(?heap).

Value:DeclaringType[?value] = ?type <-
  ReflectiveAllocation[_, ?type] = ?heap,
  Value:byHeap[?heap] = ?value.

Value:DeclaringType[?value] = ?type <-
  ReifiedConstructor:Value[_] = ?value,
  Value:Type[?value] = ?type,
  ReferenceType(?type).

Value:DeclaringType[?value] = ?type <-
  ReifiedMethod:Value[_] = ?value,
  Value:Type[?value] = ?type,
  ReferenceType(?type).

Value:DeclaringType[?value] = ?type <-
  ReifiedField:Value[_] = ?value,
  Value:Type[?value] = ?type,
  ReferenceType(?type).

/*************************************************************
 * Create objects that are implicitly allocated in reflection calls.
 * Typically these are the objects returned by each call
 *************************************************************/

ReflectiveValue(?value) <- TempReflectiveHeap(?heap), Value:byHeap[?heap] = ?value.

#define CreateReflectiveAllocationMacro(invocation, heapType, heapStr) \
  MockHeapConsMacro(heapStr, heapType, ?heap), \
  TempReflectiveHeap(?heap), \
  ReflectiveAllocation[invocation, heapType] = ?heap

OptMethodInvocation:Signature(?invocation, ?sig) <-
  MethodInvocation:Signature[?invocation] = ?sig.


// NOTE "?sig" is reserved for this macro
#define VirtualMethodMacro(invocation, to, from, sigStr) \
  Method:Id(?sig:sigStr), \
  OptMethodInvocation:Signature(invocation, ?sig), \
  AssignReturnValue[invocation] = to, \
  VirtualMethodInvocation:Base[invocation] = from


// We assume that the array is allocated inside the method, before being returned.
// NOTE "?invocationStr" and "?typeStr" are reserved for this macro
#define ReflectiveArrayMacro(invocation, type, arrayType, arrayValueStr, arrayTypeStr) \
  Instruction:Id(invocation:?invocationStr), \
  Type:Id(type:?typeStr), \
  ArrayType(arrayType), Type:Id(arrayType:arrayTypeStr), \
  arrayValueStr = "<reflective "+ ?invocationStr +"/"+ ?typeStr +"/new "+ arrayTypeStr +">"

#define ReflectiveKnownArrayMacro(invocation, arrayType, arrayValueStr, arrayTypeStr) \
  Instruction:Id(invocation:?invocationStr), \
  ArrayType(arrayType), Type:Id(arrayType:arrayTypeStr), \
  arrayValueStr = "<reflective "+ ?invocationStr +"/new "+ arrayTypeStr +">"


java:lang:Object:getClass(?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Object: java.lang.Class getClass()>").

java:lang:Class:forName(?invocation, ?inmethod) <-
  ( Method:Id(?sig:"<java.lang.Class: java.lang.Class forName(java.lang.String)>") ;
    Method:Id(?sig:"<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>") ),
  StaticMethodInvocation(?invocation, ?sig, ?inmethod).

java:lang:Class:getName(?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.String getName()>").

java:lang:Class:getComponentType(?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.Class getComponentType()>").

java:lang:Class:getSuperclass(?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.Class getSuperclass()>").

// // (YS) Old style: Makes no sense to me. The type should not be there. This is just
// // allocating too many useless arrays. Changed it throughout.
// CreateReflectiveAllocationMacro(?invocation, ?type, ?arrayType, ?arrayHeapStr),
// java:lang:Class:getInterfaces(?invocation, ?to, ?from) <-
//   VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.Class[] getInterfaces()>"),
//   ReferenceType(?type),
//   ReflectiveArrayMacro(?invocation, ?type, ?arrayType, ?arrayHeapStr, "java.lang.Class[]").

CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:Class:getInterfaces(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.Class[] getInterfaces()>"),
  ReflectiveKnownArrayMacro(?invocation, ?arrayType, ?arrayHeapStr, "java.lang.Class[]").

CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:Class:getMethods(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Method[] getMethods()>"),
  ReflectiveKnownArrayMacro(?invocation, ?arrayType, ?arrayHeapStr, "java.lang.reflect.Method[]").

java:lang:Class:getMethod(?to, ?param, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>"),
  ActualParam[0, ?invocation] = ?param.

CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:Class:getDeclaredMethods(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>"),
  ReflectiveKnownArrayMacro(?invocation, ?arrayType, ?arrayHeapStr, "java.lang.reflect.Method[]").

java:lang:Class:getDeclaredMethod(?to, ?param, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>"),
  ActualParam[0, ?invocation] = ?param.

CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:Class:getConstructors(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Constructor[] getConstructors()>"),
  ReflectiveKnownArrayMacro(?invocation, ?arrayType, ?arrayHeapStr, "java.lang.reflect.Constructor[]").

java:lang:Class:getConstructor(?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Constructor getConstructor(java.lang.Class[])>").

CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:Class:getDeclaredConstructors(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Constructor[] getDeclaredConstructors()>"),
  ReflectiveKnownArrayMacro(?invocation, ?arrayType, ?arrayHeapStr, "java.lang.reflect.Constructor[]").

java:lang:Class:getDeclaredConstructor(?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Constructor getDeclaredConstructor(java.lang.Class[])>").

CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:Class:getFields(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Field[] getFields()>"),
  ReflectiveKnownArrayMacro(?invocation, ?arrayType, ?arrayHeapStr, "java.lang.reflect.Field[]").

java:lang:Class:getField(?to, ?param, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>"),
  ActualParam[0, ?invocation] = ?param.

CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:Class:getDeclaredFields(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>"),
  ReflectiveKnownArrayMacro(?invocation, ?arrayType, ?arrayHeapStr, "java.lang.reflect.Field[]").

java:lang:Class:getDeclaredField(?to, ?param, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>"),
  ActualParam[0, ?invocation] = ?param.

// TODO Better filtering of class types
CreateReflectiveAllocationMacro(?invocation, ?type, ?heapStr),
java:lang:Class:newInstance(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.Object newInstance()>"),
  ClassType(?type), Type:Id(?type:?typeStr),
#ifdef REFLECTION_REFINED_OBJECTS
  Instruction:Id(?invocation:?invocationStr),
  ?heapStr = "<reflective Class.newInstance/" + ?invocationStr + ?typeStr + ">".
#else
// REVIEW: Does this merging lose precision?
  ?heapStr = "<reflective Class.newInstance/" + ?typeStr + ">".
#endif

CreateReflectiveAllocationMacro(?invocation, ?type, ?heapStr),
java:lang:Class:getClassLoader(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.Class: java.lang.ClassLoader getClassLoader()>"),
  // Use a single dummy value for any ClassLoader
  Type:Id(?type:"java.lang.ClassLoader"),
  ReferenceType(?type),
  ?heapStr = "<reflective dummy ClassLoader>".

CreateReflectiveAllocationMacro(?invocation, ?type, ?heapStr),
java:lang:ClassLoader:getResource(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.ClassLoader: java.net.URL getResource(java.lang.String)>"),
  // Use a single dummy value for any URL resource
  Type:Id(?type:"java.net.URL"),
  ReferenceType(?type),
  ?heapStr = "<reflective dummy URL resource>".

// TODO Handle version for multiarray? If yes, add to ReifiedClass as well
CreateReflectiveAllocationMacro(?invocation, ?arrayType, ?arrayHeapStr),
java:lang:reflect:Array:newInstance(?invocation, ?to, ?param) <-
  Method:Id(?sig:"<java.lang.reflect.Array: java.lang.Object newInstance(java.lang.Class,int)>"),
  MethodInvocation:Signature[?invocation] = ?sig,
  StaticMethodInvocation:Insn(?invocation),
  AssignReturnValue[?invocation] = ?to,
  ActualParam[0, ?invocation] = ?param,
  ArrayType(?arrayType),
  ReflectiveArrayMacro(?invocation, ?arrayType, ?arrayType, ?arrayHeapStr, "").

// TODO Better filtering of class types
CreateReflectiveAllocationMacro(?invocation, ?type, ?heapStr),
java:lang:reflect:Constructor:newInstance(?invocation, ?to, ?from) <-
  VirtualMethodMacro(?invocation, ?to, ?from, "<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>"),
  ClassType(?type), Type:Id(?type:?typeStr),
#ifdef REFLECTION_REFINED_OBJECTS
  Instruction:Id(?invocation:?invocationStr),
  ?heapStr = "<reflective Constructor.newInstance/" + ?invocationStr + ?typeStr + ">".
#else
// REVIEW: Does this merging lose precision?
  ?heapStr = "<reflective Constructor.newInstance/" + ?typeStr + ">".
#endif

// NOTE At this point, we cannot distinguish static from instance fields
java:lang:reflect:Field:get(?invocation, ?to, ?field) <-
  VirtualMethodMacro(?invocation, ?to, ?field, "<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>").

java:lang:reflect:Field:get:base[?invocation] = ?base <-
  VirtualMethodMacro(?invocation, _, _, "<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>"),
  ActualParam[0, ?invocation] = ?base.

java:lang:reflect:Field:set(?invocation, ?from, ?field) <-
  Method:Id(?signature:"<java.lang.reflect.Field: void set(java.lang.Object,java.lang.Object)>"),
  MethodInvocation:Signature[?invocation] = ?signature,
  VirtualMethodInvocation:Base[?invocation] = ?field,
  ActualParam[1, ?invocation] = ?from.

java:lang:reflect:Field:set:base[?invocation] = ?base <-
  Method:Id(?signature:"<java.lang.reflect.Field: void set(java.lang.Object,java.lang.Object)>"),
  MethodInvocation:Signature[?invocation] = ?signature,
  VirtualMethodInvocation:Insn(?invocation),
  ActualParam[0, ?invocation] = ?base.

java:lang:reflect:Method:invoke(?invocation, ?method) <-
  Method:Id(?signature:"<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>"),
  MethodInvocation:Signature[?invocation] = ?signature,
  VirtualMethodInvocation:Base[?invocation] = ?method.


// We use a distinct value abstraction for every java.lang.Class, i.e., for
// every class type that appears in the bytecode, for example '<class
// java.lang.String>'. The predicate ReifiedClass is used to look up the value
// abstraction for a given type.

// Objects created by newInstance invocations are represented by a generated
// heap allocation, a combination of the invocation-site of newInstance and the
// type of the allocated object.

ClassHeapConsMacro(?classValueId, ?javaLangClass, ?classValue),
ReifiedClass[?type] = ?classValue
<-
  ReferenceType(?type),
  Type:Id(?type:?typeStr),
  ?classValueId = "<class " + ?typeStr + ">",
  Type:Id(?javaLangClass:"java.lang.Class").


// Heap allocations for reified constructors (java.lang.reflect.Constructor)
MockHeapConsMacro(?id, ?type, ?value),
ReifiedConstructor[?signature] = ?value
<-
  Method:SimpleName[?signature] = "<init>",
  Method:Id(?signature:?strSignature),
  ?id = "<<reified constructor " + ?strSignature + ">>",
  Type:Id(?type:"java.lang.reflect.Constructor").


// Heap allocations for reified methods (java.lang.reflect.Method).
// TODO: contains temporary solution against huge method signatures.
MockHeapConsMacro(?id, ?type, ?value),
ReifiedMethod[?signature] = ?value
<-
  Method:SimpleName[?signature] = ?simplename,
  ?simplename != "<init>", ?simplename != "<clinit>",
  Method:Id(?signature:?strSignature),
  ?id = "<<reified method " + ?strSignature + ">>",
  Type:Id(?type:"java.lang.reflect.Method").


// Heap allocations for reified fields (java.lang.reflect.Field).
MockHeapConsMacro(?id, ?type, ?value),
ReifiedField[?fld] = ?value
<-
  Field:Id(?fld:?signature),
  ?id = "<<reified field " + ?signature + ">>",
  Type:Id(?type:"java.lang.reflect.Field").

ReifiedClass:Value[?type] = ?value <-
  ReifiedClass[?type] = ?heap,
  Value:byHeap[?heap] = ?value.
ReifiedConstructor:Value[?sig] = ?value <-
  ReifiedConstructor[?sig] = ?heap,
  Value:byHeap[?heap] = ?value.
ReifiedMethod:Value[?sig] = ?value <-
  ReifiedMethod[?sig] = ?heap,
  Value:byHeap[?heap] = ?value.
ReifiedField:Value[?fld] = ?value <-
  ReifiedField[?fld] = ?heap,
  Value:byHeap[?heap] = ?value.

/*************************************************************
 * BEGIN forward reflection logic.
 * Next we have the standard "forward" reflection logic, which considers
 * which objects have been found to flow to arguments of a reflective call.
 *************************************************************
 *************************************************************
 * Reflective method calls
 *
 * Issues in the documentation:
 *   - Class.getDeclaredMethods does not specify that <init> is not returned.
 *   - Method.invoke does not specify that private method calls do not do method lookup
 *   - It is impossible to call an overridden method in a super class.
 *
 * Issues in Livshits' reflection analysis:
 *   - no dynamic method lookup for instance methods (interface, abstract, overriden)
 *   - no handling of exceptions
 *   - unclear how to make context-sensitive
 *   - not sound for reflective use of reflection
 *   - no handling of boxing/unboxing
 *
 * Test:
 *   - static initialization
 *   - context-sensitivity
 *   - virtual method lookup
 *   - method declared in class of objParam
 *
 * TODO Boxing of primitive results
 *
 *************************************************************/


// Method invocations resulting from propagating Method and
// Constructor objects to reflective method invocations.

// As opposed to method invocations in the input facts, these must be
// context-sensitive for precision purposes: for a reflective method
// call sites, the invoked method can depend on the context.
ReflectiveMethodInvocation(?ctx, ?invocation, ?signature) ->
  Context(?ctx), MethodInvocation(?invocation),
  Method(?signature).

// The base variable of a reflective method call.
ReflectiveBaseVar[?invocation] = ?base ->
  MethodInvocation(?invocation),
  Var(?base).

// The return variable of a reflective method call.
ReflectiveAssignReturnValue[?invocation] = ?base ->
  MethodInvocation(?invocation),
  Var(?base).

// The variable that points-to an array of actual parameters of a
// reflective method call.
ReflectiveActualParams[?invocation] = ?actualParams ->
  MethodInvocation(?invocation),
  Var(?actualParams).

// Specific reflective method invocations.
// Reflective method invocations need to be specialized to determine
// what kind of method call this is.
ReflectiveSpecialMethodInvocation(?invocation, ?signature, ?ctx, ?base) ->
  Context(?ctx), MethodInvocation(?invocation),
  Method(?signature), Var(?base).

ReflectiveStaticMethodInvocation(?ctx, ?invocation, ?signature) ->
  Context(?ctx), MethodInvocation(?invocation),
  Method(?signature).

ReflectiveVirtualMethodInvocation(?signature, ?invocation, ?ctx, ?base) ->
  Context(?ctx), MethodInvocation(?invocation),
  Method(?signature), Var(?base).


// Private method invocations are special methods, unless they are static.

// Note that (for now) the other special method invocation cases are
// not possible: 1) instance initialization methods cannot be invoked
// reflectively using Method.invoke and 2) overridden superclass
// methods cannot be invoked through reflection.
ReflectiveSpecialMethodInvocation(?invocation, ?signature, ?ctx, ?base) <-
  ReflectiveMethodInvocation(?ctx, ?invocation, ?signature),
  Modifier:Id(?private:"private"),
  Method:Modifier(?private, ?signature),
  Modifier:Id(?static:"static"),
  ! Method:Modifier(?static, ?signature),
  ReflectiveBaseVar[?invocation] = ?base.

// Static method invocations
ReflectiveStaticMethodInvocation(?ctx, ?invocation, ?signature) <-
  ReflectiveMethodInvocation(?ctx, ?invocation, ?signature),
  Modifier:Id(?static:"static"),
  Method:Modifier(?static, ?signature).

// All others are virtual method invocations
ReflectiveVirtualMethodInvocation(?signature, ?invocation, ?ctx, ?base) <-
  ReflectiveMethodInvocation(?ctx, ?invocation, ?signature),
  Modifier:Id(?private:"private"),
  ! Method:Modifier(?private, ?signature),
  Modifier:Id(?static:"static"),
  ! Method:Modifier(?static, ?signature),
  ReflectiveBaseVar[?invocation] = ?base.


// Reflective call graph edges.
// TODO Unfortunately we have to redo the implementation of method
//      calls here. It might be a good idea to consider generation of
//      method invocations (but those are input predicates).

// A reflective call graph edge has specific details for propagating
// parameters and handling return values, so we distinguish them from
// native and normal call graph edges.
ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?callee) ->
  Context(?callerCtx), MethodInvocation(?invocation),
  Context(?calleeCtx), Method(?callee).

ReachableContext(?calleeCtx, ?callee) <-
  ReflectiveCallGraphEdge(_, _, ?calleeCtx, ?callee).


// Static methods
#ifdef REFLECTION_CONTEXT_SENSITIVITY
// REVIEW (YS): Could add back the refinement functionality, but given the
// (currently) marginal value of both context-sensitive reflection and 
// refinement-based analyses, it just isn't worth the trouble.
ReflectiveMergeStaticMacro(?callerCtx, ?invocation, ?calleeCtx),
ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?callee) <-
  ReflectiveStaticMethodInvocation(?callerCtx, ?invocation, ?callee).
#else
ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?callee) <-
  ImmutableContextFromContext[?callerCtx] = ?calleeCtx,
  ReflectiveStaticMethodInvocation(?callerCtx, ?invocation, ?callee).
#endif


// Special methods
#ifdef REFLECTION_CONTEXT_SENSITIVITY
ReflectiveMergeMacro(?callerCtx, ?invocation, ?hctx, ?value, ?calleeCtx),
ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?callee),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?this)
  <-
  VarPointsTo(?hctx, ?value,  ?callerCtx, ?base),
  ReflectiveSpecialMethodInvocation(?invocation, ?callee, ?callerCtx, ?base),
  ThisVar[?callee] = ?this,
  SupertypeOf(Var:Type[?this], Value:Type[?value]).
#else
ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?callee),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?this)
  <-
  ImmutableContextFromHContext[?hctx] = ?calleeCtx,
  VarPointsTo(?hctx, ?value,  ?callerCtx, ?base),
  ReflectiveSpecialMethodInvocation(?invocation, ?callee, ?callerCtx, ?base),
  ThisVar[?callee] = ?this,
// Check if object is an instance of the class declaring the method. It's a
// special method. Should they be identical types? Probably not. Can use
// special reflective calls to call private superclass methods.
  SupertypeOf(Var:Type[?this], Value:Type[?value]).
#endif


// Virtual methods

// TODO Check if object is an instance of the class declaring the
//      method (only overapproximation)

// It is horrible that I have to materialize this relation. But in ultra-heavy
// analyses, the engine does not perform this join first, thus getting the
// analysis stuck forever.
WTFReflectiveVirtualMethodInvocationBaseValue(?hctx, ?value, ?callerCtx, ?invocation, ?signature) <-
  VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
  ReflectiveVirtualMethodInvocation(?signature, ?invocation, ?callerCtx, ?base).

#ifdef REFLECTION_CONTEXT_SENSITIVITY
ReflectiveMergeMacro(?callerCtx, ?invocation, ?hctx, ?value, ?calleeCtx),
ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?this)
  <-
  WTFReflectiveVirtualMethodInvocationBaseValue(?hctx, ?value, ?callerCtx, ?invocation, ?signature),
  Value:Type[?value] = ?valuetype,
  Method:DeclaringType[?signature] = ?type,
  SupertypeOf(?type, ?valuetype), // TODO need nicer check
  Method:SimpleName[?signature] = ?simplename,
  Method:Descriptor[?signature] = ?descriptor,
  MethodLookup[?simplename, ?descriptor, ?valuetype] = ?tomethod,
  ThisVar[?tomethod] = ?this.
#else
ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?this)
  <-
  ImmutableContextFromHContext[?hctx] = ?calleeCtx,
  WTFReflectiveVirtualMethodInvocationBaseValue(?hctx, ?value, ?callerCtx, ?invocation, ?signature),
  Value:Type[?value] = ?valuetype,
  Method:DeclaringType[?signature] = ?type,
  SupertypeOf(?type, ?valuetype), // TODO need nicer check
  Method:SimpleName[?signature] = ?simplename,
  Method:Descriptor[?signature] = ?descriptor,
  MethodLookup[?simplename, ?descriptor, ?valuetype] = ?tomethod,
  ThisVar[?tomethod] = ?this.
#endif

// Return values of reflective method invocations
OptInterproceduralAssign(?callerCtx, ?local, ?calleeCtx, ?return) <-
  ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?callee),
  ReflectiveAssignReturnValue[?invocation] = ?local,
  ReturnVar(?return, ?callee).

InvokeArgLoadArrayIndex(?calleeCtx, ?formal, ?callerCtx, ?actual) <-
  ReflectiveCallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?callee),
  FormalParam[_, ?callee] = ?formal,
  ReflectiveActualParams[?invocation] = ?actual.

/*************************************************************
 * 
 * Reflective values
 *
 *************************************************************/

// Basically this is only used for special methods and it has very
// clever logic: we don't have a receiver var when we are calling
// a constructor reflectively. So, instead, we remember in the
// AssignReflectiveAllocation predicate the variable that the
// result of the reflective construction will be assigned to! Then
// we pretend the reflectively allocated object is already assigned
// to that local variable and use that local variable to initialize
// the "this" var of the constructor, as if this local variable (to
// which the object will be assigned after it is constructed) is the
// receiver object. It took me hours to thorougly convince myself this
// works. (YS)

AssignReflectiveAllocation(?instruction, ?type, ?ctx, ?var) ->
  Context(?ctx), Var(?var), Type(?type), Instruction(?instruction).

#ifdef REFLECTION_CONTEXT_SENSITIVITY
ReflectiveRecordMacro(?ctx, ?value, ?hctx),
InitializedClass(?type),
VarPointsTo(?hctx, ?value, ?ctx, ?var) <-
  AssignReflectiveAllocation(?instruction, ?type, ?ctx, ?var), // recursive
  ReflectiveAllocation[?instruction, ?type]  = ?heap,
  Value:byHeap[?heap] = ?value,
  Var:Type[?var] = ?vartype,
  SubtypeOf(?type, ?vartype).
#else
InitializedClass(?type),
VarPointsTo(?hctx, ?value, ?ctx, ?var) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  AssignReflectiveAllocation(?instruction, ?type, ?ctx, ?var), // recursive
  ReflectiveAllocation[?instruction, ?type]  = ?heap,
  Value:byHeap[?heap] = ?value,
  Var:Type[?var] = ?vartype,
  SubtypeOf(?type, ?vartype).
#endif


//// There are hundreds of thousands of ReflectiveAllocation facts typically. 
//// I don't think it *ever* makes sense to treat them context-sensitively.(YS)
//InitializedClass(?type),
//RecordMacro(?ctx, ?value, ?hctx),
//VarPointsTo(?hctx, ?value, ?ctx, ?var) <-
//  AssignReflectiveAllocation(?instruction, ?type, ?ctx, ?var), // recursive
//  ReflectiveAllocation[?instruction, ?type]  = ?heap,
//  Value:byHeap[?heap] = ?value,
//  ObjectShouldNotBeRefined(?value).
//
//#ifdef RecordRefinedMacro
//InitializedClass(?type),
//RecordRefinedMacro(?ctx, ?value, ?hctx),
//VarPointsTo(?hctx, ?value, ?ctx, ?var) <-
//  AssignReflectiveAllocation(?instruction, ?type, ?ctx, ?var), // recursive
//  ReflectiveAllocation[?instruction, ?type]  = ?heap,
//  Value:byHeap[?heap] = ?value,
//  ObjectShouldBeRefined(?value).
//#endif

/*************************************************************
 * Reflective assignment of class constants
 *************************************************************/

ReflectiveAssignClassConstant(?ctx, ?invocation, ?type) ->
  Context(?ctx), MethodInvocation(?invocation), Type(?type).

ForwardReflectiveAssignClassConstant(?ctx, ?invocation, ?type) ->
  Context(?ctx), MethodInvocation(?invocation), Type(?type).

BackwardReflectiveAssignClassConstant(?ctx, ?invocation, ?type) ->
  Context(?ctx), MethodInvocation(?invocation), Type(?type).

ReflectiveAssignClassConstant(?ctx, ?invocation, ?type) <-
  ForwardReflectiveAssignClassConstant(?ctx, ?invocation, ?type).


/**
 * Not every virtual method invocation has a return value, so we need
 * to initialize classes separate from the VarPointsTo rule.
 */
InitializedClass(?type) <-
  ReflectiveAssignClassConstant(_, _, ?type).

/**
 * TODO This doesn't make any sense without a 'to' variable.
 */
VarPointsTo(?hctx, ?value, ?ctx, ?return) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  ReflectiveAssignClassConstant(?ctx, ?invocation, ?type),
  ReifiedClass:Value[?type] = ?value,
  AssignReturnValue[?invocation] = ?return.

/*************************************************************
 * Reflective load of array index. 
 * The array is the array of args of a reflective call (e.g.,
 * Method.invoke(Object[] args) ).
 *************************************************************/

InvokeArgLoadArrayIndex(?calleeCtx, ?to, ?callerCtx, ?base) ->
  Context(?calleeCtx), Var(?to),
  Context(?callerCtx), Var(?base).

/**
 * It's unfortunate this code is so similar to normal LoadArrayIndex.
 * But it's not identical because there are type casts performed silently
 * when the array is just passing arguments to a reflective method call
 */
LoadReflectiveValueArrayIndex(?calleeCtx, ?to, ?basehctx, ?basevalue) <-
  InvokeArgLoadArrayIndex(?calleeCtx, ?to, ?callerCtx, ?base),
  VarPointsTo(?basehctx, ?basevalue, ?callerCtx, ?base).

VarPointsTo(?hctx, ?value, ?ctx, ?to) <-
  LoadReflectiveValueArrayIndex(?ctx, ?to, ?basehctx, ?basevalue),
  ArrayIndexPointsTo(?hctx, ?value, ?basehctx, ?basevalue),
  Var:Type[?to] = ?type,
  Value:Type[?value] = ?valuetype,
  SupertypeOf(?type, ?valuetype).

/// This is unnecessary. It's already done by ArrayIndexPointsTo.
//  // Additional type filtering based on array covariance
//  Value:Type[?basevalue] = ?arraytype,
//  ComponentType[?arraytype] = ?componenttype,
//  SupertypeOf(?componenttype, ?valuetype).

/*************************************************************
 * Reflective load of a static field
 *
 * TODO does this trigger class initialization?
 *************************************************************/

ReflectiveLoadStaticField(?ctx, ?to, ?signature) ->
  Field(?signature), Context(?ctx), Var(?to).

VarPointsTo(?hctx, ?value, ?ctx, ?to) <-
  ReflectiveLoadStaticField(?ctx, ?to, ?signature),
  StaticFieldPointsTo(?hctx, ?value, ?signature),
  Value:Type[?value] = ?valuetype,
  Var:Type[?to] = ?vartype, 
  SupertypeOf(?vartype, ?valuetype).

/*************************************************************
 * Reflective store of a static field
 *
 * TODO does this trigger class initialization?
 *************************************************************/

ReflectiveStoreStaticField(?signature, ?ctx, ?from) ->
  Field(?signature), Context(?ctx), Var(?from).

StaticFieldPointsTo(?hctx, ?value, ?signature) <-
  ReflectiveStoreStaticField(?signature, ?ctx, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  Value:Type[?value] = ?valuetype,
  Field:Type[?signature] = ?fieldtype, 
  SupertypeOf(?fieldtype, ?valuetype).

/*************************************************************
 * Reflective load of an instance field
 *************************************************************/

ReflectiveLoadInstanceField(?toCtx, ?to, ?signature, ?baseCtx, ?base) ->
  Context(?baseCtx), Var(?base), Field(?signature),
  Context(?toCtx), Var(?to).
ReflectiveLoadHeapInstanceField(?toCtx, ?to, ?signature, ?basehctx, ?basevalue) ->
  HContext(?basehctx), Value(?basevalue), Field(?signature),
  Context(?toCtx), Var(?to).

ReflectiveLoadHeapInstanceField(?toCtx, ?to, ?sig, ?basehctx, ?basevalue) <-
  ReflectiveLoadInstanceField(?toCtx, ?to, ?sig, ?baseCtx, ?base),
  Value:Type[?basevalue] = ?basevaluetype,
  Field:DeclaringType[?sig] = ?declaringClass,
  SupertypeOf(?declaringClass, ?basevaluetype),
  VarPointsTo(?basehctx, ?basevalue, ?baseCtx, ?base).

// The code below is very similar to the logic in the main analysis,
// however we split it out because of the need (here, but not for
// normal value loads) to filter type-incorrect values.
VarPointsTo(?hctx, ?value, ?ctx, ?to) <-
  ReflectiveLoadHeapInstanceField(?ctx, ?to, ?signature, ?basehctx, ?basevalue),
  InstanceFieldPointsTo(?hctx, ?value, ?signature, ?basehctx, ?basevalue),
  Value:Type[?value] = ?valuetype,
  Var:Type[?to] = ?vartype,
  SupertypeOf(?vartype, ?valuetype).


/*************************************************************
 * Reflective store of an instance field
 *************************************************************/

ReflectiveStoreInstanceField(?fromCtx, ?from, ?signature, ?baseCtx, ?base) ->
  Context(?fromCtx), Var(?from), Context(?baseCtx), Var(?base),
  Field(?signature).
ReflectiveStoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?fromCtx, ?from) ->
  Context(?fromCtx), Var(?from), Value(?basevalue), HContext(?basehctx),
  Field(?signature).

ReflectiveStoreHeapInstanceField(?sig, ?basehctx, ?basevalue, ?fromCtx, ?from) <-
  ReflectiveStoreInstanceField(?fromCtx, ?from, ?sig, ?baseCtx, ?base),
  Value:Type[?basevalue] = ?basevaluetype,
  Field:DeclaringType[?sig] = ?declaringClass,
  SupertypeOf(?declaringClass, ?basevaluetype),
  VarPointsTo(?basehctx, ?basevalue, ?baseCtx, ?base).

// The code below is very similar to the logic in the main analysis,
// however we split it out because of the need (here, but not for
// normal value loads) to filter type-incorrect values.
InstanceFieldPointsTo(?hctx, ?value, ?signature, ?basehctx, ?basevalue) <-
  ReflectiveStoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?ctx, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  Value:Null[] != ?basevalue,
  NotSpecialValue(?value),
  Value:Type[?value] = ?valuetype,
  Field:Type[?signature] = ?fieldtype,
  SupertypeOf(?fieldtype, ?valuetype).

/*************************************************************
 * END forward reflection logic
 *************************************************************/


#if defined(REFLECTION_USE_BASED_ANALYSIS) || defined(REFLECTION_INVENT_UNKNOWN_OBJECTS)

// Auxiliary relation for both kinds of analyses.
NumberOfSubtypes[?type] = ?n ->
  Type(?type), int[64](?n).
NumberOfSubtypes[?type] = ?count <-
  agg<<?count = count()>>(SubtypeOf(_, ?type)).

#endif

/*************************************************************
 * BEGIN backward reflection logic ("use-based analysis")
 * This examines where the values produced by reflection flow to,
 * (e.g., to a cast, or to selection of a method with a specific
 * name) and infers what these values must have been.
 *************************************************************
 *************************************************************
 * First create objects for the backward logic
 *************************************************************/

#ifdef REFLECTION_USE_BASED_ANALYSIS

MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingForNameHeap[?invocation] = ?heap
<-
  java:lang:Class:forName(?invocation, _),
  Type:Id(?type:"java.lang.Class"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing forName values " + ?strInvocation + ">".

// Note how the return type is that of newInstance (Object), although the relation remembers the forName
// call that produced the Class on which newInstance got called.
MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingNewInstanceHeap[?invocation] = ?heap
<-
  java:lang:Class:forName(?invocation, _),
  Type:Id(?type:"java.lang.Object"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing newInstance values " + ?strInvocation + ">".

// Special value value that propagates through all constructor calls and remembers the original forName 
MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingGetConstructorHeap[?invocation] = ?heap
<-
  java:lang:Class:forName(?invocation, _),
  Type:Id(?type:"java.lang.reflect.Constructor"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing get[Declared]Constructor[s] values " + ?strInvocation + ">".

// getMethods and getDeclaredMethods are handled the same in terms of detecting
// where their unknown result flows to. Note how the return type is a single Method
// and not an array. The array is always there, the special value just gets added to
// its contents to represent all unknown methods collectively.
MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingGetMethodsHeap[?invocation] = ?heap
<-
  (Method:Id(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>") ;
   Method:Id(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getMethods()>")),
  MethodInvocation:Signature[?invocation] = ?getMethods,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.reflect.Method"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing get[Declared]Methods values " + ?strInvocation + ">".

MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingInvokeHeapFromGetMethods[?invocation] = ?heap
<-
  (Method:Id(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>") ;
   Method:Id(?getMethods:"<java.lang.Class: java.lang.reflect.Method[] getMethods()>")),
  MethodInvocation:Signature[?invocation] = ?getMethods,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.Object"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing invoke() values " + ?strInvocation + ">".

MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingGetMethodHeap[?invocation] = ?heap
<-
  (Method:Id(?getMethod:"<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>") ;
   Method:Id(?getMethod:"<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>")),
  MethodInvocation:Signature[?invocation] = ?getMethod,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.reflect.Method"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing get[Declared]Method values " + ?strInvocation + ">".

MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingInvokeHeapFromGetMethod[?invocation] = ?heap
<-
  (Method:Id(?getMethod:"<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>") ;
   Method:Id(?getMethod:"<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>")),
  MethodInvocation:Signature[?invocation] = ?getMethod,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.Object"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing invoke() values " + ?strInvocation + ">".

// Special objects for get[Declared]Field[s]. Very similar to methods.
MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingGetFieldsHeap[?invocation] = ?heap
<-
  (Method:Id(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>") ;
   Method:Id(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getFields()>")),
  MethodInvocation:Signature[?invocation] = ?getFields,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.reflect.Field"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing get[Declared]Fields values " + ?strInvocation + ">".

MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingGetHeapFromGetFields[?invocation] = ?heap
<-
  (Method:Id(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>") ;
   Method:Id(?getFields:"<java.lang.Class: java.lang.reflect.Field[] getFields()>")),
  MethodInvocation:Signature[?invocation] = ?getFields,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.Object"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing get() values " + ?strInvocation + ">".

MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingGetFieldHeap[?invocation] = ?heap
<-
  (Method:Id(?getField:"<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>") ;
   Method:Id(?getField:"<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>")),
  MethodInvocation:Signature[?invocation] = ?getField,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.reflect.Field"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing get[Declared]Field values " + ?strInvocation + ">".

MockHeapConsMacro(?strHeap, ?type, ?heap),
SpecialMissingGetHeapFromGetField[?invocation] = ?heap
<-
  (Method:Id(?getField:"<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>") ;
   Method:Id(?getField:"<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>")),
  MethodInvocation:Signature[?invocation] = ?getField,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.Object"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing get() values " + ?strInvocation + ">".


/*************************************************************
 * Next come the real backward reflection analysis inferences
 *************************************************************/

// Logic to catch unknown results of Class.forName invocations.
// These may flow to casts, so we'll get useful info back.
VarPointsTo(?hctx, ?value, ?ctx, ?return) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  SpecialMissingForNameHeap[?invocation] = ?heap,
  Value:byHeap[?heap] = ?value,
  AssignReturnValue[?invocation] = ?return,
  Instruction:Method[?invocation] = ?inmethod,
  ReachableContext(?ctx, ?inmethod).

// Special object just to designate the unknown values returned by
// Class.newInstance. At every newInstance to which an unknown object
// created by forName flows, we return a new unknown object 
// (of type Object and not Class) that remembers the forName site.
VarPointsTo(?hctx, ?specialvalue, ?ctx, ?to) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  java:lang:Class:newInstance(_, ?to, ?var),
  VarPointsTo(_, ?specialclass, ?ctx, ?var),
  Value:Heap[?specialclass] = ?specialclassHeap,
  OptSpecialMissingForNameHeap(?forNameInvocation, ?specialclassHeap), 
  SpecialMissingNewInstanceHeap[?forNameInvocation] = ?specialheap,
  Value:byHeap[?specialheap] = ?specialvalue.

// Similar flow of special object through get[Declared]Constructor
VarPointsTo(?hctx, ?specialConstructorValue, ?ctx, ?to) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  (java:lang:Class:getConstructor(?to, ?var);
   java:lang:Class:getDeclaredConstructor(?to, ?var)),
  VarPointsTo(_, ?specialclass, ?ctx, ?var),
  Value:Heap[?specialclass] = ?specialclassHeap,
  OptSpecialMissingForNameHeap(?forNameInvocation, ?specialclassHeap), 
  SpecialMissingGetConstructorHeap[?forNameInvocation] = ?specialConstructorHeap,
  Value:byHeap[?specialConstructorHeap] = ?specialConstructorValue.

// Pretty similar for get[Declared]Constructors. The array that the
// return var points to (established by forward logic) is populated
// with the special Constructor object the call returns.
ArrayIndexPointsTo(?immCtx, ?specialConstructorValue, ?hctx, ?arrayValue) <-
  ImmutableHContextFromContext[?ctx] = ?immCtx,
  OptForNameFromGetConstructors(?forNameInvocation, ?ctx, ?to),
  VarPointsTo(?hctx, ?arrayValue, ?ctx, ?to),
  SpecialMissingGetConstructorHeap[?forNameInvocation] = ?specialConstructorHeap,
  Value:byHeap[?specialConstructorHeap] = ?specialConstructorValue.

OptForNameFromGetConstructors(?forNameInvocation, ?ctx, ?to) <-
  (java:lang:Class:getConstructors(_, ?to, ?var);
   java:lang:Class:getDeclaredConstructors(_, ?to, ?var)),
  VarPointsTo(_, ?specialclass, ?ctx, ?var),
  Value:Heap[?specialclass] = ?specialclassHeap,
  OptSpecialMissingForNameHeap(?forNameInvocation, ?specialclassHeap).

// Even though there was one more step in the special object propagation,
// in the end Constructor.newInstance is handled similarly to Class.newInstance.
VarPointsTo(?hctx, ?specialvalue, ?ctx, ?to) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  java:lang:reflect:Constructor:newInstance(_, ?to, ?var),
  VarPointsTo(_, ?specialConstructor, ?ctx, ?var),
  Value:Heap[?specialConstructor] = ?specialConstructorHeap,
  OptSpecialMissingGetConstructorHeap(?forNameInvocation, ?specialConstructorHeap),
  SpecialMissingNewInstanceHeap[?forNameInvocation] = ?specialheap,
  Value:byHeap[?specialheap] = ?specialvalue.


// some auxiliary stuff
OptSpecialMissingForNameHeap(?forNameInvocation, ?specialclass) <-
  SpecialMissingForNameHeap[?forNameInvocation] = ?specialclass.

OptSpecialMissingGetConstructorHeap(?forNameInvocation, ?specialConstructor) <-
  SpecialMissingGetConstructorHeap[?forNameInvocation] = ?specialConstructor.

ResolvedForNameInvocation(?invocation) ->
  MethodInvocation(?invocation).

// REVIEW: Highly heuristic.
// If there is an interesting string assignment in the same method,
// we assume it's a resolved call.
ResolvedForNameInvocation(?invocation) <-
  java:lang:Class:forName(?invocation, ?inmethod),
//  ActualParam[0, ?invocation] = ?param,
  AssignContextInsensitiveHeapAllocation(?string, _, ?inmethod),
  ClassNameMatchingStringConstant(?string).

ResolvedForNameInvocation(?invocation) <-
  java:lang:Class:forName(?invocation, _),
  Config:DynamicClass(_, ?invocation).

UnresolvedForNameInvocation(?ctx, ?invocation) ->
  MethodInvocation(?invocation), Context(?ctx).

// REVIEW: heuristic.
// If the parameter points to *any* non-constant, then the call
// is unresolved. Gets around the recursion through negation issue.
// Also done in ECOOP'14 paper?
UnresolvedForNameInvocation(?ctx, ?invocation) <-
  Reachable(?inMethod),
  java:lang:Class:forName(?invocation, ?inMethod),
  !ResolvedForNameInvocation(?invocation),
  ActualParam[0, ?invocation] = ?param,
  VarPointsTo(_, ?nonstring, ?ctx, ?param),
  Value:Heap[?nonstring] = ?nonstringHeap,
  !ClassNameMatchingStringConstant(?nonstringHeap).

// ... and next comes the logic to tie it all together. This is amazingly nice!
// If a special unknown object o that got created from a newInstance
// that was called on an unknown object that got returned by a forName
// gets cast to T, then go back to the forName and make all subtypes
// of T be possible returned types (their reified objects, anyway).

OptUnresolvedForNameInvocationHeap(?forNameCtx, ?forNameInvocation, ?specialvalue) <-
  SpecialMissingNewInstanceHeap[?forNameInvocation] = ?specialheap,
  Value:byHeap[?specialheap] = ?specialvalue,
  UnresolvedForNameInvocation(?forNameCtx, ?forNameInvocation).

BackwardReflectiveAssignClassConstant(?forNameCtx, ?forNameInvocation, ?type) <-
  InferredType:AssignCast(?type, ?from),
  //  ReachableContext(?ctx, ?inmethod), // implied by VPT
  VarPointsTo(_, ?specialvalue, _, ?from),
  OptUnresolvedForNameInvocationHeap(?forNameCtx, ?forNameInvocation, ?specialvalue).

//// Introduces recursion through negation
//  !ForwardReflectiveAssignClassConstant(?forNameCtx, ?forNameInvocation, _).

InferredType:AssignCast(?type, ?from) ->
  Type(?type), Var(?from).

InferredType:AssignCast(?type, ?from) <-
  OptAssignCast(?type, _, ?from),
  ClassType(?type).

InferredType:MaximumSubtypes[] = 5.

// This produces too many targets so we impose a limit on the number
// of subtypes of the type cast to.
InferredType:AssignCast(?subtype, ?from) <-
  OptAssignCast(?type, _, ?from),
  SubtypeOf(?subtype, ?type),
  ClassType(?subtype),
  NumberOfSubtypes[?type] <= InferredType:MaximumSubtypes[].            

/**
 * String-based backwards reasoning, applied to get[Declared]{Field,Method}
 **/

// Another important reasoning tool is to extract constant strings
// from getMethod/getField calls and to use those to enhance what
// forName must have returned.

TypeMatchingMethod(?type, ?constant) ->
  Type(?type), HeapAllocation(?constant).
TypeMatchingMethod(?subtype, ?constant) <-
  MethodNameMatchingStringConstant:Signature(?signature, ?constant),
  Method:DeclaringType[?signature] = ?type,
  SubtypeOf(?subtype, ?type).

NumberOfTypesMatchingMethod[?constant] = ?n ->
  HeapAllocation(?constant), int[64](?n).
NumberOfTypesMatchingMethod[?constant] = ?n <-
  agg<<?n = count()>>(TypeMatchingMethod(_,?constant)).

FairlyInformativeMethodName(?constant) <-
  NumberOfTypesMatchingMethod[?constant] <= InferredType:MaximumSubtypes[].  

// The problem is that strings are remarkably lousy in precision. A single
// string (e.g., "encode") will match many tens of methods all over the
// type hierarchy. So we need to limit this to precise strings.
BackwardReflectiveAssignClassConstant(?forNameCtx, ?forNameInvocation, ?type) <-
  (java:lang:Class:getDeclaredMethod(_, ?param, ?from) ;
   java:lang:Class:getMethod(_, ?param, ?from)),
  VarPointsTo(_, ?specialvalue, ?ctx, ?from),
  Value:Heap[?specialvalue] = ?specialheap,
  OptSpecialMissingForNameHeap(?forNameInvocation, ?specialheap),
  VarPointsTo(_, ?constant, ?ctx, ?param),
  Value:Heap[?constant] = ?constantHeap,
  FairlyInformativeMethodName(?constantHeap),
  TypeMatchingMethod(?type, ?constantHeap),
  UnresolvedForNameInvocation(?forNameCtx, ?forNameInvocation).

TypeMatchingFieldName(?type, ?constant) ->
  Type(?type), HeapAllocation(?constant).
TypeMatchingFieldName(?subtype, ?constant) <-
  FieldNameMatchingStringConstant:Signature(?signature, ?constant),
  Field:DeclaringType[?signature] = ?type,
  SubtypeOf(?subtype, ?type).

NumberOfTypesMatchingFieldName[?constant] = ?n ->
  HeapAllocation(?constant), int[64](?n).
NumberOfTypesMatchingFieldName[?constant] = ?n <-
  agg<<?n = count()>>(TypeMatchingFieldName(_,?constant)).

FairlyInformativeFieldName(?constant) <-
  NumberOfTypesMatchingFieldName[?constant] <= InferredType:MaximumSubtypes[].

BackwardReflectiveAssignClassConstant(?forNameCtx, ?forNameInvocation, ?type) <-
  (java:lang:Class:getDeclaredField(_, ?param, ?from) ;
   java:lang:Class:getField(_, ?param, ?from)),
  VarPointsTo(_, ?specialvalue, ?ctx, ?from),
  Value:Heap[?specialvalue] = ?specialheap,
  OptSpecialMissingForNameHeap(?forNameInvocation, ?specialheap),
  VarPointsTo(_, ?constant, ?ctx, ?param),
  Value:Heap[?constant] = ?constantHeap,
  FairlyInformativeFieldName(?constantHeap),
  TypeMatchingFieldName(?type, ?constantHeap),
  UnresolvedForNameInvocation(?forNameCtx, ?forNameInvocation).


ReflectiveAssignClassConstant(?ctx, ?invocation, ?type) <-
  BackwardReflectiveAssignClassConstant(?ctx, ?invocation, ?type).

/**
 * Handling of getMethods/getDeclaredMethods
 **/

OptSpecialMissingGetMethodsHeap(?getMethodsInvocation, ?specialmethod) <-
  SpecialMissingGetMethodsHeap[?getMethodsInvocation] = ?specialmethod.

OptSpecialMissingInvokeHeapFromGetMethods(?invokeInvocation, ?specialheap) <-
  SpecialMissingInvokeHeapFromGetMethods[?invokeInvocation] = ?specialheap.

// The array that the return var points to (established by forward logic)
// is populated with the special Method object the call returns.
ArrayIndexPointsTo(?immCtx, ?value, ?hctx, ?arrayValue) <-
  ImmutableHContextFromContext[?ctx] = ?immCtx,
  SpecialMissingGetMethodsHeap[?invocation] = ?heap,
  Value:byHeap[?heap] = ?value,
  AssignReturnValue[?invocation] = ?return,
  VarPointsTo(?hctx, ?arrayValue, ?ctx, ?return), 
  Context(?ctx). // hack to avoid warning

OptReifiedClass(?type, ?classValue) ->
  Type(?type), Value(?classValue).
OptReifiedClass(?type, ?classValue) <-
  ReifiedClass:Value[?type] = ?classValue.

// Is this slow? We've already done it in forward logic. Maybe store/reuse.
OptGetMethodsClass(?type, ?getMethodsInvocation) <-
  (java:lang:Class:getMethods(?getMethodsInvocation, _, ?from);
   java:lang:Class:getDeclaredMethods(?getMethodsInvocation, _, ?from)),
  VarPointsTo(_, ?classValue, _, ?from),
  OptReifiedClass(?type, ?classValue).


OptInvokeOnSpecialMissingGetMethodsHeap(?getMethodsInvocation , ?ctx, ?invocation) <-
  java:lang:reflect:Method:invoke(?invocation, ?methodVar),
  VarPointsTo(_, ?specialMethodValue, ?ctx, ?methodVar),
  Value:Heap[?specialMethodValue] = ?specialMethodHeap,
  OptSpecialMissingGetMethodsHeap(?getMethodsInvocation, ?specialMethodHeap).


// Make an invoke return a special object that remembers the method it's
// supposed to be called on.
VarPointsTo(?hctx, ?specialvalue, ?ctx, ?var) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  OptInvokeOnSpecialMissingGetMethodsHeap(?getMethodsInvocation , ?ctx, ?invocation),
  SpecialMissingInvokeHeapFromGetMethods[?getMethodsInvocation] = ?specialheap,
  Value:byHeap[?specialheap] = ?specialvalue,
  AssignReturnValue[?invocation] = ?var.
//// Does nothing but incur cost: filtering to ensure that the base of
//// the reflective invocation is compatible with what we know about
//// the class the reflective method came from.
//  ActualParam[0, ?invocation] = ?base,
//  VarPointsTo(_, ?value, ?ctx, ?base),
//  OptGetMethodsClass(?type, ?getMethodsInvocation),
//  Value:Type[?value] = ?valueType,
//  SupertypeOf(?type, ?valueType).

OptMethodType(?signature, ?classtype) ->
  Method(?signature), Type(?classtype).
OptMethodType(?signature, ?classtype) <-
  Method:DeclaringType[?signature] = ?classtype.

// The clincher: if we see the cast of a result that came
// from an invoke, over a method that came from a getMethods, match
// the cast type to the class the methods came from to populate
// the return array of getMethods with the matching ones.

OptSpecialInvokeHeapCast(?type, ?getMethodsInvocation) <-
  OptAssignCast(?type, _, ?from),
  VarPointsTo(_, ?specialvalue, _, ?from),
  Value:Heap[?specialvalue] = ?specialheap,
  OptSpecialMissingInvokeHeapFromGetMethods(?getMethodsInvocation, ?specialheap).

OptMethodObjectFromInvoke(?methodValue, ?return) <-
  OptSpecialInvokeHeapCast(?type, ?getMethodsInvocation),
  OptGetMethodsClass(?classtype, ?getMethodsInvocation),
  OptMethodType(?signature, ?classtype),
  Method:ReturnType[?signature] = ?type,
  AssignReturnValue[?getMethodsInvocation] = ?return,
  ReifiedMethod:Value[?signature] = ?methodValue.

// REVIEW: why reuse the hctx? Just for lack of anything better?
ArrayIndexPointsTo(?hctx, ?methodValue, ?hctx, ?arrayValue) <-
  OptMethodObjectFromInvoke(?methodValue, ?return),
  VarPointsTo(?hctx, ?arrayValue, _, ?return).

/**
 * Handling of getMethod/getDeclaredMethod
 **/

OptSpecialMissingGetMethodHeap(?getMethodInvocation, ?specialmethod) <-
  SpecialMissingGetMethodHeap[?getMethodInvocation] = ?specialmethod.

OptSpecialMissingInvokeHeapFromGetMethod(?invokeInvocation, ?specialheap) <-
  SpecialMissingInvokeHeapFromGetMethod[?invokeInvocation] = ?specialheap.

VarPointsTo(?hctx, ?value, ?ctx, ?return) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  SpecialMissingGetMethodHeap[?invocation] = ?heap,
  Value:byHeap[?heap] = ?value,
  AssignReturnValue[?invocation] = ?return,
  Instruction:Method[?invocation] = ?inmethod,
  ReachableContext(?ctx, ?inmethod).

// Make an invoke return a special object that remembers the method it's
// supposed to be called on. See similar handling of getMethods.
VarPointsTo(?hctx, ?specialvalue, ?ctx, ?var) <-  
  ImmutableHContextFromContext[?ctx] = ?hctx,
  java:lang:reflect:Method:invoke(?invocation, ?methodVar),
  VarPointsTo(_, ?specialMethodValue, ?ctx, ?methodVar),
  Value:Heap[?specialMethodValue] = ?specialMethodHeap,
  OptSpecialMissingGetMethodHeap(?getMethodInvocation, ?specialMethodHeap),
  SpecialMissingInvokeHeapFromGetMethod[?getMethodInvocation] = ?specialheap,
  Value:byHeap[?specialheap] = ?specialvalue,
  AssignReturnValue[?invocation] = ?var.

Opt2SpecialInvokeHeapCast(?type, ?getMethodInvocation) <-
  OptAssignCast(?type, _, ?from),
  VarPointsTo(_, ?specialvalue, _, ?from),
  Value:Heap[?specialvalue] = ?specialheap,
  OptSpecialMissingInvokeHeapFromGetMethod(?getMethodInvocation, ?specialheap).

UnresolvedGetMethodInvocation(?ctx, ?invocation) ->
  MethodInvocation(?invocation), Context(?ctx).

// unresolved if var points to *any* non-constant. 
UnresolvedGetMethodInvocation(?ctx, ?invocation) <-
  VirtualMethodInvocation:Insn(?invocation),
  (MethodInvocation:Signature[?invocation] = 
   "<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>";
   MethodInvocation:Signature[?invocation] = 
   "<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>"),
  ActualParam[0, ?invocation] = ?param,
  VarPointsTo(_, ?nonstring, ?ctx, ?param),
  Value:Heap[?nonstring] = ?nonstringHeap,
  !MethodNameMatchingStringConstant(?nonstringHeap).

OptGetMethodClass(?type, ?ctx, ?getMethodInvocation) <-
  UnresolvedGetMethodInvocation(?ctx, ?getMethodInvocation),
  VirtualMethodInvocation:Base[?getMethodInvocation] = ?from,
  VarPointsTo(_, ?classValue, ?ctx, ?from),
  OptReifiedClass(?type, ?classValue).

VarPointsTo(?hctx, ?methodValue, ?ctx, ?return) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  Opt2SpecialInvokeHeapCast(?type, ?getMethodInvocation),
  OptGetMethodClass(?classtype, ?ctx, ?getMethodInvocation),
  OptMethodType(?signature, ?classtype),
  AssignReturnValue[?getMethodInvocation] = ?return,
  Method:ReturnType[?signature] = ?type,
  ReifiedMethod:Value[?signature] = ?methodValue.

/**
 *  Handling of getFields/getDeclaredFields. Very similar to methods.
 **/

OptSpecialMissingGetFieldsHeap(?getFieldsInvocation, ?specialfield) <-
  SpecialMissingGetFieldsHeap[?getFieldsInvocation] = ?specialfield.

OptSpecialMissingGetHeapFromGetFields(?getInvocation, ?specialheap) <-
  SpecialMissingGetHeapFromGetFields[?getInvocation] = ?specialheap.

// The array that the return var points to (established by forward logic)
// is populated with the special Field object the call returns.
ArrayIndexPointsTo(?immCtx, ?value, ?hctx, ?arrayValue) <-
  ImmutableHContextFromContext[?ctx] = ?immCtx,
  SpecialMissingGetFieldsHeap[?invocation] = ?heap,
  Value:byHeap[?heap] = ?value,
  AssignReturnValue[?invocation] = ?return,
  VarPointsTo(?hctx, ?arrayValue, ?ctx, ?return), 
  Context(?ctx). // hack to avoid warning

// Is this slow? We've already done it in forward logic. Maybe store/reuse.
OptGetFieldsClass(?type, ?getFieldsInvocation) <-
  (java:lang:Class:getFields(?getFieldsInvocation, _, ?from);
   java:lang:Class:getDeclaredFields(?getFieldsInvocation, _, ?from)),
  VarPointsTo(_, ?classValue, _, ?from),
  OptReifiedClass(?type, ?classValue).



OptGetOnSpecialMissingGetFieldsHeap(?getFieldsInvocation , ?ctx, ?invocation) <-
  java:lang:reflect:Field:get(?invocation, _, ?fieldVar),
  VarPointsTo(_, ?specialFieldValue, ?ctx, ?fieldVar),
  Value:Heap[?specialFieldValue] = ?specialFieldHeap,
  OptSpecialMissingGetFieldsHeap(?getFieldsInvocation, ?specialFieldHeap).


// Make a get return a special object that remembers the field it's
// supposed to be called on.
VarPointsTo(?hctx, ?specialvalue, ?ctx, ?var) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  OptGetOnSpecialMissingGetFieldsHeap(?getFieldsInvocation , ?ctx, ?invocation),
  SpecialMissingGetHeapFromGetFields[?getFieldsInvocation] = ?specialheap,
  Value:byHeap[?specialheap] = ?specialvalue,
  AssignReturnValue[?invocation] = ?var.
//// Does nothing but incur cost: filtering to ensure that the base of
//// the reflective invocation is compatible with what we know about
//// the class the reflective field came from.
//  ActualParam[0, ?invocation] = ?base,
//  VarPointsTo(_, ?value, ?ctx, ?base),
//  OptGetFieldsClass(?type, ?getFieldsInvocation),
//  Value:Type[?value] = ?valueType,
//  SupertypeOf(?type, ?valueType).

OptFieldType(?type, ?signature, ?declaringClassType) ->
   Field(?signature), Type(?declaringClassType), Type(?type).
OptFieldType(?type, ?signature, ?declaringClassType) <-
   Field:DeclaringType[?signature] = ?declaringClassType,
   Field:Type[?signature] = ?type.

// The clincher: if we see the cast of a result that came
// from a get, over a field that came from a getFields, match
// the cast type to the class the fields came from to populate
// the return array of getFields with the matching ones.

OptSpecialGetHeapCast(?type, ?getFieldsInvocation) <-
  OptAssignCast(?type, _, ?from),
  VarPointsTo(_, ?specialvalue, _, ?from),
  Value:Heap[?specialvalue] = ?specialheap,
  OptSpecialMissingGetHeapFromGetFields(?getFieldsInvocation, ?specialheap).

OptFieldObjectFromGet(?fieldValue, ?return) <-
  OptSpecialGetHeapCast(?type, ?getFieldsInvocation),
  OptGetFieldsClass(?classtype, ?getFieldsInvocation),
  OptFieldType(?type, ?signature, ?classtype),
  // REVIEW: the real test shouldn't be for type identity
  AssignReturnValue[?getFieldsInvocation] = ?return,
  ReifiedField:Value[?signature] = ?fieldValue.

// REVIEW: why reuse the hctx? Just for lack of anything better?
ArrayIndexPointsTo(?hctx, ?fieldValue, ?hctx, ?arrayValue) <-
  OptFieldObjectFromGet(?fieldValue, ?return),
  VarPointsTo(?hctx, ?arrayValue, _, ?return).

/**
 * Handling of getField/getDeclaredField
 **/

OptSpecialMissingGetFieldHeap(?getFieldInvocation, ?specialfield) <-
  SpecialMissingGetFieldHeap[?getFieldInvocation] = ?specialfield.

OptSpecialMissingGetHeapFromGetField(?getInvocation, ?specialheap) <-
  SpecialMissingGetHeapFromGetField[?getInvocation] = ?specialheap.

VarPointsTo(?hctx, ?value, ?ctx, ?return) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  SpecialMissingGetFieldHeap[?invocation] = ?heap,
  Value:byHeap[?heap] = ?value,
  AssignReturnValue[?invocation] = ?return,
  Instruction:Method[?invocation] = ?inmethod,
  ReachableContext(?ctx, ?inmethod).

// Make a get return a special object that remembers the field it's
// supposed to be called on. See similar handling of getFields.
VarPointsTo(?hctx, ?specialvalue, ?ctx, ?var) <-  
  ImmutableHContextFromContext[?ctx] = ?hctx,
  java:lang:reflect:Field:get(?invocation, _, ?fieldVar),
  VarPointsTo(_, ?specialFieldValue, ?ctx, ?fieldVar),
  Value:Heap[?specialFieldValue] = ?specialFieldHeap,
  OptSpecialMissingGetFieldHeap(?getFieldInvocation, ?specialFieldHeap),
  SpecialMissingGetHeapFromGetField[?getFieldInvocation] = ?specialheap,
  Value:byHeap[?specialheap] = ?specialvalue,
  AssignReturnValue[?invocation] = ?var.

Opt2SpecialGetHeapCast(?type, ?getFieldInvocation) <-
  OptAssignCast(?type, _, ?from),
  VarPointsTo(_, ?specialvalue, _, ?from),
  Value:Heap[?specialvalue] = ?specialheap,
  OptSpecialMissingGetHeapFromGetField(?getFieldInvocation, ?specialheap).

UnresolvedGetFieldInvocation(?ctx, ?invocation) ->
  MethodInvocation(?invocation), Context(?ctx).

// unresolved if var points to *any* non-constant. Basically pointless. Near always true.
UnresolvedGetFieldInvocation(?ctx, ?invocation) <-
   VirtualMethodInvocation:Insn(?invocation),
   (MethodInvocation:Signature[?invocation] = 
    "<java.lang.Class: java.lang.reflect.Field getField(java.lang.String)>";
    MethodInvocation:Signature[?invocation] = 
    "<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>"),
   ActualParam[0, ?invocation] = ?param,
   VarPointsTo(_, ?nonstring, ?ctx, ?param),
   Value:Heap[?nonstring] = ?nonstringHeap,
   !FieldNameMatchingStringConstant(?nonstringHeap).

OptGetFieldClass(?type, ?ctx, ?getFieldInvocation) <-
  UnresolvedGetFieldInvocation(?ctx, ?getFieldInvocation),
  VirtualMethodInvocation:Base[?getFieldInvocation] = ?from,
  VarPointsTo(_, ?classValue, ?ctx, ?from),
  OptReifiedClass(?type, ?classValue).

VarPointsTo(?hctx, ?fieldValue, ?ctx, ?return) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  Opt2SpecialGetHeapCast(?type, ?getFieldInvocation),
  OptGetFieldClass(?classtype, ?ctx, ?getFieldInvocation),
  OptFieldType(?type, ?signature, ?classtype),
  AssignReturnValue[?getFieldInvocation] = ?return,
  ReifiedField:Value[?signature] = ?fieldValue.

#endif // REFLECTION_USE_BASED_ANALYSIS

/*************************************************************
 * END backward reflection logic ("use-based analysis")
 *************************************************************/

/*************************************************************
 * BEGIN invention of objects
 * This analysis idea consists of inventing artificial objects
 * at the point of a use of a result of reflection analysis,
 * when the reflection operation produced nothing.
 *************************************************************/
#ifdef REFLECTION_INVENT_UNKNOWN_OBJECTS

/*************************************************************
 * First, create marker objects for the use of this analysis
 *************************************************************/

// This is the representative of an unknown reflective object, after it has been cast. 
// Has a real type. We pre-generate for all types and casts in the universe.
MockHeapConsMacro(?strHeap, ?type, ?heap),
UnknownReflectiveObject[?type, ?invocation] = ?heap
<-
  AssignCast(?type, _, _, _),
  ClassType(?type),
  Type:Id(?type:?strType),
  (Method:Id(?method:"<java.lang.Class: java.lang.Object newInstance()>") ;
   Method:Id(?method:"<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>") ;
   Method:Id(?method:"<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>") ;
   Method:Id(?method:"<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>")),
  MethodInvocation:Signature[?invocation] = ?method,
  VirtualMethodInvocation:Insn(?invocation),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<<unknown object of type " + ?strType + " returned by call " + ?strInvocation + ">>".

// This is the representative of an unknown reflective object that flows from the reflection
// operation to a cast.
MockHeapConsMacro(?strHeap, ?type, ?heap),
MarkerReflectiveObject[?invocation] = ?heap
<-
  (Method:Id(?method:"<java.lang.Class: java.lang.Object newInstance()>") ;
   Method:Id(?method:"<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>") ;
   Method:Id(?method:"<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>") ;
   Method:Id(?method:"<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>")),
  MethodInvocation:Signature[?invocation] = ?method,
  VirtualMethodInvocation:Insn(?invocation),
  Type:Id(?type:"java.lang.Object"),
  Instruction:Id(?invocation:?strInvocation),
  ?strHeap = "<special object for missing reflective values " + ?strInvocation + ">".

/*************************************************************
 * Next comes the main "invention of objects" analysis
 *************************************************************/
// Propagate the marker object everywhere
VarPointsTo(?hctx, ?value, ?ctx, ?return) <-
  ImmutableHContextFromContext[?ctx] = ?hctx,
  VirtualMethodInvocation:Insn(?invocation),
  (MethodInvocation:Signature[?invocation] = "<java.lang.Class: java.lang.Object newInstance()>" ;
   MethodInvocation:Signature[?invocation] = "<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>" ;
   MethodInvocation:Signature[?invocation] = "<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>" ;
   MethodInvocation:Signature[?invocation] = "<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>"),
  Instruction:Method[?invocation] = ?inmethod,
  ReachableContext(?ctx, ?inmethod),
  AssignReturnValue[?invocation] = ?return,
  MarkerReflectiveObject[?invocation] = ?heap,
  Value:byHeap[?heap] = ?value.

Opt2AssignCast(?inmethod, ?type, ?to, ?from) ->
  Method(?inmethod), Var(?from), Var(?to), Type(?type).
Opt2AssignCast(?inmethod, ?supertype, ?to, ?from) <-
  AssignCast(?supertype, ?from, ?to, ?inmethod).

OptMarkerReflectiveObject(?invocation, ?heap) ->
  MethodInvocation(?invocation), HeapAllocation(?heap).
OptMarkerReflectiveObject(?invocation, ?heap) <-
  MarkerReflectiveObject[?invocation] = ?heap.

// The idea is that at every cast that sees a reflectively produced object
// flow to it, we invent a new object (with the cast's type) and let if flow
// from the cast!
// REVIEW: the reuse of hctx is arbitrary
VarPointsTo(?hctx, ?value, ?ctx, ?to) <-  
  Opt2AssignCast(_, ?type, ?to, ?from),
  VarPointsTo(?hctx, ?markervalue, ?ctx, ?from),
  Value:Heap[?markervalue] = ?markerheap,
  OptMarkerReflectiveObject(?invocation, ?markerheap),
  UnknownReflectiveObject[?type, ?invocation] = ?heap,
  Value:byHeap[?heap] = ?value.

//// Not sure this pays off. Even worse, it is too slow to generate
//// all possible unknown objects via delta logic.
//  UnknownReflectiveObject[?subtype, ?invocation] = ?heap,
//  OptFilteredCastSubtype(?subtype, ?type).
//
// MaximumSubtypesForInvented[] = 10.
//
// OptFilteredCastSubtype(?subtype, ?type) ->
//   Type(?type), Type(?subtype).
// OptFilteredCastSubtype(?type, ?type) <-
//   Opt2AssignCast(_, ?type, _, _),
//   ClassType(?type).
// OptFilteredCastSubtype(?subtype, ?type) <-
//   Opt2AssignCast(_, ?type, _, _),
//   SubtypeOf(?subtype, ?type),
//   ClassType(?subtype),
//   NumberOfSubtypes[?type] <= MaximumSubtypesForInvented[].            
  
#endif // REFLECTION_INVENT_UNKNOWN_OBJECTS

/*************************************************************
 * END invention of objects
 *************************************************************/

// Mark all the above special objects
SpecialObject(?heap) <-
  SpecialMissingForNameHeap[_] = ?heap;
  SpecialMissingNewInstanceHeap[_] = ?heap;
  SpecialMissingGetConstructorHeap[_] = ?heap;
  SpecialMissingGetMethodHeap[_] = ?heap;
  SpecialMissingGetMethodsHeap[_] = ?heap;
  SpecialMissingInvokeHeapFromGetMethod[_] = ?heap;
  SpecialMissingInvokeHeapFromGetMethods[_] = ?heap;
  SpecialMissingGetFieldHeap[_] = ?heap;
  SpecialMissingGetFieldsHeap[_] = ?heap;
  SpecialMissingGetHeapFromGetField[_] = ?heap;
  SpecialMissingGetHeapFromGetFields[_] = ?heap.
