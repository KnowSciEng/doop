/*************************************************************
 * MethodHandle constants
 *************************************************************/

HeapAllocation:ContextInsensitive(?heap) <-
  MethodHandleConstant(?heap).

#define LAMBDA_METAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"

#define LAMBDA_ALTMETAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>"

/* Method references are wrapped by calling invokedynamic with
   boostrap method being the lambda metafactory and the second
   bootstrap argument being a constant method handle. The result
   'value' of the invokedynamic is a lambda, which contains an
   instance method calling static method 'realMethod'. */

ConstantMethodHandleLambda(?value, ?dynName, ?dynRet, ?realMethod) ->
   Value(?value), string(?dynName), string(?dynRet), Method(?realMethod).

VarPointsTo(?hctx, ?value, ?ctx, ?var),
MockValueConsMacro(?valueId, ?interface, ?value),
ConstantMethodHandleLambda(?value, ?dynName, ?dynRet, ?realMethod) <-
   DynamicMethodInvocation:Insn(?invo),
   BootstrapParam[1, ?invo] = ?handleVar,
   DynamicMethodInvocation:Bootstrap[?invo] = ?bootMethod,
   Method:Id(?bootMethod:LAMBDA_METAFACTORY_ID),
   VarPointsTo(?hctx, ?handleVal, ?ctx, ?handleVar),
   Value:Heap[?handleVal] = ?handle,
   MethodHandleConstant:Method[?handle] = ?realMethod,
   DynamicMethodInvocation:DynName[?invo] = ?dynName,
   DynamicMethodInvocation:DynReturnType[?invo] = ?dynRet,
   InterfaceType(?interface), Type:Id(?interface:?dynRet),
   AssignReturnValue[?invo] = ?var,
   Instruction:Id(?invo:?invoId),
   ?valueId = "<lambda " + ?dynRet + "::" + ?dynName + " at " + ?invoId + ">".

/* Record invokedynamic invocations whose bootstrap methods are not
   handled at all. */
UnhandledInvokedynamic(?i, ?bootMethodId) ->
   DynamicMethodInvocation:Insn(?i), string(?bootMethodId).

UnhandledInvokedynamic(?i, ?bootMethodId) <-
   DynamicMethodInvocation:Insn(?i),
   DynamicMethodInvocation:Bootstrap[?i] = ?bootMethod,
   Method:Id(?bootMethod:?bootMethodId),
   // ?bootMethodId != LAMBDA_ALTMETAFACTORY_ID,
   ?bootMethodId != LAMBDA_METAFACTORY_ID.

/* When invokeinterface is called on a lambda object constructed by a
   constant method handle, then its real static method is called. This
   proxying converts the static method pointed to by the method handle
   to an instance method. */

InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?m) ->
   Context(?callerCtx), VirtualMethodInvocation:Insn(?i),
   Context(?calleeCtx), Method(?m).

InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?realMethod) <-
   ConstantMethodHandleLambda(?value, ?dynName, _, ?realMethod),
   VirtualMethodInvocation:Base[?i] = ?var,
   VarPointsTo(_, ?value, ?callerCtx, ?var),
   ImmutableContextFromContext[?callerCtx] = ?calleeCtx,
   VirtualMethodInvocation:SimpleName[?i] = ?dynName.

ReachableContext(?calleeCtx, ?callee) <-
   InvokedynamicCallGraphEdge(_, _, ?calleeCtx, ?callee).
