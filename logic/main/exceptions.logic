/**
 * Compute for an instruction which exception handlers handle which exception
 * types
 */
ExceptionHandler:At[?type, ?instruction] = ?handler ->
   ExceptionHandler(?handler), Type(?type), Instruction(?instruction).

ImpossibleExceptionHandler(?handler, ?type, ?instruction) ->
   ExceptionHandler(?handler), Type(?type), Instruction(?instruction).

/**
 * All possible handlers of an exception type for an instruction
 */
PossibleExceptionHandler(?handler, ?type, ?instruction) ->
   ExceptionHandler(?handler),
   Type(?type),
   Instruction(?instruction).

/**
 * Instructions that are in the range of an exception handler
 */
ExceptionHandler:InRange(?handler, ?instruction) ->
   ExceptionHandler(?handler),
   Instruction(?instruction).

/**
 * Transitive closure of ExceptionHandler:Previous.
 */
ExceptionHandler:Before(?before, ?handler) ->
   ExceptionHandler(?before),
   ExceptionHandler(?handler).

InRangeOfExceptionHandler(?instruction) -> Instruction(?instruction).
/**
 * (REVIEW-Yannis) Note how this logic is superlinear. We keep relations that
 * link every exception handler to every relevant (i.e., throw or methcall)
 * instruction under its range, and to every type that the exception handler
 * can handle, including all subtypes of the declared type.  It is not easy to
 * change this, nor perhaps too valuable. But it is certainly a spot where
 * bottom-up evaluation with an explicit representation hurts us.  We have very
 * large ExceptionHandler:At, PossibleExceptionHandler, etc. relations.
 * NOTE: currently exception objects are allocated context-insensitively.
/**
 * An exception of a specific type, thrown at an instruction, is handled by an
 * exception handler.
 */
ExceptionHandler:At[?type, ?instruction] = ?handler <-
   PossibleExceptionHandler(?handler, ?type, ?instruction),
   !ImpossibleExceptionHandler(?handler, ?type, ?instruction).

/**
 * An exception type that is caught by an earlier exception handler (not
 * ?handler).
 */
ImpossibleExceptionHandler(?handler, ?type, ?instruction) <-
   PossibleExceptionHandler(?handler, ?type, ?instruction),
   ExceptionHandler:Before(?previous, ?handler),
   PossibleExceptionHandler(?previous, ?type, ?instruction).

PossibleExceptionHandler(?handler, ?type, ?instruction) <-
   ExceptionHandler:InRange(?handler, ?instruction),
   ExceptionHandler:Type[?handler] = ?type.

PossibleExceptionHandler(?handler, ?subtype, ?instruction) <-
   ExceptionHandler:InRange(?handler, ?instruction),
   ExceptionHandler:Type[?handler] = ?type,
   Superclass(?subtype, ?type).


ExceptionHandler:InRange(?handler, ?instruction) <-
   Instruction:Method[?instruction] = ?method,
   ExceptionHandler:Method[?handler] = ?method, // TODO: this could be optimized
   Instruction:Index[?instruction] = ?index,
   ExceptionHandler:Begin[?handler] = ?begin,
   ?begin <= ?index,
   ExceptionHandler:End[?handler] = ?end,
   ?index < ?end.

ExceptionHandler:Before(?previous, ?handler) <-
   ExceptionHandler:Previous[?handler] = ?previous.

ExceptionHandler:Before(?before, ?handler) <-
   ExceptionHandler:Before(?middle, ?handler),
   ExceptionHandler:Previous[?middle] = ?before.



/**
 * TODO: Implicitly thrown exceptions are not included
 */

/**
 * Represents the exceptions a method can throw
 */
ThrowPointsTo(?hctx, ?value, ?ctx, ?method) ->
   HContext(?hctx), Value(?value),
   Context(?ctx), Method(?method).



Instruction:Throws(?hctx, ?value, ?ctx, ?insn) <-
  Throw(?insn, ?var),
  VarPointsTo(?hctx, ?value, ?ctx, ?var).

Instruction:Throws(?hctx, ?value, ?callerCtx, ?invocation) <-
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod),
  ThrowPointsTo(?hctx, ?value, ?calleeCtx, ?tomethod).

ThrowPointsTo(?hctx, ?value, ?ctx, ?method) <-
  Instruction:Throws(?hctx, ?value, ?ctx, ?insn),
  Instruction:Method[?insn] = ?method,
  Value:Type[?value] = ?valueType,
   !(ExceptionHandler:At[?valueType, ?insn] = _).

VarPointsTo(?hctx, ?value, ?ctx, ?param) <-
  Instruction:Throws(?hctx, ?value, ?ctx, ?insn),
  Value:Type[?value] = ?valueType,
   ExceptionHandler:At[?valueType, ?insn] = ?handler,
   ExceptionHandler:FormalParam[?handler] = ?param.
