/* Models the dynamic proxies of Java.

   There are two ways to create a dynamic proxy instance:

   (1) G obj = (G)Proxy.newProxyInstance(c, i, h);
   (2) G obj = (G)Proxy.getProxyClass(c, i)
                       .getConstructor(InvocationHandler.class)
                       .newInstance(h);

   Compared to the spec, we have the following restrictions:

   (a) We create a single proxy per interface; if the user passes many
   interfaces, the analysis generates all possible single-interface
   proxies as a result.

   (b) We don't distinguish between different positions in the
   interface array and thus we don't use these Proxy properties
   (http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html):

     - "No two elements in the interfaces array may refer to identical
       Class objects."

     - "the order of the specified proxy interfaces is significant:
       two requests for a proxy class with the same combination of
       interfaces but in a different order will result in two distinct
       proxy classes"

     - Resolution of duplicate methods in interfaces according to the
       order of values in the interfaces array.

*/

ProxyClassOfInterface[?iface] = ?class <-
   DirectSuperinterface(?class, ?iface),
   ProxyClass(?class).
  
java:lang:reflect:Proxy:newProxyInstance(?invo, ?ret, ?handler, ?interfaces) <-
   StaticMethodInvocation:SimpleName[?invo] = "newProxyInstance",
   MethodInvocation:Signature[?invo] = ?meth,
   Method:Id(?meth:"<java.lang.reflect.Proxy: java.lang.Object newProxyInstance(java.lang.ClassLoader,java.lang.Class[],java.lang.reflect.InvocationHandler)>"),
   ActualParam[1, ?invo] = ?interfaces,
   ActualParam[2, ?invo] = ?handler,
   AssignReturnValue[?invo] = ?ret.

ArrayContentsPointToInterface(?iface, ?hctx, ?arrayValue) <-
   ArrayIndexPointsTo(_, ?interfaceVal, ?hctx, ?arrayValue),
   ClassHeap:InstanceType[Value:Heap[?interfaceVal]] = ?iface,
   InterfaceType(?iface).

// Proxy.getProxyClass() is simpler than Proxy.newProxyInstance(): it
// does not allocate a proxy instance and takes no handler.
java:lang:reflect:Proxy:getProxyClass(?invo, ?ret, ?interfaces) <-
   StaticMethodInvocation:SimpleName[?invo] = "getProxyClass",
   MethodInvocation:Signature[?invo] = ?meth,
   Method:Id(?meth:"<java.lang.reflect.Proxy: java.lang.Class getProxyClass(java.lang.ClassLoader,java.lang.Class[])>"),
   ActualParam[1, ?invo] = ?interfaces,
   AssignReturnValue[?invo] = ?ret.

VarPointsTo(?hctxImmutable, ?proxyClassObj, ?ctx, ?ret) <-
   java:lang:reflect:Proxy:getProxyClass(_, ?ret, ?interfaces),
   VarPointsTo(?hctx, ?interfacesVal, ?ctx, ?interfaces),
   ArrayContentsPointToInterface(?iface, ?hctx, ?interfacesVal),
   ProxyClassOfInterface[?iface] = ?proxyClass,
   ReifiedClass:Value[?proxyClass] = ?proxyClassObj,
   ImmutableHContextFromContext[?ctx] = ?hctxImmutable.

// _OptVarPointsToForArray(?ctx, ?interfaces, ?hctx, ?interfacesValue) <-
//    VarPointsTo(?hctx, ?arrayObj, ?ctx, ?arrayVar),
//    Value:Heap[?arrayObj] = ?arrayHeap,
//    ArrayType(HeapAllocation:Type[?arrayHeap]).

Optjava:lang:reflect:Proxy:newProxyInstance(?ret, ?handler, ?interfaces, ?invo) <-
   java:lang:reflect:Proxy:newProxyInstance(?invo, ?ret, ?handler, ?interfaces).
   
// Create a new heap allocation per
// (newProxyInstance call, interface type) pair.
//// REVIEW: ideally these should be allocated context sensitively, i.e.,
//// call RecordMacro, and use the calling ?ctx as argument.
HeapAllocation:Normal:Cons[?heapId] = ?heap,
NormalHeap(?heap),
HeapAllocation:Type[?heap] = ?proxyClass,
ProxyClassInstance[?iface, ?invo] = ?heap
<-
   Optjava:lang:reflect:Proxy:newProxyInstance(_, _, _, ?invo),
   InterfaceType(?iface),
   ProxyClassOfInterface[?iface] = ?proxyClass,
   Type:Id(?iface:?ifaceName),
   Instruction:Id(?invo:?invoId),
   ?heapId = "<proxy object for interface " + ?ifaceName + " at " + ?invoId + ">".

MethodOfInterface(?meth, ?iface) <-
   InterfaceType(?iface),
   Method:DeclaringType[?meth] = ?iface.

HeapAllocation:Normal:Cons[?heapId] = ?arrHeap,
NormalHeap(?arrHeap),
HeapAllocation:Type[?arrHeap] = ?objArrayType,
ArgArrayOfProxyMethod[?meth, ?invo] = ?arrHeap
<-
   ProxyClassInstance[?iface, ?invo] = _,
   Instruction:Id(?invo:?invoId),
   Type:Id(?objArrayType:"java.lang.Object[]"),
   MethodOfInterface(?meth, ?iface),
   Method:Id(?meth:?methName),
   ?heapId = "<argument array for proxied method " + ?methName + " at " + ?invoId + ">".

// JLS 5.1.7 (Java 8).
// TODO Misses null-to-null boxing (is it useful for proxies?).
PrimitiveType:Boxed["boolean"] = "java.lang.Boolean".
PrimitiveType:Boxed["byte"   ] = "java.lang.Byte".
PrimitiveType:Boxed["short"  ] = "java.lang.Short".
PrimitiveType:Boxed["char"   ] = "java.lang.Character".
PrimitiveType:Boxed["int"    ] = "java.lang.Integer".
PrimitiveType:Boxed["long"   ] = "java.lang.Long".
PrimitiveType:Boxed["float"  ] = "java.lang.Float".
PrimitiveType:Boxed["double" ] = "java.lang.Double".

PrimitiveFormalOfInterface(?methName, ?formal, ?formalTypeId) <-
   MethodOfInterface(?meth, _),
   FormalParam[_, ?meth] = ?formal,
   Var:Type[?formal] = ?formalType,
   PrimitiveType(?formalType),
   Method:Id(?meth:?methName),
   Type:Id(?formalType:?formalTypeId).

// Primitive values passed as arguments to proxied methods, are boxed
// to be passed to the args array. Thus, for every primitive argument
// of a proxied method, we create a new heap allocation to show where
// boxing occurs in the method. REVIEW: contexts (as above)?
HeapAllocation:Normal:Cons[?heapId] = ?heap,
NormalHeap(?heap),
HeapAllocation:Type[?heap] = ?boxType,
BoxAllocationOfPrimitiveFormal[?formal] = ?heap
 <-
   PrimitiveFormalOfInterface(?methName, ?formal, ?formalTypeId),
   PrimitiveType:Boxed[?formalTypeId] = ?boxTypeId,
   Var:Id(?formal:?formalId),
   Type:Id(?boxType:?boxTypeId),
   ?heapId = "<boxed " + ?boxTypeId + " argument for proxied method " + ?methName + " and formal " + ?formalId + ">".

// Return var of newProxyInstance should point to the appropriate
// dynamic proxy object.
//// REVIEW: as above, have a real heap context instead of immutable?
VarPointsTo(?hctxImmutable, ?value, ?ctx, ?ret),
ProxyObjectAtInvocation[?iface, ?invo] = ?heap
<-
   java:lang:reflect:Proxy:newProxyInstance(?invo, ?ret, _, ?interfaces),
   VarPointsTo(?hctx, ?interfacesVal, ?ctx, ?interfaces), 
   ArrayContentsPointToInterface(?iface, ?hctx, ?interfacesVal),
   ProxyClassInstance[?iface, ?invo] = ?heap,
   Value:byHeap[?heap] = ?value,
   ImmutableHContextFromContext[?ctx] = ?hctxImmutable.

Opt2java:lang:reflect:Proxy:newProxyInstance(?ret, ?interfaces, ?invo, ?handler) <-
   java:lang:reflect:Proxy:newProxyInstance(?invo, ?ret, ?handler, ?interfaces).

ProxyObject:Invocation[?heap] = ?invo,
ProxyObject:Handler[?heap] = ?handlerObj,
ProxyObject:HandlerHctx[?heap] = ?hctxHandler,
ProxyObject:Interface[?heap] = ?iface
<-
   Opt2java:lang:reflect:Proxy:newProxyInstance(_, _, ?invo, ?handler),
   VarPointsTo(?hctxHandler, ?handlerObj, _, ?handler), 
   ProxyObjectAtInvocation[?iface, ?invo] = ?heap.


// And the clincher: if a method gets invoked on a proxy object, simulate
// a call to the proxy object handler's "invoke" method, with the right
// arguments passed in.
CallToMethodOfProxyObject(?heap, ?ctx, ?invo) <-
   VirtualMethodInvocation:Insn(?invo),
   VirtualMethodInvocation:Base[?invo] = ?base,
   VarPointsTo(_, ?value, ?ctx, ?base),
   Value:Heap[?value] = ?heap,
   ProxyObject:Invocation[?heap] = _.


//// REVIEW
// #ifdef REFLECTION_CONTEXT_SENSITIVITY
// ReflectiveMergeMacro(?callerCtx, ?invocation, ?hctx, ?value, ?calleeCtx), ...
ProxyCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?handlerInvokeMeth),
VarPointsTo(ProxyObject:HandlerHctx[?heap], ProxyObject:Handler[?heap], ?calleeCtx, ?this)
<-
   ImmutableContextFromContext[?callerCtx] = ?calleeCtx,
   CallToMethodOfProxyObject(?heap, ?callerCtx, ?invo),
   ProxyObject:Handler[?heap] = ?handlerObj,
   Value:Type[?handlerObj] = ?handlerType,
   Method:Id(?invoke:"<java.lang.reflect.InvocationHandler: java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])>"),
   Method:SimpleName[?invoke] = ?invokeMethName,
   Method:Descriptor[?invoke] = ?invokeMethDescriptor,
   MethodLookup[?invokeMethName, ?invokeMethDescriptor, ?handlerType] = ?handlerInvokeMeth,
   ThisVar[?handlerInvokeMeth] = ?this.

//// TODO From spec: if method has same name/signature as Object's
//// hashCode(), equals(), or toString(), then the reified Method
//// always comes from Object.
VarPointsTo(?hctx, ?proxyValue, ?calleeCtx, ?proxyArg),
VarPointsTo(?hctx, ?methValue, ?calleeCtx, ?methArg),
VarPointsTo(?hctx, ?argsArrValue, ?calleeCtx, ?argsArg)
<-
   ProxyCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?handlerInvokeMeth),
   CallToMethodOfProxyObject(?heap, ?callerCtx, ?invo),
   FormalParam[0, ?handlerInvokeMeth] = ?proxyArg,
   FormalParam[1, ?handlerInvokeMeth] = ?methArg,
   FormalParam[2, ?handlerInvokeMeth] = ?argsArg,
   ImmutableHContextFromContext[?calleeCtx] = ?hctx,
   Value:byHeap[?heap] = ?proxyValue,
   MethodInvocation:Signature[?invo] = ?methSig,
   ReifiedMethod:Value[?methSig] = ?methValue,
   ArgArrayOfProxyMethod[?methSig, ProxyObject:Invocation[?heap]] = ?argsArrHeap,
   Value:byHeap[?argsArrHeap] = ?argsArrValue.

ReachableContext(?calleeCtx, ?callee) <-
  ProxyCallGraphEdge(_, _, ?calleeCtx, ?callee).

ArgArrayForFormal(?arrValue, ?formal) <-
   ArgArrayOfProxyMethod[?meth, _] = ?arrHeap,
   Value:byHeap[?arrHeap] = ?arrValue,
   FormalParam[_, ?meth] = ?formal.

// Populate args array:
// (a) Reference-type arguments go in directly.
ArrayIndexPointsTo(?hctx2, ?formalVal, ?hctx, ?arrValue) <-
   ArgArrayForFormal(?arrValue, ?formal),
   VarPointsTo(?hctx, ?formalVal, ?ctx, ?formal),
   Var:Type[?formal] = ?formalType,
   ReferenceType(?formalType),
   ImmutableHContextFromContext[?ctx] = ?hctx2.
// (b) Primitive arguments are boxed first.
ArrayIndexPointsTo(?hctx2, ?formalVal, ?hctx, ?arrValue) <-
   ArgArrayForFormal(?arrValue, ?formal),
   VarPointsTo(?hctx, ?formalVal, ?ctx, ?formal),
   BoxAllocationOfPrimitiveFormal[?formal] = ?heap,
   Value:byHeap[?heap] = ?formalVal,
   ImmutableHContextFromContext[?ctx] = ?hctx2.
// REVIEW: contexts.

// Handle return values: connect the return value of handler.invoke()
// to the return value of the wrapped method.
//
// TODO Exceptions from spec: (a) the resulting value must be able to
// be succesfully cast to the correct type (or a ClassCastException is
// raised) and (b) if invoke() returns a null and the intended result
// is a primitive, then NullPointerException is raised.
VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret)
<-
   ProxyCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?handlerInvokeMeth),
   ReturnVar(?handlerReturnVar, ?handlerInvokeMeth),
   VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?handlerReturnVar),
   AssignReturnValue[?invo] = ?ret.
