/*************************************************************
 * MethodHandle constants
 *************************************************************/

HeapAllocation:ContextInsensitive(?heap) <-
   MethodHandleConstant(?heap).

#define LAMBDA_METAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"

#define LAMBDA_ALTMETAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>"

LambdaMetafactory[] = ?bootMethod <- Method:Id(?bootMethod:LAMBDA_METAFACTORY_ID).

// Method references are wrapped by calling invokedynamic with
// boostrap method being the lambda metafactory and the second
// bootstrap argument being a constant method handle. The result
// 'value' of the invokedynamic is a lambda, which contains an
// instance method calling static method 'realMethod'.

ConstantMethodHandleLambda(?value, ?dynName, ?dynRet, ?realMethod) ->
   Value(?value), string(?dynName), string(?dynRet), Method(?realMethod).

VarPointsTo(?hctx, ?value, ?ctx, ?var),
MockValueConsMacro(?valueId, ?interface, ?value),
ConstantMethodHandleLambda(?value, ?dynName, ?dynRet, ?realMethod) <-
   DynamicMethodInvocation:Insn(?invo),
   BootstrapParam[1, ?invo] = ?handleVar,
   DynamicMethodInvocation:Bootstrap[?invo] = LambdaMetafactory[],
   VarPointsTo(?hctx, ?handleVal, ?ctx, ?handleVar),
   Value:Heap[?handleVal] = ?handle,
   MethodHandleConstant:Method[?handle] = ?realMethod,
   DynamicMethodInvocation:DynName[?invo] = ?dynName,
   DynamicMethodInvocation:DynReturnType[?invo] = ?dynRet,
   InterfaceType(?interface), Type:Id(?interface:?dynRet),
   AssignReturnValue[?invo] = ?var,
   Instruction:Id(?invo:?invoId),
   ?valueId = "<lambda " + ?dynRet + "::" + ?dynName + " at " + ?invoId + ">".

// Record invokedynamic invocations whose bootstrap methods are not
// handled at all.
UnhandledInvokedynamic(?i, ?bootMethodId) ->
   DynamicMethodInvocation:Insn(?i), string(?bootMethodId).

UnhandledInvokedynamic(?i, ?bootMethodId) <-
   DynamicMethodInvocation:Insn(?i),
   DynamicMethodInvocation:Bootstrap[?i] = ?bootMethod,
   Method:Id(?bootMethod:?bootMethodId),
   // ?bootMethodId != LAMBDA_ALTMETAFACTORY_ID,
   ?bootMethodId != LAMBDA_METAFACTORY_ID.

// When invokeinterface is called on a lambda object constructed by a
// constant method handle, the real method is called. This can wrap a
// static method call as an instance method call.

InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?m) ->
   Context(?callerCtx), VirtualMethodInvocation:Insn(?i),
   Context(?calleeCtx), Method(?m).

// We create two call graph edges: one for the method called and one
// for the bootstrap method.
InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?realMethod),
InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, LambdaMetafactory[]) <-
   ConstantMethodHandleLambda(?value, ?dynName, _, ?realMethod),
   VirtualMethodInvocation:Base[?i] = ?var,
   VarPointsTo(_, ?value, ?callerCtx, ?var),
   ImmutableContextFromContext[?callerCtx] = ?calleeCtx,
   VirtualMethodInvocation:SimpleName[?i] = ?dynName.

ReachableContext(?calleeCtx, ?callee) <-
   InvokedynamicCallGraphEdge(_, _, ?calleeCtx, ?callee).
