#include "main-declarations.dl"

.comp AbstractContextSensitivity<Configuration> {
  #ifdef ANDROID
  #include "android-declarations.dl"
  #endif
  #include "class-initialization-declarations.dl"
  #include "exceptions-declarations.dl"
  #include "implicit-reachable-declarations.dl"
  #include "threads-declarations.dl"
  #ifdef ANDROID
    #include "android.dl"
  #endif

  #include "string-concat.dl"
  #include "exceptions.dl"
  #ifndef DISABLE_METHOD_HANDLES
    #include "method-handles.dl"
  #endif

  #if defined(REFLECTION)
    #include "reflection/declarations.dl"
  #endif

  .decl FakeInvocation_RegisterFinalize0(?heap:HeapAllocation, ?invo:MethodInvocation)

  .decl FakeInvocation_RegisterFinalize(?value:Value, ?invo:MethodInvocation)

  //-----------------------------------------------------------------------------
  // [Value]
  //-----------------------------------------------------------------------------

  .type Value = HeapAllocation | NumConstant

  .decl isValue(?value:Value)

  .decl Value_isHeap(?value:Value)
  .decl Value_isMock(?value:Value)

  // Value_Num maps each numeric constant to a value while
  // also prepending it with *num-constant-* to distinguish it
  // from heap allocations that share the same string value.
  .decl Value_Num(?value:Value, ?const:NumConstant)

  .decl Value_isNonHeap(?value:Value)

  // Special value objects are just artificial ones that we use to find where the
  // result of a reflective call can flow to. We don't want to track them
  // through the heap.
  .decl NotSpecialObject(?value:Value)

  .decl Value_Type(?value:Value, ?type:Type)
  .decl Value_DeclaringType(?value:Value, ?type:Type)

  // [Miscellaneous]
  .decl Value_Null(?null:Value)

  #include "context-sensitivity-declarations.dl"
  #include "../commonMacros.dl"
  #include "prologue.dl"
  #include "context-sensitivity.dl"
  #include "export.dl"

  #define InvocationHandlerInvoke(invokeMeth)   Method_SimpleName(invokeMeth, "invoke"), \
    Method_DeclaringType(invokeMeth, ?class), \
    basic.SubtypeOf(?class, ?tInvocationHandler), \
    isInterfaceType(?tInvocationHandler), \
    ?tInvocationHandler = "java.lang.reflect.InvocationHandler"

  #define NEW_PROXY_INSTANCE "<java.lang.reflect.Proxy: java.lang.Object newProxyInstance(java.lang.ClassLoader,java.lang.Class[],java.lang.reflect.InvocationHandler)>"
  #define DYNAMIC_PROXY_EXPORT

  #if defined(REFLECTION_DYNAMIC_PROXIES)
    #include "reflection/dynamic-proxies.dl"
    #include "reflection/dynamic-proxies-delta.dl"
  #endif // REFLECTION_DYNAMIC_PROXIES

  #ifdef DYNAMIC_PROXY_EXPORT
    .decl ReachableProxyInvoke(?invokeMeth:Method)
    .output ReachableProxyInvoke

    ReachableProxyInvoke(?invokeMeth) :-
      Reachable(?invokeMeth),
      InvocationHandlerInvoke(?invokeMeth).

    .decl ReachableNewProxyInstance(?inMeth:Method)
    .output ReachableNewProxyInstance

    ReachableNewProxyInstance(?inMeth) :-
      ?newProxyInstance = NEW_PROXY_INSTANCE,
      Reachable(?newProxyInstance),
      CallGraphEdge(_, ?invo, _, ?newProxyInstance),
      Instruction_Method(?invo, ?inMeth).

  #endif // DYNAMIC_PROXY_EXPORT

  #if defined(REFLECTION)
    #include "reflection/rules.dl"
  #endif

  #ifdef TAMIFLEX
     #include "../addons/tamiflex/declarations.dl"
     #include "../addons/tamiflex/rules.dl"
  #endif
  #if defined(DACAPO) || defined(DACAPO_BACH)
     #include "../addons/dacapo/rules.dl"
  #endif

  .init configuration = Configuration
}
