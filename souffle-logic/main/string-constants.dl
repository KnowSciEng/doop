/*************************************************************
 * Special objects
 *
 * Some objects are so common that they heavily impact performance if
 * every allocation is distinguished or a context-sensitive heap
 * abstraction is used. In many cases, this precision is not actually
 * useful for a points-to analysis, so handling them in a less precise
 * way is beneficial. This handling started from string constants and
 * is now expanded to cover (in many diverse ways) merging of all
 * library objects, exception objects, string buffers and builders,
 * and more.
 *************************************************************/
#include "throwable.dl"

/**
 * Objects that should use a context-insensitive heap abstraction.
 */
.decl HeapAllocation_ContextInsensitive(?heap:HeapAllocation)

// Merged objects are currently always context-insensitive 
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Merge(?heap, _).

/**
 * Objects that should be merged to some heap abstraction
 * (will overlap with merely context-insensitive objects)
 */
.decl HeapAllocation_Merge(?heap:HeapAllocation, ?mergeHeap:HeapAllocation)

// The ones that absolutely have to be kept distinct
.decl HeapAllocation_Keep(?heap:HeapAllocation)

/**
 * This is the handling for objects that are explicitly allocated in
 * the program text. There will also be other objects: pseudo objects
 * (null, string-constant), reified reflection objects, string
 * constants that the analysis thought are safe to merge, yet they do
 * arise reflectively, etc.
 */
AssignNormalHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  !HeapAllocation_ContextInsensitive(?heap).

AssignContextInsensitiveHeapAllocation(?mergeHeap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_Merge(?heap, ?mergeHeap).

AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_ContextInsensitive(?heap),
  !(HeapAllocation_Merge(?heap, _)). // should be mostly unnecessary, but has bitten us many times


/*************************************************************
 * Special handling for all sorts of objects. All potential
 * representatives of an object are examined, and one is picked
 * for merging. The idea is to make the rest of the logic flexible:
 * signal as many reasons as apply for merging an object with
 * others and then have a single point in the code that decides
 * which merging is best.
 *************************************************************/

.decl HeapRepresentative(?heap:HeapAllocation, ?heapRepr:symbol)
.decl HeapIsMergedString(?heap:HeapAllocation)

// If the object is a string that should be merged, ignore other
// representatives and merge with that.
HeapIsMergedString(?heap) :-
  HeapRepresentative("<<string-constant>>", ?heap).
// Rule split in two since it needs to be stratified differently
#ifndef NO_MERGES
HeapAllocation_Merge(?heap, ?heapRepr) :-
  ?heapRepr = "<<string-constant>>",
  HeapRepresentative(?heapRepr, ?heap).

.decl HeapIsMergedStringFactory(?heap:HeapAllocation)

HeapIsMergedStringFactory(?heap) :-
  HeapRepresentative("<<string-buffer>>", ?heap);
  HeapRepresentative("<<string-builder>>", ?heap).

HeapAllocation_Merge(?heap, ?heapRepr) :-
  (?heapRepr = "<<string-buffer>>",
   HeapRepresentative(?heapRepr, ?heap));
  (?heapRepr = "<<string-builder>>",
   HeapRepresentative(?heapRepr, ?heap)).

.decl RepresentativesToPickFrom(?heapRepr:HeapAllocation, ?heap:HeapAllocation)

RepresentativesToPickFrom(?heapRepr, ?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  !HeapIsMergedString(?heap),
  !HeapIsMergedStringFactory(?heap),
  !HeapAllocation_Keep(?heap).

.decl MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd:number, ?heap:HeapAllocation)

MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap) :-
  RepresentativesToPickFrom(_, ?heap),
  ?minHeapReprOrd = min ord(?heapRepr): RepresentativesToPickFrom(?heapRepr, ?heap).

HeapAllocation_Merge(?heap, ?mergeHeap) :-
  isHeapAllocation(?mergeHeap),
  ord(?mergeHeap) = ?minHeapReprOrd,
  MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap).
#endif

/*************************************************************
 * String constants
 *************************************************************/
 
#ifndef DISTINGUISH_ALL_STRING_CONSTANTS
#ifndef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS
#ifndef NO_MERGES
HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  ?constant = "<<string-constant>>",
  isHeapAllocation(?constant),
  !HeapAllocation_Keep(?heap).
#endif
#endif
#endif // distinguish-no-string-constants mode

.decl ReflectionStringConstant(?heap:HeapAllocation)
.decl ReflectionSubstringObject(?heap:HeapAllocation)

#ifdef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS

.output ReflectionStringConstant

// This includes substrings, i.e., both exact and inexact matches!
ReflectionStringConstant(?heap) :-
  PreClassNameMatchingStringConstant(?heap);
  PreMethodNameMatchingStringConstant(?heap);
  PreFieldNameMatchingStringConstant(?heap).

// This is only for incomplete (i.e., substring) matches
ReflectionSubstringObject(?heap) :-
  PreClassNameMatchingStringConstantInexact_Type(_,?heap);
  PreMethodNameMatchingStringConstantInexact_Signature(_,?heap);
  PreFieldNameMatchingStringConstantInexact_Signature(_,?heap).

#ifndef NO_MERGES
HeapRepresentative("<<string-constant>>", ?heap) :-
  isStringConstant(?heap),
  !ReflectionStringConstant(?heap),
  !HeapAllocation_Keep(?heap).
#endif

#ifdef GROUP_REFLECTION_STRINGS

// ///// Naive Merging strategy: all strings that map to same reflection object
// ///// are merged. Not too effective.
// _StringRepresentativeForType[?type] = ?mergeHeap <-
//   agg<<?mergeHeap = min(?heap)>>(PreClassNameMatchingStringConstant:Type(?type, ?heap)).
// _StringRepresentativeForMethod[?sig] = ?mergeHeap <-
//   agg<<?mergeHeap = min(?heap)>>(PreMethodNameMatchingStringConstant:Signature(?sig, ?heap)).
// _StringRepresentativeForField[?sig] = ?mergeHeap <-
//   agg<<?mergeHeap = min(?heap)>>(PreFieldNameMatchingStringConstant:Signature(?sig, ?heap)).

// _OptPreClassNameMatchingStringConstant:Type(?heap, ?type) <-
//   PreClassNameMatchingStringConstant:Type(?type, ?heap).
// _OptPreMethodNameMatchingStringConstant:Signature(?heap, ?sig) <-
//   PreMethodNameMatchingStringConstant:Signature(?sig, ?heap).
// _OptPreFieldNameMatchingStringConstant:Signature(?heap, ?sig) <-
//   PreFieldNameMatchingStringConstant:Signature(?sig, ?heap).

// HeapRepresentative(?mergeHeap, ?heap) <-
//   _OptPreClassNameMatchingStringConstant:Type(?heap, ?type),
//   _StringRepresentativeForType[?type] = ?mergeHeap.

// HeapRepresentative(?mergeHeap, ?heap) <-
//   _OptPreMethodNameMatchingStringConstant:Signature(?heap, ?sig),
//   _StringRepresentativeForMethod[?sig] = ?mergeHeap.

// HeapRepresentative(?mergeHeap, ?heap) <-
//   _OptPreFieldNameMatchingStringConstant:Signature(?heap, ?sig),
//   _StringRepresentativeForField[?sig] = ?mergeHeap.
// ///// End naive merging strategy

///// Merging strategy that employs coloring of heap allocations based on
///// the classes they conflict on.

// REVIEW: There are two cases that are currently ignored, as too rare to matter:
//  -conflicts between a field and a method are not important. The constraint is
//   that string matching methods should not conflict with strings matching other
//   methods (and similar for fields), not with any member.
//  -we lose precision because we may merge strings that match different class
//   names.
.decl MethodOfClassMatchesString(?heap:HeapAllocation, ?type:Type)
.decl FieldOfClassMatchesString(?heap:HeapAllocation, ?type:Type)

MethodOfClassMatchesString(?heap, ?type) :-
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap),
  Method_DeclaringType(?sig, ?type).

FieldOfClassMatchesString(?heap, ?type) :-
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap),
  Field_DeclaringType(?sig, ?type).

// Important to not forget NullType: it derives from everything!
MethodOfClassMatchesString(?heap, ?type) :-
  MethodOfClassMatchesString(?heap, ?superType),
  basic.SubtypeOf(?type, ?superType),
  !isNullType(?type).

// Important to not forget NullType: it derives from everything!
FieldOfClassMatchesString(?heap, ?type) :-
  FieldOfClassMatchesString(?heap, ?superType),
  basic.SubtypeOf(?type, ?superType),
  !isNullType(?type).

// Also, we could restrict this to leaf classes, since they will
// exhibit maximal conflicts anyway. But this doesn't seem to pay off,
// at least in smaller benchmarks.

// Arbitrary ordering relation to determine coloring
.decl StringGreaterThanOtherInSameClass(?heap1:HeapAllocation, ?heap2:HeapAllocation, ?type:Type)

StringGreaterThanOtherInSameClass(?heap1, ?heap2, ?type) :-
  FieldOfClassMatchesString(?heap1, ?type),
  FieldOfClassMatchesString(?heap2, ?type),
  ord(?heap1) > ord(?heap2).

StringGreaterThanOtherInSameClass(?heap1, ?heap2, ?type) :-
  MethodOfClassMatchesString(?heap1, ?type),
  MethodOfClassMatchesString(?heap2, ?type),
  ord(?heap1) > ord(?heap2).

.decl MinStringOrdinalGreaterThanOtherInSameClass(?heap:HeapAllocation, ?heapGreaterOrd:number, ?type:Type)
.decl StringImmediatelyLessThanOtherInClass(?heap:HeapAllocation, ?type:Type, ?heapGreater:HeapAllocation)
.decl StringImmediatelyGreaterThanOtherInSomeClass(?heapGreater:HeapAllocation, ?heap:HeapAllocation)

MinStringOrdinalGreaterThanOtherInSameClass(?heap, ?heapGreaterOrd, ?type) :-
  StringGreaterThanOtherInSameClass(_, ?heap, ?type),
  ?heapGreaterOrd = min ord(?h): StringGreaterThanOtherInSameClass(?h, ?heap, ?type).

StringImmediatelyLessThanOtherInClass(?heap, ?type, ?heapGreater) :-
  MinStringOrdinalGreaterThanOtherInSameClass(?heap, ?heapGreaterOrd, ?type),
  isHeapAllocation(?heapGreater),
  ord(?heapGreater) = ?heapGreaterOrd.

StringImmediatelyGreaterThanOtherInSomeClass(?heapGreater, ?heap) :-
  StringImmediatelyLessThanOtherInClass(?heap, _, ?heapGreater).

.decl StringColorGreaterThan(?num:number, ?heap:HeapAllocation)

StringColorGreaterThan(0, ?heap) :-
  FieldOfClassMatchesString(?heap, _);
  MethodOfClassMatchesString(?heap, _).

StringColorGreaterThan(?num + 1, ?heap) :-
  StringImmediatelyGreaterThanOtherInSomeClass(?heap, ?heapLower),
  StringColorGreaterThan(?num, ?heapLower).

.decl StringColorForHeap(?heap:HeapAllocation, ?color:number)

StringColorForHeap(?heap, ?color) :-
  StringColorGreaterThan(_, ?heap),
  ?color = max (?n): StringColorGreaterThan(?n, ?heap).

.decl MinStringOrdinalForColor(?color:number, ?minHeapOrd:number)
.decl StringRepresentativeForColor(?color:number, ?heap:HeapAllocation)

MinStringOrdinalForColor(?color, ?minHeapOrd) :-
  StringColorForHeap(_, ?color),
  ?minHeapOrd = min ord(?heap): StringColorForHeap(?heap, ?color).

StringRepresentativeForColor(?color, ?mergeHeap) :-
  MinStringOrdinalForColor(?color, ?minHeapOrd),
  isHeapAllocation(?mergeHeap),
  ord(?mergeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?mergeHeap, ?heap) :-
  StringColorForHeap(?heap, ?color),
  StringRepresentativeForColor(?color, ?mergeHeap).
#endif
///// End coloring strategy

// Make the representative play (at a minimum) the same role as the
// original string re: reflection. This may introduce some imprecision
// (depending on the merging strategy), but it's expected to be small,
// compared to the cost of tracking full strings all over the code.
ClassNameMatchingStringConstant_Type(?type, ?heapRepr) :-
  HeapAllocation_Merge(?heap, ?heapRepr),
  PreClassNameMatchingStringConstant_Type(?type, ?heap).

MethodNameMatchingStringConstant_Signature(?sig, ?heapRepr) :-
  HeapAllocation_Merge(?heap, ?heapRepr),
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap).

FieldNameMatchingStringConstant_Signature(?sig, ?heapRepr) :-
  HeapAllocation_Merge(?heap, ?heapRepr),
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap).
#endif // GROUP_REFLECTION_STRINGS
#endif // DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS

HeapAllocation_ContextInsensitive(?heap) :-
  isStringConstant(?heap),
  !HeapRepresentative(_, ?heap).

.decl NonTrivialStringConstant(?heap:HeapAllocation)

NonTrivialStringConstant(?heap) :-
  isStringConstant(?heap),
  strlen(?heap) >= 7.

/**
 * String constants that (may) refer to class, method, and field names
 */
.decl ClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl MethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl FieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)

.decl PreClassNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantExact_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantInexact_Type(?type:Type, ?heap:HeapAllocation)

// These are the predicates that the outside world will use. The Pre-
// versions are so that they can be stratified earlier and strings can
// possibly be merged based on them.
ClassNameMatchingStringConstant_Type(?type, ?heap) :-
  PreClassNameMatchingStringConstant_Type(?type, ?heap).
MethodNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap).
FieldNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap).

// We distinguish between an exact match and a
// substring match.

PreClassNameMatchingStringConstant(?string),
PreClassNameMatchingStringConstant_Type(?type, ?string),
PreClassNameMatchingStringConstantExact_Type(?type, ?string) :-
  isStringConstant(?string),
  isReferenceType(?type),
#ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  ApplicationClass(?type),
     // library classes are known and in known packages. Makes no sense
     // to access them via .getClass
#endif
  // #ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  // #ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
  //   NonTrivialStringConstant(?string),
  // #endif
  // #endif
  ord(?type) = ord(?string).

.decl PreMethodNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantExact_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantInexact_Signature(?sig:Method, ?heap:HeapAllocation)

PreMethodNameMatchingStringConstant(?string),
PreMethodNameMatchingStringConstant_Signature(?sig, ?string),
PreMethodNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),
  //  Method_DeclaringType(?sig, ?type),
  //  ApplicationClass(?type),
     // there is some possibility of accessing methods and fields
     // reflectively, even in system classes. Maybe one needs to
     // circumvent access control, or maybe one wants to treat all
     // fields uniformly and some are inherited from a system superclass.
  Method_SimpleName(?sig, ?string),
  ?string != "<init>",
  ?string != "<clinit>". // common, yet not methods callable via reflection

.decl PreFieldNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantExact_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantInexact_Signature(?sig:Field, ?heap:HeapAllocation)

PreFieldNameMatchingStringConstant(?string),
PreFieldNameMatchingStringConstant_Signature(?sig, ?string),
PreFieldNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),
  // Field_DeclaringType(?sig, ?declaringClass),
  // ApplicationClass(?declaringClass);
  // #ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  // #ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
  //   NonTrivialStringConstant(?string),
  // #endif
  // #endif
  Field_SimpleName(?sig, ?string).

/*************************************************************
 * Class constants
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  isClassHeap(?heap).

/*************************************************************
 * Merging allocation sites per method, per class, or per package
 *************************************************************/

// Per-method merging: auto-merge allocation sites for method that
// allocates many objects of same type. Also, enable other rules to
// explicitly ask for per-method merging, beyond the above heuristic
// (by setting "...ShouldBeMerged...").

.decl MethodAllocationMergeThreshold(?t:number)

MethodAllocationMergeThreshold(50).

.decl ExceptionType(?type:Type)

ExceptionType(?type) :-
  ?throw = "java.lang.Throwable",
  isType(?throw),
  basic.SubtypeOf(?type, ?throw).

.decl OptAssignHeapAllocation(?inmethod:Method, ?heap:HeapAllocation)

OptAssignHeapAllocation(?inmethod, ?heap) :-
  AssignHeapAllocation(?heap, _, ?inmethod).

// There are objects, like strings, null, and class objects, that
// don't have a unique allocation site.
.decl ObjectMultipleAllocated(?heap:HeapAllocation)

ObjectMultipleAllocated(?heap) :-
  OptAssignHeapAllocation(?inmethod1, ?heap),
  OptAssignHeapAllocation(?inmethod2, ?heap),
  ?inmethod1 != ?inmethod2.

.decl MethodAndTypeToHeap(?heap:HeapAllocation, ?heapType:Type, ?method:Method)

MethodAndTypeToHeap(?heap, ?heaptype, ?meth) :-
  AssignHeapAllocation(?heap, _, ?meth),
  HeapAllocation_Type(?heap, ?heaptype),
  !isStringConstant(?heap),
  !StringFactoryHeap(?heap),
  !HeapAllocation_EmptyArray(?heap),
  !ObjectMultipleAllocated(?heap),
  !HeapAllocation_Keep(?heap).

.decl AllocationsPerMethodAndType(?type:Type, ?meth:Method, ?n:number)

AllocationsPerMethodAndType(?type, ?meth, ?n) :-
  MethodAndTypeToHeap(_, ?type, ?meth),
  ?n = count : MethodAndTypeToHeap(_, ?type, ?meth).

.decl AllocationShouldBeMergedPerMethod(?heaptype:Type, ?meth:Method)

AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  MethodAllocationMergeThreshold(?t),
  ?n > ?t.

.decl MethodAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?meth:Method)

MethodAndTypeToMergedHeap(?heap, ?heaptype, ?meth) :-
  AllocationShouldBeMergedPerMethod(?heaptype, ?meth),
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth).

.decl MinHeapOrdinalPerMethodAndType(?ord:number, ?type:Type, ?meth:Method)
.decl MethodAndTypeToRepresentative(?type:Type, ?meth:Method, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth) :-
  MethodAndTypeToMergedHeap(_, ?type, ?meth),
  ?minHeapOrd = min ord(?heap): MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap),
  MethodAndTypeToMergedHeap(?heap, ?type, ?meth).
#endif
// Now, per-class merging. This is more rare and should be requested
// explicitly for a given type. Again, does not apply to types with
// special merging policies.
.decl ClassAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:ClassType)
.decl AllocationsPerClassAndType(?type:Type, ?class:ClassType, ?n:number)

ClassAndTypeToHeap(?heap, ?heaptype, ?class) :-
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth),
  Method_DeclaringType(?meth, ?class).

AllocationsPerClassAndType(?type, ?class, ?n) :-
  ClassAndTypeToHeap(_, ?type, ?class),
  ?n = count : ClassAndTypeToHeap(_, ?type, ?class).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedPerClass(?heaptype:Type, ?class:Type)

.decl ClassAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:Type)

ClassAndTypeToMergedHeap(?heap, ?heaptype, ?class) :-
  AllocationShouldBeMergedPerClass(?heaptype, ?class),
  ClassAndTypeToHeap(?heap, ?heaptype, ?class).

.decl MinHeapOrdinalPerClassAndType(?minHeapOrd:number, ?type:Type, ?class:Type)
.decl ClassAndTypeToRepresentative(?type:Type, ?class:Type, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class) :-
  ClassAndTypeToMergedHeap(_, ?type, ?class),
  ?minHeapOrd = min ord(?heap): ClassAndTypeToMergedHeap(?heap, ?type, ?class).

ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap),
  ClassAndTypeToMergedHeap(?heap, ?type, ?class).
#endif
// Same for per-package merging.
#include "package-heuristic.dl"

.decl PackageAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)
.decl AllocationsPerPackageAndType(?type:Type, ?packageName:symbol, ?n:number)

PackageAndTypeToHeap(?heap, ?heaptype, ?packageName) :-
  ClassAndTypeToHeap(?heap, ?heaptype, ?class),
  Class_PackageHack(?class, ?packageName).

AllocationsPerPackageAndType(?type, ?packageName, ?n) :-
  PackageAndTypeToHeap(_, ?type, ?packageName),
  ?n = count : PackageAndTypeToHeap(_, ?type, ?packageName).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedPerPackage(?heaptype:Type, ?packageName:symbol)

.decl PackageAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)

PackageAndTypeToMergedHeap(?heap, ?heaptype, ?packageName) :-
  AllocationShouldBeMergedPerPackage(?heaptype, ?packageName),
  PackageAndTypeToHeap(?heap, ?heaptype, ?packageName).

.decl MinHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, ?packageName:symbol)
.decl PackageAndTypeToRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName) :-
  PackageAndTypeToMergedHeap(_, ?type, ?packageName),
  ?minHeapOrd = min ord(?heap): PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).

PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap),
  PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).
#endif
// And the ultimate: universal per-type merging
.decl TypeToHeap(?heap:HeapAllocation, ?heaptype:Type)
.decl AllocationsPerType(?type:Type, ?n:number)

TypeToHeap(?heap, ?heaptype) :-
  ClassAndTypeToHeap(?heap, ?heaptype, _).

AllocationsPerType(?type, ?n) :-
  TypeToHeap(_, ?type),
  ?n = count : TypeToHeap(_, ?type).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedGlobally(?heaptype:Type)

.decl TypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type)

TypeToMergedHeap(?heap, ?heaptype) :-
  AllocationShouldBeMergedGlobally(?heaptype),
  TypeToHeap(?heap, ?heaptype).

.decl MinHeapOrdinalPerType(?minHeapOrd:number, ?type:Type)
.decl TypeToRepresentative(?type:Type, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerType(?minHeapOrd, ?type) :-
  TypeToMergedHeap(_, ?type),
  ?minHeapOrd = min ord(?heap): TypeToMergedHeap(?heap, ?type).

TypeToRepresentative(?type, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerType(?minHeapOrd, ?type),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  TypeToRepresentative(?type, ?representativeHeap),
  TypeToMergedHeap(?heap, ?type).
#endif
/*************************************************************
 * Coarse-grained allocation policy
 *************************************************************/

#ifdef COARSE_GRAINED_ALLOCATION
// // Ultra coarse-grained allocation policy
// AllocationShouldBeMergedGlobally(?type) :-
//   AllocationsPerType(?type, ?n),
//  ?n > 1.

// // Very coarse-grained allocation policy
// AllocationShouldBeMergedPerPackage(?type, ?packageName) :-
//   AllocationsPerPackageAndType(?type, ?packageName, ?n),
//   ?n > 1.

// Coarse-grained allocation policy
AllocationShouldBeMergedPerClass(?type, ?class) :-
  AllocationsPerClassAndType(?type, ?class, ?n),
  ?n > 1.
#endif // COARSE_GRAINED_ALLOCATION


/*************************************************************
 * Library class that should be treated specially
 *************************************************************/

#ifndef CONTEXT_SENSITIVE_LIBRARY_ANALYSIS
#include "special-library.dl"
HeapAllocation_ContextInsensitive(?heap) :-
  SpecialLibraryObject(?heap),
  !HeapRepresentative(_, ?heap).

#ifdef MERGE_LIBRARY_OBJECTS_PER_METHOD
AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  ?n > 1,
  Method_DeclaringType(?meth, ?class),
  SpecialLibraryClass(?class).
#endif
#endif

/*************************************************************
 * String buffers and builders
 *************************************************************/

.decl StringFactoryType(?type:Type)
.decl StringFactoryHeap(?heap:HeapAllocation)

StringFactoryType(?type) :-
  ?type = "java.lang.StringBuffer" ;
  ?type = "java.lang.StringBuilder".

StringFactoryHeap(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  StringFactoryType(?heaptype).

#ifndef DISTINGUISH_ALL_STRING_BUFFERS
#ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
#ifdef DISTINGUISH_STRING_BUFFERS_PER_PACKAGE

.decl PackageAndTypeToStringFactoryHeap(?heap:HeapAllocation, ?type:Type, ?packageName:symbol)

PackageAndTypeToStringFactoryHeap(?heap, ?heaptype, ?packageName) :-
  StringFactoryType(?heaptype),
  HeapAllocation_Type(?heap, ?heaptype),
  AssignHeapAllocation(?heap, _, ?meth),
  Method_DeclaringType(?meth, ?class),
  Class_PackageHack(?class, ?packageName).

.decl MinStringFactoryHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, packageName:symbol)
.decl PackageAndTypeToStringFactoryRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)

MinStringFactoryHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName) :-
  PackageAndTypeToStringFactoryHeap(_, ?type, ?packageName),
  ?minHeapOrd = min ord(?heap): PackageAndTypeToStringFactoryHeap(?heap, ?type, ?packageName).

PackageAndTypeToStringFactoryRepresentative(?type, ?packageName, ?representativeHeap) :-
  MinStringFactoryHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName),
  StringFactoryHeap(?representativeHeap),
  ord(?representativeHeap) = ?minHeapOrd.

// current policy: all string builders merged per-package
#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  PackageAndTypeToStringFactoryHeap(?heap, ?type, ?packageName),
  PackageAndTypeToStringFactoryRepresentative(?type, ?packageName, ?representativeHeap).
#endif
//// Used to be all are merged per-class:
// // all string buffers (and builders) in the same class are merged
// AllocationShouldBeMergedPerClass(?heaptype, ?class) <-
//   AllocationsPerClassAndType[?heaptype, ?class] > 1,
//   StringFactoryType(?heaptype).

//// Used to be per-method:
// AllocationShouldBeMergedPerMethod(?heaptype, ?meth) <-
//   AllocationsPerMethodAndType[?heaptype, ?meth] > 1,
//   StringFactoryType(?heaptype).
#else // not DISTINGUISH_STRING_BUFFERS_PER_PACKAGE, i.e., merge them all
#ifndef NO_MERGES
HeapRepresentative("<<string-buffer>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuffer"),
  !HeapAllocation_Keep(?heap).

HeapRepresentative("<<string-builder>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuilder"),
  !HeapAllocation_Keep(?heap).
#endif
#endif
#endif
#endif

/*************************************************************
 * Primitive arrays
 *
 * char[] or int[] don't have object elements, so it's useless to
 * allocate them context-sensitively.
 *
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isArrayType(?type),
  ComponentType(?type, ?componentType),
  isPrimitiveType(?componentType).

/*************************************************************
 * Class without reference fields
 *
 * Treat context-insensitively always? It doesn't matter much,
 * but doesn't hurt much either.
 *************************************************************/

/*
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  Type_HasNoReferenceField(?heaptype),
  !HeapRepresentative(_, ?heap).
  // The rules have become complex enough that they overlap.

.decl Type_HasNoReferenceField(?type:Type)
.decl Type_DeclaresReferenceField(?type:Type)

Type_HasNoReferenceField("java.lang.Object").

Type_HasNoReferenceField(?class) :-
  isClassType(?class),
  DirectSuperclass(?class, ?super),
  Type_HasNoReferenceField(?super),
  !Type_DeclaresReferenceField(?class).

Type_DeclaresReferenceField(?class) :-
  isClassType(?class),
  Field_DeclaringType(?signature, ?class),
  Field_Type(?signature, ?type),
  ReferenceType(?type),
  !FieldIsStatic(?signature).

FieldIsStatic(?sig) :-
  Field_Modifier("static", ?sig).

//// Quite risky: even final fields hold interesting state.
//FieldIsStaticOrFinal?sig) <-
//  Modifier:Id(?final:"final"),
//  Field:Modifier(?final, ?sig).
*/


/*************************************************************
 * Primitive types
 *
 * Needed for precise handling of Class.getPrimitiveClass().
 *************************************************************/

ReflectionStringConstant("int").
ReflectionStringConstant("float").
ReflectionStringConstant("double").
ReflectionStringConstant("byte").
ReflectionStringConstant("boolean").
ReflectionStringConstant("char").
ReflectionStringConstant("long").
ReflectionStringConstant("short").
ReflectionStringConstant("void").
