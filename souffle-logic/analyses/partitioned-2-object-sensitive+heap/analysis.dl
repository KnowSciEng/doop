#include "../../main/single-phase-analysis.dl"
#include "../../main/configuration.dl"
#include "partitioning.dl"

.comp PartitionedTwoObjectSensitivePlusHeapConfiguration : AbstractConfiguration {
  .type Context  = [ partition: Partition, value1: mainAnalysis.Value, value2: mainAnalysis.Value ]
  .type HContext = [ partition: Partition, value: mainAnalysis.Value ]

  .decl PartitionForValue(value: mainAnalysis.Value, partition: Partition)
  .decl ValueInAllPartitions(value: mainAnalysis.Value)
  .decl NotValueInAllPartitions(value: mainAnalysis.Value)
  .decl TypeInAllPartitions(type: Type)
  .decl NotTypeInAllPartitions(type: Type)
  .decl PartitionForInvocation(invo: Instruction, partition: Partition)
  .decl PartitionForMethod(method: Method, partition: Partition)
  .decl MethodInAllPartitions(method: Method)
  .decl PartitionForResolvedInvocation(type: Type, invo: Instruction, partition: Partition)
  .decl MatchingMethodForInvocationAndType(type: Type, invocation: Instruction, method: Method)
  .decl ValidCtxVar(ctx: Context, var: Var)
  .decl CollapsedVarPointsTo(hctx: HContext, heap: mainAnalysis.Value, ctx: Context, var: Var)
  
  // horrible indexing, but there will only be a handful of such contexts
  ImmutableContextFromHContext(hctx, ctx) :-
    isHContext(hctx),
    isImmutableContext(ctx),
    hctx = [partitionId, hctxVal],
    ctx = [partitionId, ctxVal1, ctxVal2],
    ctxVal1 = ctxVal1,
    ctxVal2 = ctxVal2,
    hctxVal = hctxVal.
  .output ImmutableContextFromHContext

  ImmutableContextFromContext(ctx1, ctx2) :-
    isContext(ctx1),
    isImmutableContext(ctx2),
    ctx1 = [partitionId, ctx1Val1, ctx1Val2],
    ctx2 = [partitionId, ctx2Val1, ctx2Val2],
    ctx1Val1 = ctx1Val1,
    ctx1Val2 = ctx1Val2,
    ctx2Val1 = ctx2Val1,
    ctx2Val2 = ctx2Val2.
  .output ImmutableContextFromContext

  ImmutableHContextFromContext(ctx, hctx) :-
    isContext(ctx),
    isImmutableHContext(hctx),
    ctx = [partitionId, ctxVal1, ctxVal2],
    hctx = [partitionId, hctxVal],
    ctxVal1 = ctxVal1,
    ctxVal2 = ctxVal2,
    hctxVal = hctxVal.
  .output ImmutableHContextFromContext

  CompatibleHContexts(hctx1, hctx2) :-
    isHContext(hctx1),
    isHContext(hctx2),
    hctx1 = [partition, hctxv1],
    hctx2 = [partition, hctxv2],
    hctxv1 = hctxv1,
    hctxv2 = hctxv2.

  CompatibleContextAndHContext(ctx, hctx) :-
    isContext(ctx),
    isHContext(hctx),
    ctx = [partition, ctxv1, ctxv2],
    hctx = [partition, hctxv],
    ctxv1 = ctxv1,
    ctxv2 = ctxv2,
    hctxv = hctxv.

  // Merge optimization hack

  // MatchingMethodForInvocationAndType(type, invocation, tomethod) :-
  //   basic.ResolveInvocation(type, invocation, tomethod).

  // MatchingMethodForInvocationAndType(type, invocation, tomethod) :-
  //   SpecialMethodInvocation_Base(invocation, base),
  //   MethodInvocation_Method(invocation, tomethod),
  //   Var_Type(base, basetype),
  //   basic.SubtypeOf(type, basetype).

  PartitionForValue(value, partitionId) :-
    mainAnalysis.Value_Type(value, valueClass),
    TypeToPartitionId(valueClass, partitionId).

  ValueInAllPartitions(value) :-
    Value_DeclaringType(value, valueClass),
    TypeInAllPartitions(valueClass).

  NotValueInAllPartitions(value) :-
    Value_DeclaringType(value, valueClass),
    NotTypeInAllPartitions(valueClass).

  TypeInAllPartitions(type) :-
    isType(type),
    match("java\.util.*", type).

  NotTypeInAllPartitions(type) :-
    isType(type),
    !TypeInAllPartitions(type).

  PartitionForInvocation(invo, partitionId) :-
    Instruction_Method(invo, inmethod),
    Method_DeclaringType(inmethod, inClass),
    TypeToPartitionId(inClass, partitionId).

  PartitionForMethod(method, partitionId) :-
    Method_DeclaringType(method, inClass),
    TypeToPartitionId(inClass, partitionId).

  MethodInAllPartitions(method) :-
    Method_DeclaringType(method, type),
    TypeInAllPartitions(type).

  // PartitionForResolvedInvocation(type, invo, partitionId) :-
  //   MatchingMethodForInvocationAndType(type, invo, tomethod),
  //   Method_DeclaringType(tomethod, toclass),
  //   TypeToPartitionId(toclass, partitionId).

  /// Base the decision on the partition of the target method
  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value, valuetype),
    ((PartitionForMethod(tomethod, partition),
      PartitionForInvocation(invo, partition));
      TypeInAllPartitions(valuetype)),
    hctx = [partition, hctxValue],
    calleeCtx = [partition, hctxValue, value].

  ContextResponse(callerCtx, hctx, invo,value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value, valuetype),
    !(PartitionForMethod(tomethod, _)),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value, valuetype),
    PartitionForMethod(tomethod, partId),
    (!PartitionForInvocation(invo, partId) ;
     !PartitionForInvocation(invo, _)),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  // and for static methods
  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    ((PartitionForMethod(tomethod, partition),
      PartitionForInvocation(invo, partition));
      MethodInAllPartitions(tomethod)),
    calleeCtx = callerCtx.

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    !PartitionForMethod(tomethod, _),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    ((PartitionForMethod(tomethod, targetpartition),
      PartitionForInvocation(invo, invopartition),
      targetpartition != invopartition);
      !PartitionForInvocation(invo, _)),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).      

  ThreadStartContextResponse(callerCtx, hctx, value, newCtx) :-
    ThreadStartContextRequest(callerCtx, hctx, value),
    hctx = [partition, hctxValue],
    newCtx = [partition, hctxValue, value].
        
  StartupContextResponse(hctx, value, newCtx) :-
    StartupContextRequest(hctx, value),
    hctx = [partition, hctxValue],
    newCtx = [partition, hctxValue, value].
        
  FinalizerRegisterContextResponse(callerCtx, inmethod, value, newCtx) :-
    FinalizerRegisterContextRequest(callerCtx, inmethod, value),
    callerCtx = [partition, callerCtxValue1, callerCtxValue2],
    newCtx = [partition, callerCtxValue2, value],
    callerCtxValue1 = callerCtxValue1.
       
  InitContextResponse(value, ctx) :-
    InitContextRequest(value),
    isPartition(partition),
    ctx = [partition, value, value].

  InitHContextResponse(value, hctx) :-
    InitHContextRequest(value),
    isPartition(partition),
    hctx = [partition, value].


  // What are the necessary parameters for this analysis
  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value,var),
    ctx = [partition, ctxv1, ctxv2],
    (PartitionForValue(value, partition);
     ValueInAllPartitions(value)),
    hctx = [partition, ctxv2],
    ctxv1 = ctxv1.

  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value, var),
    PartitionForValue(value, partitionId1),
    ctx = [partitionId2, ctxv1, ctxv2],
    partitionId1 != partitionId2,
    NotValueInAllPartitions(value),
    ImmutableHContextFromContext(ctx, hctx),
    ctxv1 = ctxv1,
    ctxv2 = ctxv2.
  
  // Post-processing
 ValidCtxVar(ctx, var) :-
   mainAnalysis.ReachableContext(ctx, meth),
   Method_DeclaringType(meth, intype),
   Var_DeclaringMethod(var, meth),
   (!TypeToPartitionId(intype, _);
     TypeToPartitionId(intype, partition),
     ctx = [partition, ctxv1, ctxv2],
     ctxv1 = ctxv1,
     ctxv2 = ctxv2).
  
  CollapsedVarPointsTo(hctx, heap, ctx, var) :-
    mainAnalysis.VarPointsTo(hctx, heap, ctx, var),
    ValidCtxVar(ctx, var).
// .output isContext
// .output isHContext
// .output isImmutableContext
// .output isImmutableHContext

// .decl VerbatimContext(partition: Partition, value1: mainAnalysis.Value, value2: mainAnalysis.Value)
// .output VerbatimContext

// VerbatimContext(partition, value1, value2) :-
//   isContext(ctx),
//   ctx = [partition, value1, value2].

// .decl VerbatimHContext(partition: Partition, value: mainAnalysis.Value)
// .output VerbatimHContext

// VerbatimHContext(partition, value) :-
//    isHContext(hctx),
//    hctx = [partition, value].

// .decl VerbatimImmutableContext(partition: Partition, value1: mainAnalysis.Value, value2: mainAnalysis.Value)
// .output VerbatimImmutableContext

// VerbatimImmutableContext(partition, value1, value2) :-
//    isContext(ctx),
//    isImmutableContext(ctx),
//    ctx = [partition, value1, value2].

// .decl VerbatimImmutableHContext(partition: Partition, value: mainAnalysis.Value)
// .output VerbatimImmutableHContext

// VerbatimImmutableHContext(partition, value) :-
//    isHContext(hctx),
//    isImmutableHContext(hctx),
//    hctx = [partition, value].

}
