// Context-sensitive pointer analysis with context of 2 object and a
// context-sensitive heap abstraction.

// In this analysis, the real context is a pair of Values and the real
// heap context a single Value.

#include "../../main/single-phase-analysis.dl"
#include "../../main/configuration.dl"
#include "partitioning.dl"

.comp TwoObjectSensitivePlusHeapConfiguration : AbstractConfiguration {
  .type Context  = [ partition: Partition, value1:mainAnalysis.Value, value2:mainAnalysis.Value ]
  .type HContext = [ partition: Partition, value:mainAnalysis.Value ]

  .decl PartitionForValue(value: mainAnalysis.Value, partition: Partition)
  .decl ValueInAllPartitions(value: mainAnalysis.Value)
  .decl NotValueInAllPartitions(value: mainAnalysis.Value)
  .decl TypeInAllPartitions(type: Type)
  .decl NotTypeInAllPartitions(type: Type)
  .decl PartitionForInvocation(invo: Instruction, partition: Partition)
  .decl PartitionForMethod(method: Method, partition: Partition)
  .decl MethodInAllPartitions(method: Method)
  .decl PartitionForResolvedInvocation(type: Type, invo: Instruction, partition: Partition)
  .decl MatchingMethodForInvocationAndType(type: Type, invocation: Instruction, method: Method)

  .decl CachedMerge(invo: Instruction, hctx: HContext, value: mainAnalysis.Value, calleeCtx: Context)
  .decl CachedMergeStatic(callerCtx: Context, invo: Instruction, calleeCtx: Context)
  .decl MergeBasis(callerCtx: Context, invo: Instruction, hctx: HContext, value: mainAnalysis.Value)
  .decl MyMergeBasis(invo: Instruction, hctx: HContext, value: mainAnalysis.Value)
  .decl MergeStaticBasis(ctx: Context, invo: Instruction)

  .decl RecordBasis(var: Var, ctx: Context, value: mainAnalysis.Value)
  .decl MyRecordBasis(ctx: Context, value: mainAnalysis.Value)
  .decl CachedRecord(ctx: Context, value: mainAnalysis.Value, hctx: HContext)
  .decl _ValidCtxVar(ctx: Context, var: Var)
  .decl CollapsedVarPointsTo(hctx: HContext, heap: mainAnalysis.Value, ctx: Context, var: Var)

  // horrible indexing, but there will only be a handful of such contexts
  ImmutableContextFromHContext(hctx, ctx) :-
    isHContext(hctx),
    isImmutableContext(ctx),
    hctx = [partition, hctxVal],
    ctx = [partition, ctxVal1, ctxVal2].

  ImmutableContextFromContext(ctx1, ctx2) :-
    isContext(ctx1),
    isImmutableContext(ctx2),
    ctx1 = [partition, ctx1Val1, ctx1Val2],
    ctx2 = [partition, ctx2Val1, ctx2Val2].

  ImmutableHContextFromContext(ctx, hctx) :-
    isContext(ctx),
    isImmutableHContext(hctx),
    ctx = [partition, ctxVal1, ctxVal2],
    hctx = [partition, hctxVal].

  // Merge optimization hack

  MatchingMethodForInvocationAndType(type, invocation, tomethod) :-
    basic.ResolveInvocation(type, invocation, tomethod).

  MatchingMethodForInvocationAndType(type, invocation, tomethod) :-
    SpecialMethodInvocation_Base(invocation, base),
    MethodInvocation_Method(invocation, tomethod),
    Var_Type(base, basetype),
    basic.SubtypeOf(type, basetype).

  PartitionForValue(value, partitionId) :-
    mainAnalysis.Value_Type(value, valueClass),
    TypeToPartitionId(valueClass, partitionId).

  ValueInAllPartitions(value) :-
    Value_DeclaringType(value, valueClass),
    TypeInAllPartitions(valueClass).

  NotValueInAllPartitions(value) :-
    Value_DeclaringType(value, valueClass),
    NotTypeInAllPartitions(valueClass).

  TypeInAllPartitions(type) :-
    isType(type),
    match("java\.util.*", type).

  NotTypeInAllPartitions(type) :-
    isType(type),
    !TypeInAllPartitions(type).

  PartitionForInvocation(invo, partitionId) :-
    Instruction_Method(invo, inmethod),
    Method_DeclaringType(inmethod, inClass),
    TypeToPartitionId(inClass, partitionId).

  PartitionForMethod(method, partitionId) :-
    Method_DeclaringType(method, inClass),
    TypeToPartitionId(inClass, partitionId).

  MethodInAllPartitions(method) :-
    Method_DeclaringType(method, type),
    TypeInAllPartitions(type).

  PartitionForResolvedInvocation(type, invo, partitionId) :-
    MatchingMethodForInvocationAndType(type, invo, tomethod),
    Method_DeclaringType(tomethod, toclass),
    TypeToPartitionId(toclass, partitionId).


  /// Base the decision on the partition of the target method
  isContext(calleeCtx),
  ContextResponse(callerCtx, invo, hctx, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, _),
    mainAnalysis.Value_Type(value, valuetype),
      (TypeInAllPartitions(valuetype) ;
      (PartitionForResolvedInvocation(valuetype, invo, partition),
       PartitionForInvocation(invo, partition))),
    hctx = [__partition, __value1],
    calleeCtx = [__partition, __value1, value].

  ContextResponse(callerCtx, invo, hctx, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, _),
    mainAnalysis.Value_Type(value, valuetype),
    !(PartitionForResolvedInvocation(valuetype, invo, _)),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  ContextResponse(callerCtx, invo, hctx, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, _),
    mainAnalysis.Value_Type(value, valuetype),
    PartitionForResolvedInvocation(valuetype, invo, partId),
    ((!PartitionForInvocation(invo, partId)) ;
     (!PartitionForInvocation(invo, _))),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  // and for static methods
  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    ((PartitionForMethod(tomethod, partition),
    PartitionForInvocation(invo, partition));
    MethodInAllPartitions(tomethod)),
    calleeCtx = callerCtx.

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    !PartitionForMethod(tomethod, _),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    ((PartitionForMethod(tomethod, topartition),
     PartitionForInvocation(invo, invopartition),
     topartition != invopartition) ;
    !(PartitionForInvocation(invo, _))),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).



  // What are the necessary parameters for this analysis
  isHContext(hctx),
  RecordContextResponse(ctx, value, hctx) :-
    RecordContextRequest(ctx, value, _),
    ((ctx = [partition, ctxv1, ctxv2], PartitionForValue(value, partition)) ;
     ValueInAllPartitions(value)).

  RecordContextResponse(ctx, value, hctx) :-
    RecordContextRequest(ctx, value, _),
    PartitionForValue(value, partId),
    ctx = [partId2, ctxv1, ctxv2],
    partId != partId2,
    NotValueInAllPartitions(value),
    ImmutableHContextFromContext(ctx, hctx).

  // Post-processing
  _ValidCtxVar(ctx, var) :-
    mainAnalysis.ReachableContext(ctx, meth),
    Method_DeclaringType(meth, intype),
    Var_DeclaringMethod(var,meth),
    ((!TypeToPartitionId(intype, _));
     (TypeToPartitionId(intype, partition), ctx = [partition, ctxv1, ctxv2])).

  CollapsedVarPointsTo(hctx, heap, ctx, var) :-
    mainAnalysis.VarPointsTo(hctx, heap, ctx, var),
   _ValidCtxVar(ctx, var).
}
