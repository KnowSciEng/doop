/*************************************************************
 * Special objects
 *
 * Some objects are so common that they heavily impact performance if
 * every allocation is distinguished or a context-sensitive heap
 * abstraction is used. In many cases, this precision is not actually
 * useful for a points-to analysis, so handling them in a less precise
 * way is beneficial. This handling started from string constants and
 * is now expanded to cover (in many diverse ways) merging of all
 * library objects, exception objects, string buffers and builders,
 * and more.
 *************************************************************/

/**
 * Objects that should use a context-insensitive heap abstraction.
 */
.decl HeapAllocation_ContextInsensitive(?heap:HeapAllocation)

// Merged objects are currently always context-insensitive
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Merge(?heap, _).

/**
 * Objects that should be merged to some heap abstraction
 * (will overlap with merely context-insensitive objects)
 */
.decl HeapAllocation_Merge(?heap:HeapAllocation, ?mergeHeap:HeapAllocation)

// The ones that absolutely have to be kept distinct
.decl HeapAllocation_Keep(?heap:HeapAllocation)

/**
 * This is the handling for objects that are explicitly allocated in
 * the program text. There will also be other objects: pseudo objects
 * (null, string-constant), reified reflection objects, string
 * constants that the analysis thought are safe to merge, yet they do
 * arise reflectively, etc.
 */

.decl AssignNormalHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)
.decl AssignContextInsensitiveHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)

AssignNormalHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  !HeapAllocation_ContextInsensitive(?heap).

AssignContextInsensitiveHeapAllocation(?mergeHeap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_Merge(?heap, ?mergeHeap).

AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_ContextInsensitive(?heap),
  !(HeapAllocation_Merge(?heap, _)). // should be mostly unnecessary, but has bitten us many times


/*************************************************************
 * Special handling for all sorts of objects. All potential
 * representatives of an object are examined, and one is picked
 * for merging. The idea is to make the rest of the logic flexible:
 * signal as many reasons as apply for merging an object with
 * others and then have a single point in the code that decides
 * which merging is best.
 *************************************************************/

.decl HeapRepresentative(?heap:HeapAllocation, ?heapRepr:symbol)
.decl HeapIsMergedString(?heap:HeapAllocation)

// If the object is a string that should be merged, ignore other
// representatives and merge with that.
HeapIsMergedString(?heap) :-
  HeapRepresentative("<<string-constant>>", ?heap).
// Rule split in two since it needs to be stratified differently
.decl HeapIsMergedStringFactory(?heap:HeapAllocation)

#ifndef NO_MERGES
HeapAllocation_Merge(?heap, ?heapRepr) :-
  ?heapRepr = "<<string-constant>>",
  HeapRepresentative(?heapRepr, ?heap).

HeapIsMergedStringFactory(?heap) :-
  HeapRepresentative("<<string-buffer>>", ?heap);
  HeapRepresentative("<<string-builder>>", ?heap).

HeapAllocation_Merge(?heap, ?heapRepr) :-
  (?heapRepr = "<<string-buffer>>",
   HeapRepresentative(?heapRepr, ?heap));
  (?heapRepr = "<<string-builder>>",
   HeapRepresentative(?heapRepr, ?heap));
  (?heapRepr = "<<pystring-object>>",
   HeapRepresentative(?heapRepr, ?heap));
  (?heapRepr = "<<class-metaobject>>",
   HeapRepresentative(?heapRepr, ?heap)).

.decl RepresentativesToPickFrom(?heapRepr:HeapAllocation, ?heap:HeapAllocation)

RepresentativesToPickFrom(?heapRepr, ?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  !HeapIsMergedString(?heap),
  !HeapIsMergedStringFactory(?heap),
  !HeapAllocation_Keep(?heap).

.decl MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd:number, ?heap:HeapAllocation)

MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap) :-
  RepresentativesToPickFrom(_, ?heap),
  ?minHeapReprOrd = min ord(?heapRepr): RepresentativesToPickFrom(?heapRepr, ?heap).

HeapAllocation_Merge(?heap, ?mergeHeap) :-
  isHeapAllocation(?mergeHeap),
  ord(?mergeHeap) = ?minHeapReprOrd,
  MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap).
#endif

/*************************************************************
 * String constants
 *************************************************************/

#ifndef DISTINGUISH_ALL_STRING_CONSTANTS
#ifndef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS
#ifndef NO_MERGES
HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  ?constant = "<<string-constant>>",
  isHeapAllocation(?constant),
  !HeapAllocation_Keep(?heap).

// HeapRepresentative("<<class-metaobject>>", ?heap) :-
//   HeapAllocation_Type(?heap, "java.lang.Class"),
//   !HeapAllocation_Keep(?heap).

#endif
#endif
#endif // distinguish-no-string-constants mode

.decl ReflectionStringConstant(?heap:HeapAllocation)
.decl ReflectionSubstringObject(?heap:HeapAllocation)

#ifdef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS

.output ReflectionStringConstant

// This includes substrings, i.e., both exact and inexact matches!
ReflectionStringConstant(?heap) :-
  PreClassNameMatchingStringConstant(?heap);
  PreMethodNameMatchingStringConstant(?heap);
  PreFieldNameMatchingStringConstant(?heap).

// This is only for incomplete (i.e., substring) matches
ReflectionSubstringObject(?heap) :-
  PreClassNameMatchingStringConstantInexact_Type(_,?heap);
  PreMethodNameMatchingStringConstantInexact_Signature(_,?heap);
  PreFieldNameMatchingStringConstantInexact_Signature(_,?heap).

#ifndef NO_MERGES
HeapRepresentative("<<string-constant>>", ?heap) :-
  isStringConstant(?heap),
  !ReflectionStringConstant(?heap),
  !HeapAllocation_Keep(?heap).
#endif

#ifdef GROUP_REFLECTION_STRINGS

// ///// Naive Merging strategy: all strings that map to same reflection object
// ///// are merged. Not too effective.
// _StringRepresentativeForType[?type] = ?mergeHeap <-
//   agg<<?mergeHeap = min(?heap)>>(PreClassNameMatchingStringConstant:Type(?type, ?heap)).
// _StringRepresentativeForMethod[?sig] = ?mergeHeap <-
//   agg<<?mergeHeap = min(?heap)>>(PreMethodNameMatchingStringConstant:Signature(?sig, ?heap)).
// _StringRepresentativeForField[?sig] = ?mergeHeap <-
//   agg<<?mergeHeap = min(?heap)>>(PreFieldNameMatchingStringConstant:Signature(?sig, ?heap)).

// _OptPreClassNameMatchingStringConstant:Type(?heap, ?type) <-
//   PreClassNameMatchingStringConstant:Type(?type, ?heap).
// _OptPreMethodNameMatchingStringConstant:Signature(?heap, ?sig) <-
//   PreMethodNameMatchingStringConstant:Signature(?sig, ?heap).
// _OptPreFieldNameMatchingStringConstant:Signature(?heap, ?sig) <-
//   PreFieldNameMatchingStringConstant:Signature(?sig, ?heap).

// HeapRepresentative(?mergeHeap, ?heap) <-
//   _OptPreClassNameMatchingStringConstant:Type(?heap, ?type),
//   _StringRepresentativeForType[?type] = ?mergeHeap.

// HeapRepresentative(?mergeHeap, ?heap) <-
//   _OptPreMethodNameMatchingStringConstant:Signature(?heap, ?sig),
//   _StringRepresentativeForMethod[?sig] = ?mergeHeap.

// HeapRepresentative(?mergeHeap, ?heap) <-
//   _OptPreFieldNameMatchingStringConstant:Signature(?heap, ?sig),
//   _StringRepresentativeForField[?sig] = ?mergeHeap.
// ///// End naive merging strategy

///// Merging strategy that employs coloring of heap allocations based on
///// the classes they conflict on.

// REVIEW: There are two cases that are currently ignored, as too rare to matter:
//  -conflicts between a field and a method are not important. The constraint is
//   that string matching methods should not conflict with strings matching other
//   methods (and similar for fields), not with any member.
//  -we lose precision because we may merge strings that match different class
//   names.
.decl MethodOfClassMatchesString(?heap:HeapAllocation, ?type:Type)
.decl FieldOfClassMatchesString(?heap:HeapAllocation, ?type:Type)

MethodOfClassMatchesString(?heap, ?type) :-
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap),
  Method_DeclaringType(?sig, ?type).

FieldOfClassMatchesString(?heap, ?type) :-
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap),
  Field_DeclaringType(?sig, ?type).

// Important to not forget NullType: it derives from everything!
MethodOfClassMatchesString(?heap, ?type) :-
  MethodOfClassMatchesString(?heap, ?superType),
  basic.SubtypeOf(?type, ?superType),
  !isNullType(?type).

// Important to not forget NullType: it derives from everything!
FieldOfClassMatchesString(?heap, ?type) :-
  FieldOfClassMatchesString(?heap, ?superType),
  basic.SubtypeOf(?type, ?superType),
  !isNullType(?type).

// Also, we could restrict this to leaf classes, since they will
// exhibit maximal conflicts anyway. But this doesn't seem to pay off,
// at least in smaller benchmarks.

// Arbitrary ordering relation to determine coloring
.decl StringGreaterThanOtherInSameClass(?heap1:HeapAllocation, ?heap2:HeapAllocation, ?type:Type)

StringGreaterThanOtherInSameClass(?heap1, ?heap2, ?type) :-
  FieldOfClassMatchesString(?heap1, ?type),
  FieldOfClassMatchesString(?heap2, ?type),
  ord(?heap1) > ord(?heap2).

StringGreaterThanOtherInSameClass(?heap1, ?heap2, ?type) :-
  MethodOfClassMatchesString(?heap1, ?type),
  MethodOfClassMatchesString(?heap2, ?type),
  ord(?heap1) > ord(?heap2).

.decl MinStringOrdinalGreaterThanOtherInSameClass(?heap:HeapAllocation, ?heapGreaterOrd:number, ?type:Type)
.decl StringImmediatelyLessThanOtherInClass(?heap:HeapAllocation, ?type:Type, ?heapGreater:HeapAllocation)
.decl StringImmediatelyGreaterThanOtherInSomeClass(?heapGreater:HeapAllocation, ?heap:HeapAllocation)

MinStringOrdinalGreaterThanOtherInSameClass(?heap, ?heapGreaterOrd, ?type) :-
  StringGreaterThanOtherInSameClass(_, ?heap, ?type),
  ?heapGreaterOrd = min ord(?h): StringGreaterThanOtherInSameClass(?h, ?heap, ?type).

StringImmediatelyLessThanOtherInClass(?heap, ?type, ?heapGreater) :-
  MinStringOrdinalGreaterThanOtherInSameClass(?heap, ?heapGreaterOrd, ?type),
  isHeapAllocation(?heapGreater),
  ord(?heapGreater) = ?heapGreaterOrd.

StringImmediatelyGreaterThanOtherInSomeClass(?heapGreater, ?heap) :-
  StringImmediatelyLessThanOtherInClass(?heap, _, ?heapGreater).

.decl StringColorGreaterThan(?num:number, ?heap:HeapAllocation)

StringColorGreaterThan(0, ?heap) :-
  FieldOfClassMatchesString(?heap, _);
  MethodOfClassMatchesString(?heap, _).

StringColorGreaterThan(?num + 1, ?heap) :-
  StringImmediatelyGreaterThanOtherInSomeClass(?heap, ?heapLower),
  StringColorGreaterThan(?num, ?heapLower).

.decl StringColorForHeap(?heap:HeapAllocation, ?color:number)

StringColorForHeap(?heap, ?color) :-
  StringColorGreaterThan(_, ?heap),
  ?color = max (?n): StringColorGreaterThan(?n, ?heap).

.decl MinStringOrdinalForColor(?color:number, ?minHeapOrd:number)
.decl StringRepresentativeForColor(?color:number, ?heap:HeapAllocation)

MinStringOrdinalForColor(?color, ?minHeapOrd) :-
  StringColorForHeap(_, ?color),
  ?minHeapOrd = min ord(?heap): StringColorForHeap(?heap, ?color).

StringRepresentativeForColor(?color, ?mergeHeap) :-
  MinStringOrdinalForColor(?color, ?minHeapOrd),
  isHeapAllocation(?mergeHeap),
  ord(?mergeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?mergeHeap, ?heap) :-
  StringColorForHeap(?heap, ?color),
  StringRepresentativeForColor(?color, ?mergeHeap).
#endif
///// End coloring strategy

// Make the representative play (at a minimum) the same role as the
// original string re: reflection. This may introduce some imprecision
// (depending on the merging strategy), but it's expected to be small,
// compared to the cost of tracking full strings all over the code.
ClassNameMatchingStringConstant_Type(?type, ?heapRepr) :-
  HeapAllocation_Merge(?heap, ?heapRepr),
  PreClassNameMatchingStringConstant_Type(?type, ?heap).

MethodNameMatchingStringConstant_Signature(?sig, ?heapRepr) :-
  HeapAllocation_Merge(?heap, ?heapRepr),
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap).

FieldNameMatchingStringConstant_Signature(?sig, ?heapRepr) :-
  HeapAllocation_Merge(?heap, ?heapRepr),
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap).
#endif // GROUP_REFLECTION_STRINGS
#endif // DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS

HeapAllocation_ContextInsensitive(?heap) :-
  isStringConstant(?heap),
  !HeapRepresentative(_, ?heap).

.decl NonTrivialStringConstant(?heap:HeapAllocation)

NonTrivialStringConstant(?heap) :-
  isStringConstant(?heap),
  strlen(?heap) >= 7.

/**
 * String constants that (may) refer to class, method, and field names
 */
.decl ClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl MethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl FieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)

.decl PreClassNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantExact_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantInexact_Type(?type:Type, ?heap:HeapAllocation)

// These are the predicates that the outside world will use. The Pre-
// versions are so that they can be stratified earlier and strings can
// possibly be merged based on them.
ClassNameMatchingStringConstant_Type(?type, ?heap) :-
  PreClassNameMatchingStringConstant_Type(?type, ?heap).
MethodNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap).
FieldNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap).

// We distinguish between an exact match and a
// substring match.

PreClassNameMatchingStringConstant(?string),
PreClassNameMatchingStringConstant_Type(?type, ?string),
PreClassNameMatchingStringConstantExact_Type(?type, ?string) :-
  isStringConstant(?string),
  isReferenceType(?type),
#ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  ApplicationClass(?type),
     // library classes are known and in known packages. Makes no sense
     // to access them via .getClass
#endif
  // #ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  // #ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
  //   NonTrivialStringConstant(?string),
  // #endif
  // #endif
  ord(?type) = ord(?string).

.decl PreMethodNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantExact_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantInexact_Signature(?sig:Method, ?heap:HeapAllocation)

PreMethodNameMatchingStringConstant(?string),
PreMethodNameMatchingStringConstant_Signature(?sig, ?string),
PreMethodNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),
  //  Method_DeclaringType(?sig, ?type),
  //  ApplicationClass(?type),
     // there is some possibility of accessing methods and fields
     // reflectively, even in system classes. Maybe one needs to
     // circumvent access control, or maybe one wants to treat all
     // fields uniformly and some are inherited from a system superclass.
  Method_SimpleName(?sig, ?string),
  ?string != "<init>",
  ?string != "<clinit>". // common, yet not methods callable via reflection

.decl PreFieldNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantExact_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantInexact_Signature(?sig:Field, ?heap:HeapAllocation)

PreFieldNameMatchingStringConstant(?string),
PreFieldNameMatchingStringConstant_Signature(?sig, ?string),
PreFieldNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),
  // Field_DeclaringType(?sig, ?declaringClass),
  // ApplicationClass(?declaringClass);
  // #ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  // #ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
  //   NonTrivialStringConstant(?string),
  // #endif
  // #endif
  Field_SimpleName(?sig, ?string).

#ifdef REFLECTION_SUBSTRING_ANALYSIS
// Creating class/field/method names via string concatenation makes more
// sense for application classes/fields/methods.
PreClassNameMatchingStringConstant(?string),
PreClassNameMatchingStringConstant_Type(?type, ?string),
PreClassNameMatchingStringConstantInexact_Type(?type, ?string) :-
  isHeapAllocation(?string),
#ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  ApplicationClass(?type),
#endif
  ClassNameSuffix(?string, ?type).

PreMethodNameMatchingStringConstant(?string),
PreMethodNameMatchingStringConstant_Signature(?sig, ?string),
PreMethodNameMatchingStringConstantInexact_Signature(?sig, ?string) :-
#ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  ApplicationClass(?type),
  Method_DeclaringType(?sig, ?type),
#endif
  (MethodNameSuffix(?string, ?sig);
   MethodNamePrefix(?string, ?sig)),
  isHeapAllocation(?string),
  ?string != "<init>",
  ?string != "<clinit>". // common, yet not methods callable via reflection

PreFieldNameMatchingStringConstant(?string),
PreFieldNameMatchingStringConstant_Signature(?sig, ?string),
PreFieldNameMatchingStringConstantInexact_Signature(?sig, ?string) :-
#ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  ApplicationClass(?declaringClass),
  Field_DeclaringType(?sig, ?declaringClass),
#endif
  (FieldNameSuffix(?string, ?sig);
   FieldNamePrefix(?string, ?sig)),
  isHeapAllocation(?string).


.decl ClassIterationTrick(?length:number)
ClassIterationTrick(7).
ClassIterationTrick(?length+1) :- ClassIterationTrick(?length), ?length < 90.

.decl MemberPrefixIterationTrick(?length:number)
MemberPrefixIterationTrick(7).
#ifdef REFLECTION_HIGH_SOUNDNESS_MODE
MemberPrefixIterationTrick(3).
#endif
MemberPrefixIterationTrick(?length+1) :- MemberPrefixIterationTrick(?length), ?length < 90.

.decl MemberSuffixIterationTrick(?length:number)
MemberSuffixIterationTrick(7).
#ifdef REFLECTION_HIGH_SOUNDNESS_MODE
MemberSuffixIterationTrick(5).
#endif
MemberSuffixIterationTrick(?length+1) :- MemberSuffixIterationTrick(?length), ?length < 90.


.decl string_upper(s1:symbol, s2:symbol)

string_upper("a", "A"). string_upper("b", "B"). string_upper("c", "C"). string_upper("d", "D").
string_upper("e", "E"). string_upper("f", "F"). string_upper("g", "G"). string_upper("h", "H").
string_upper("i", "I"). string_upper("j", "J"). string_upper("k", "K"). string_upper("l", "L").
string_upper("m", "M"). string_upper("n", "N"). string_upper("o", "O"). string_upper("p", "P").
string_upper("q", "Q"). string_upper("r", "R"). string_upper("s", "S"). string_upper("t", "T").
string_upper("u", "U"). string_upper("v", "V"). string_upper("w", "W"). string_upper("x", "X").
string_upper("y", "Y"). string_upper("z", "Z").
string_upper("A", "A"). string_upper("B", "B"). string_upper("C", "C"). string_upper("D", "D").
string_upper("E", "E"). string_upper("F", "F"). string_upper("G", "G"). string_upper("H", "H").
string_upper("I", "I"). string_upper("J", "J"). string_upper("K", "K"). string_upper("L", "L").
string_upper("M", "M"). string_upper("N", "N"). string_upper("O", "O"). string_upper("P", "P").
string_upper("Q", "Q"). string_upper("R", "R"). string_upper("S", "S"). string_upper("T", "T").
string_upper("U", "U"). string_upper("V", "V"). string_upper("W", "W"). string_upper("X", "X").
string_upper("Y", "Y"). string_upper("Z", "Z").
string_upper("0", "0"). string_upper("1", "1"). string_upper("2", "2"). string_upper("3", "3").
string_upper("4", "4"). string_upper("5", "5"). string_upper("6", "6"). string_upper("7", "7").
string_upper("8", "8"). string_upper("9", "9").

// Exploit camel-case convention

#define StringChangesCaseAfterPosition(pos, str) \
  ((substr(str, pos, 1) = char, \
  substr(str, pos + 1, 1) = nextChar, \
  ((string_upper(char, Uchar), Uchar = char, string_upper(nextChar, UnextChar), UnextChar != nextChar); \
   (string_upper(char, Uchar), Uchar != char, string_upper(nextChar, UnextChar), UnextChar = nextChar))); \
  (substr(str, pos + 1, 1) = nextChar, \
   (nextChar = "_"; \
    nextChar = "."; \
    nextChar = "$")); \
  (substr(str, pos, 1) = char, \
   (char = "_"; \
    char = "."; \
    char = "$")))

#define StringChangesCaseBeforePosition(pos, str) \
  ((substr(str, pos, 1) = char, \
  substr(str, pos - 1, 1) = prevChar, \
  ((string_upper(char, Uchar), Uchar = char, string_upper(prevChar, UprevChar), UprevChar != prevChar); \
   (string_upper(char, Uchar), Uchar != char, string_upper(prevChar, UprevChar), UprevChar = prevChar))); \
  (substr(str, pos - 1, 1) = prevChar, \
   (prevChar = "_"; \
    prevChar = "."; \
    prevChar = "$")); \
  (substr(str, pos, 1) = char, \
   (char = "_"; \
    char = "."; \
    char = "$")))

.decl ClassNameSuffix(?suffix:symbol, ?classname:ReferenceType)
.decl MethodNameSuffix(?suffix:symbol, ?sig:Method)
.decl MethodNamePrefix(?prefix:symbol, ?sig:Method)
.decl FieldNameSuffix(?suffix:symbol, ?sig:Field)
.decl FieldNamePrefix(?prefix:symbol, ?sig:Field)

// Precompute proper suffixes. Crucial for efficiency.
ClassNameSuffix(substr(?className, strlen(?className) - ?length, ?length), ?className) :-
  isReferenceType(?className),
  ClassIterationTrick(?length),
  strlen(?className) > ?length,
  StringChangesCaseBeforePosition(strlen(?className) - ?length, ?className).

MethodNameSuffix(substr(?methodName, strlen(?methodName) - ?length, ?length), ?sig) :-
  Method_SimpleName(?sig, ?methodName),
  MemberSuffixIterationTrick(?length),
  strlen(?methodName) > ?length,
  StringChangesCaseBeforePosition(strlen(?methodName) - ?length, ?methodName).

MethodNamePrefix(substr(?methodName, 0, ?length), ?sig) :-
  Method_SimpleName(?sig, ?methodName),
  MemberPrefixIterationTrick(?length),
  strlen(?methodName) > ?length,
  StringChangesCaseAfterPosition(?length - 1, ?methodName).

FieldNameSuffix(substr(?fieldName, strlen(?fieldName) - ?length, ?length), ?sig) :-
  Field_SimpleName(?sig, ?fieldName),
  MemberSuffixIterationTrick(?length),
  strlen(?fieldName) > ?length,
  StringChangesCaseBeforePosition(strlen(?fieldName) - ?length, ?fieldName).

FieldNamePrefix(substr(?fieldName, 0, ?length), ?sig) :-
  Field_SimpleName(?sig, ?fieldName),
  MemberPrefixIterationTrick(?length),
  strlen(?fieldName) > ?length,
  StringChangesCaseAfterPosition(?length - 1, ?fieldName).

//// Too costly!
//ClassNameSuffix(?type, ?suffix) <-
//  ReferenceType(?type),
//  Type:Id(?type:?className),
//  string:length[?className] = ?classNameLength,
//  ?pos = ?classNameLength / 2 + 1,
//  ?suffixLength = ?classNameLength - ?pos,
//  string:substring[?className, ?pos, ?suffixLength] = ?suffix.
//
//PreClassNameMatchingStringConstant(?heap),
//PreClassNameMatchingStringConstant:Type(?type, ?heap)
//  <-
//  NonTrivialStringConstant(?heap),
//  HeapAllocation:Id[?heap] = ?string,
//  ClassNameSuffix(?type, ?suffix),
//  string:substring[?suffix, _, string:length[?string]] = ?string.
//
//PreMethodNameMatchingStringConstant(?heap),
//PreMethodNameMatchingStringConstant:Signature(?sig, ?heap)
//  <-
//  NonTrivialStringConstant(?heap),
//  HeapAllocation:Id[?heap] = ?string,
//  Method:SimpleName[?sig] = ?methodName,
//  (string:substring[?methodName, _, _] = ?string ; ?methodName = ?string).

#endif // REFLECTION_SUBSTRING_ANALYSIS


/*************************************************************
 * Class constants
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  isClassHeap(?heap).

/*************************************************************
 * Merging allocation sites per method, per class, or per package
 *************************************************************/

// Per-method merging: auto-merge allocation sites for method that
// allocates many objects of same type. Also, enable other rules to
// explicitly ask for per-method merging, beyond the above heuristic
// (by setting "...ShouldBeMerged...").

.decl MethodAllocationMergeThreshold(?t:number)

MethodAllocationMergeThreshold(50).

.decl ExceptionType(?type:Type)

ExceptionType(?type) :-
  ?throw = "java.lang.Throwable",
  isType(?throw),
  basic.SubtypeOf(?type, ?throw).

.decl OptAssignHeapAllocation(?inmethod:Method, ?heap:HeapAllocation)

OptAssignHeapAllocation(?inmethod, ?heap) :-
  AssignHeapAllocation(?heap, _, ?inmethod).

// There are objects, like strings, null, and class objects, that
// don't have a unique allocation site.
.decl ObjectMultipleAllocated(?heap:HeapAllocation)

ObjectMultipleAllocated(?heap) :-
  OptAssignHeapAllocation(?inmethod1, ?heap),
  OptAssignHeapAllocation(?inmethod2, ?heap),
  ?inmethod1 != ?inmethod2.

.decl MethodAndTypeToHeap(?heap:HeapAllocation, ?heapType:Type, ?method:Method)

MethodAndTypeToHeap(?heap, ?heaptype, ?meth) :-
  AssignHeapAllocation(?heap, _, ?meth),
  HeapAllocation_Type(?heap, ?heaptype),
  !isStringConstant(?heap),
  !StringFactoryHeap(?heap),
  !HeapAllocation_EmptyArray(?heap),
  !ObjectMultipleAllocated(?heap),
  !HeapAllocation_Keep(?heap).

.decl AllocationsPerMethodAndType(?type:Type, ?meth:Method, ?n:number)

AllocationsPerMethodAndType(?type, ?meth, ?n) :-
  MethodAndTypeToHeap(_, ?type, ?meth),
  ?n = count : MethodAndTypeToHeap(_, ?type, ?meth).

.decl AllocationShouldBeMergedPerMethod(?heaptype:Type, ?meth:Method)

AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  MethodAllocationMergeThreshold(?t),
  ?n > ?t.

.decl MethodAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?meth:Method)

MethodAndTypeToMergedHeap(?heap, ?heaptype, ?meth) :-
  AllocationShouldBeMergedPerMethod(?heaptype, ?meth),
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth).

.decl MinHeapOrdinalPerMethodAndType(?ord:number, ?type:Type, ?meth:Method)
.decl MethodAndTypeToRepresentative(?type:Type, ?meth:Method, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth) :-
  MethodAndTypeToMergedHeap(_, ?type, ?meth),
  ?minHeapOrd = min ord(?heap): MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap),
  MethodAndTypeToMergedHeap(?heap, ?type, ?meth).
#endif
// Now, per-class merging. This is more rare and should be requested
// explicitly for a given type. Again, does not apply to types with
// special merging policies.
.decl ClassAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:ClassType)
.decl AllocationsPerClassAndType(?type:Type, ?class:ClassType, ?n:number)

ClassAndTypeToHeap(?heap, ?heaptype, ?class) :-
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth),
  Method_DeclaringType(?meth, ?class).

AllocationsPerClassAndType(?type, ?class, ?n) :-
  ClassAndTypeToHeap(_, ?type, ?class),
  ?n = count : ClassAndTypeToHeap(_, ?type, ?class).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedPerClass(?heaptype:Type, ?class:Type)

.decl ClassAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:Type)

ClassAndTypeToMergedHeap(?heap, ?heaptype, ?class) :-
  AllocationShouldBeMergedPerClass(?heaptype, ?class),
  ClassAndTypeToHeap(?heap, ?heaptype, ?class).

.decl MinHeapOrdinalPerClassAndType(?minHeapOrd:number, ?type:Type, ?class:Type)
.decl ClassAndTypeToRepresentative(?type:Type, ?class:Type, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class) :-
  ClassAndTypeToMergedHeap(_, ?type, ?class),
  ?minHeapOrd = min ord(?heap): ClassAndTypeToMergedHeap(?heap, ?type, ?class).

ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap),
  ClassAndTypeToMergedHeap(?heap, ?type, ?class).
#endif
// Same for per-package merging.
#include "package-heuristic.dl"

.decl PackageAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)
.decl AllocationsPerPackageAndType(?type:Type, ?packageName:symbol, ?n:number)

PackageAndTypeToHeap(?heap, ?heaptype, ?packageName) :-
  ClassAndTypeToHeap(?heap, ?heaptype, ?class),
  Class_PackageHack(?class, ?packageName).

AllocationsPerPackageAndType(?type, ?packageName, ?n) :-
  PackageAndTypeToHeap(_, ?type, ?packageName),
  ?n = count : PackageAndTypeToHeap(_, ?type, ?packageName).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedPerPackage(?heaptype:Type, ?packageName:symbol)

.decl PackageAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)

PackageAndTypeToMergedHeap(?heap, ?heaptype, ?packageName) :-
  AllocationShouldBeMergedPerPackage(?heaptype, ?packageName),
  PackageAndTypeToHeap(?heap, ?heaptype, ?packageName).

.decl MinHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, ?packageName:symbol)
.decl PackageAndTypeToRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName) :-
  PackageAndTypeToMergedHeap(_, ?type, ?packageName),
  ?minHeapOrd = min ord(?heap): PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).

PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap),
  PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).
#endif
// And the ultimate: universal per-type merging
.decl TypeToHeap(?heap:HeapAllocation, ?heaptype:Type)
.decl AllocationsPerType(?type:Type, ?n:number)

TypeToHeap(?heap, ?heaptype) :-
  ClassAndTypeToHeap(?heap, ?heaptype, _).

AllocationsPerType(?type, ?n) :-
  TypeToHeap(_, ?type),
  ?n = count : TypeToHeap(_, ?type).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedGlobally(?heaptype:Type)

.decl TypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type)

TypeToMergedHeap(?heap, ?heaptype) :-
  AllocationShouldBeMergedGlobally(?heaptype),
  TypeToHeap(?heap, ?heaptype).

.decl MinHeapOrdinalPerType(?minHeapOrd:number, ?type:Type)
.decl TypeToRepresentative(?type:Type, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerType(?minHeapOrd, ?type) :-
  TypeToMergedHeap(_, ?type),
  ?minHeapOrd = min ord(?heap): TypeToMergedHeap(?heap, ?type).

TypeToRepresentative(?type, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerType(?minHeapOrd, ?type),
  ord(?representativeHeap) = ?minHeapOrd.

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  TypeToRepresentative(?type, ?representativeHeap),
  TypeToMergedHeap(?heap, ?type).
#endif
/*************************************************************
 * Coarse-grained allocation policy
 *************************************************************/

#ifdef COARSE_GRAINED_ALLOCATION
// // Ultra coarse-grained allocation policy
// AllocationShouldBeMergedGlobally(?type) :-
//   AllocationsPerType(?type, ?n),
//  ?n > 1.

// // Very coarse-grained allocation policy
// AllocationShouldBeMergedPerPackage(?type, ?packageName) :-
//   AllocationsPerPackageAndType(?type, ?packageName, ?n),
//   ?n > 1.

// Coarse-grained allocation policy
AllocationShouldBeMergedPerClass(?type, ?class) :-
  AllocationsPerClassAndType(?type, ?class, ?n),
  ?n > 1.
#endif // COARSE_GRAINED_ALLOCATION


/*************************************************************
 * Library class that should be treated specially
 *************************************************************/

#ifndef CONTEXT_SENSITIVE_LIBRARY_ANALYSIS
  #include "special-library.dl"
  HeapAllocation_ContextInsensitive(?heap) :-
    SpecialLibraryObject(?heap),
    !HeapRepresentative(_, ?heap).

  #ifdef MERGE_LIBRARY_OBJECTS_PER_METHOD

    AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
      AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
      ?n > 1,
      Method_DeclaringType(?meth, ?class),
      SpecialLibraryClass(?class).

  #endif
#endif

/*************************************************************
 * String buffers and builders
 *************************************************************/

.decl StringFactoryType(?type:Type)
.decl StringFactoryHeap(?heap:HeapAllocation)

StringFactoryType(?type) :-
  ?type = "java.lang.StringBuffer" ;
  ?type = "java.lang.StringBuilder".

StringFactoryHeap(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  StringFactoryType(?heaptype).

.decl StringFactoryVar(?var:Var)

#ifndef DISTINGUISH_ALL_STRING_BUFFERS
#ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
#ifdef DISTINGUISH_STRING_BUFFERS_PER_PACKAGE

.decl PackageAndTypeToStringFactoryHeap(?heap:HeapAllocation, ?type:Type, ?packageName:symbol)

PackageAndTypeToStringFactoryHeap(?heap, ?heaptype, ?packageName) :-
  StringFactoryType(?heaptype),
  HeapAllocation_Type(?heap, ?heaptype),
  AssignHeapAllocation(?heap, _, ?meth),
  Method_DeclaringType(?meth, ?class),
  Class_PackageHack(?class, ?packageName).

.decl MinStringFactoryHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, packageName:symbol)
.decl PackageAndTypeToStringFactoryRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)

MinStringFactoryHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName) :-
  PackageAndTypeToStringFactoryHeap(_, ?type, ?packageName),
  ?minHeapOrd = min ord(?heap): PackageAndTypeToStringFactoryHeap(?heap, ?type, ?packageName).

PackageAndTypeToStringFactoryRepresentative(?type, ?packageName, ?representativeHeap) :-
  MinStringFactoryHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName),
  StringFactoryHeap(?representativeHeap),
  ord(?representativeHeap) = ?minHeapOrd.

// current policy: all string builders merged per-package
#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  PackageAndTypeToStringFactoryHeap(?heap, ?type, ?packageName),
  PackageAndTypeToStringFactoryRepresentative(?type, ?packageName, ?representativeHeap).
#endif
//// Used to be all are merged per-class:
// // all string buffers (and builders) in the same class are merged
// AllocationShouldBeMergedPerClass(?heaptype, ?class) <-
//   AllocationsPerClassAndType[?heaptype, ?class] > 1,
//   StringFactoryType(?heaptype).

//// Used to be per-method:
// AllocationShouldBeMergedPerMethod(?heaptype, ?meth) <-
//   AllocationsPerMethodAndType[?heaptype, ?meth] > 1,
//   StringFactoryType(?heaptype).
#else // not DISTINGUISH_STRING_BUFFERS_PER_PACKAGE, i.e., merge them all
#ifndef NO_MERGES
HeapRepresentative("<<string-buffer>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuffer"),
  !HeapAllocation_Keep(?heap).

HeapRepresentative("<<string-builder>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuilder"),
  !HeapAllocation_Keep(?heap).

HeapRepresentative("<<pystring-object>>", ?heap) :-
  HeapAllocation_Type(?heap, "org.python.core.PyString"),
  !HeapAllocation_Keep(?heap).
#endif
#endif
#endif
#endif

/*************************************************************
 * Throwable
 *************************************************************/

/*
 // (Yannis) This is the original, precise and straightforward treatment
 // of throwables. They were allocated context insensitively. This still
 // produced huge ThrowPointsTo sets and caused slowdowns.
 */
#ifdef SEPARATE_EXCEPTION_OBJECTS
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?type),
  ExceptionType(?type).
#else

// The optimized treatment represents every exception (i.e., throwable)
// object by a unique representative of the same type. All exception
// objects of the same type are therefore merged. This means that points-to
// results for throwables are not accurate! Only the type will be right.

//.decl ExceptionTypeToHeap2(?heap:HeapAllocation, ?type:Type)
//
//ExceptionTypeToHeap2(?heap, ?heaptype) :-
//  HeapAllocation_Type(?heap, ?heaptype),
//  basic.SubtypeOf(?heaptype, "java.lang.Throwable"),
//  ExceptionHandler_Type(_, ?handlertype),
//  basic.SubtypeOf(?heaptype, ?handlertype).

.decl ExceptionTypeToHeap(?heap:HeapAllocation, ?type:Type)

ExceptionTypeToHeap(?heap, ?heaptype) :-
  AssignHeapAllocation(?heap, _, _),
  HeapAllocation_Type(?heap, ?heaptype),
  ExceptionType(?heaptype).

.decl ExceptionHeapTypeRepresentativeOrdinal(?type:Type, ?reprHeapOrd:number)

ExceptionHeapTypeRepresentativeOrdinal(?type, ?representativeHeapOrd) :-
  ExceptionTypeToHeap(_, ?type),
  ?representativeHeapOrd = min ord(?heap) : ExceptionTypeToHeap(?heap, ?type).

#ifndef NO_MERGES
HeapRepresentative(?representativeHeap, ?heap) :-
  ExceptionHeapTypeRepresentativeOrdinal(?heaptype, ?representativeHeapOrd),
  ExceptionTypeToHeap(?heap, ?heaptype),
  ord(?representativeHeap) = ?representativeHeapOrd,
  isHeapAllocation(?representativeHeap).
#endif
#endif // SEPARATE_EXCEPTION_OBJECTS
/*
// An intermediate option is to only merge exception objects of the
// same type that are thrown in the same method.
SameTypeAndMethod(?heap1, ?heap2) <-
  HeapAllocation:Type[?heap1] = ?heaptype,
  Type:Id(?throw:"java.lang.Throwable"),
  basic.SubtypeOf(?heaptype, ?throw),
  HeapAllocation:Type[?heap2] = ?heaptype,
  AssignHeapAllocation(?heap1,_,?inmethod),
  AssignHeapAllocation(?heap2,_,?inmethod).

// Similarly quadratic but efficient.
HeapRepresentative(?representativeHeap, ?heap) <-
  agg<<?representativeHeap = min(?otherHeap)>>(SameTypeAndMethod(?otherHeap,?heap)).
*/

/*************************************************************
 * Primitive arrays
 *
 * char[] or int[] don't have object elements, so it's useless to
 * allocate them context-sensitively.
 *
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isArrayType(?type),
  ComponentType(?type, ?componentType),
  isPrimitiveType(?componentType).

/*************************************************************
 * Class without reference fields
 *
 * Treat context-insensitively always? It doesn't matter much,
 * but doesn't hurt much either.
 *************************************************************/

/*
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  Type_HasNoReferenceField(?heaptype),
  !HeapRepresentative(_, ?heap).
  // The rules have become complex enough that they overlap.

.decl Type_HasNoReferenceField(?type:Type)
.decl Type_DeclaresReferenceField(?type:Type)

Type_HasNoReferenceField("java.lang.Object").

Type_HasNoReferenceField(?class) :-
  isClassType(?class),
  DirectSuperclass(?class, ?super),
  Type_HasNoReferenceField(?super),
  !Type_DeclaresReferenceField(?class).

Type_DeclaresReferenceField(?class) :-
  isClassType(?class),
  Field_DeclaringType(?signature, ?class),
  Field_Type(?signature, ?type),
  ReferenceType(?type),
  !FieldIsStatic(?signature).

FieldIsStatic(?sig) :-
  Field_Modifier("static", ?sig).

//// Quite risky: even final fields hold interesting state.
//FieldIsStaticOrFinal?sig) <-
//  Modifier:Id(?final:"final"),
//  Field:Modifier(?final, ?sig).
*/


/*************************************************************
 * Primitive types
 *
 * Needed for precise handling of Class.getPrimitiveClass().
 *************************************************************/

ReflectionStringConstant("int").
ReflectionStringConstant("float").
ReflectionStringConstant("double").
ReflectionStringConstant("byte").
ReflectionStringConstant("boolean").
ReflectionStringConstant("char").
ReflectionStringConstant("long").
ReflectionStringConstant("short").
ReflectionStringConstant("void").


/*************************************************************
 * Suffix helper relations
 *
 * Needed for precise handling of Class.getPrimitiveClass().
 *************************************************************/

// Very silly we have to do this.
.decl _StringIterationTrick(?pos:number)
_StringIterationTrick(0).
_StringIterationTrick(?pos + 1) :- _StringIterationTrick(?pos), ?pos < 256.

.decl RelevantSuffixPosition(?typeName: symbol, ?pos:number)
RelevantSuffixPosition(?typeName, ?pos) :-
  isType(?typeName),
  _StringIterationTrick(?pos), ?pos < strlen(?typeName).

.decl Suffix(?type:Type, ?suffix:symbol, ?suffixLen:number)

Suffix(?type, ?suffix, ?suffixLen) :-
  RelevantSuffixPosition(?type, ?pos),
  substr(?type, ?pos, 1) = ".",
  ?suffixLen = strlen(?type) - ?pos - 1,
  ?suffix = substr(?type, ?pos + 1, ?suffixLen).

Suffix(?type, ?type, ?suffixLen) :-
  isType(?type),
  ?suffixLen = strlen(?type).

.decl MinimalSuffixLen(?type:Type, ?suffixLen:number)

MinimalSuffixLen(?type, ?suffixLen) :-
  isType(?type),
  ?suffixLen = min ?len : Suffix(?type, _, ?len).

// Computes the suffix after the last dot of a type name.
.decl MinimalSuffix(?type:Type, ?suffix:symbol)

MinimalSuffix(?type, ?suffix) :-
  MinimalSuffixLen(?type, ?suffixLen),
  Suffix(?type, ?suffix, ?suffixLen).
