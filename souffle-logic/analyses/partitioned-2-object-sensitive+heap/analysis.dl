#include "../../main/single-phase-analysis.dl"
#include "../../main/configuration.dl"
#ifndef USER_DEFINED_PARTITIONS
#include "partitioning.dl"
#else
.decl TypeToPartition(?type: Type, ?partitionRepresentativeType: symbol)
.input TypeToPartition(IO="file", filename="TypeToPartition.facts", delimiter=",")

TypeToPartitionId(?type, ?partitionId) :-
    TypeToPartition(?type, ?partitionRepresentativeType),
    ?partitionId = ord(?partitionRepresentativeType).

isPartition(?partitionId) :-
  TypeToPartitionId(_, ?partitionId).

.output TypeToPartition
#endif

.output TypeToPartitionId

.number_type Partition

.decl isPartition(partition: Partition)
.decl TypeToPartitionId(?type: Type, ?partition: Partition)

.comp PartitionedTwoObjectSensitivePlusHeapConfiguration : AbstractConfiguration {

  .type Context  = [ partition: Partition, value1:mainAnalysis.Value, value2:mainAnalysis.Value ]
  .type HContext = [ partition: Partition, value:mainAnalysis.Value ]
  
  .decl PartitionForInvocation(invo: Instruction, partition: Partition)
  .decl PartitionForMethod(method: Method, partition: Partition)
  .decl PartitionForVar(var: Var, partition: Partition)

  .decl TypeInAllPartitions(type: Type)
  .decl VarInAllPartitions(var: Var)
  .decl MethodInAllPartitions(method: Method)

  .decl ValidCtxVar(ctx: mainAnalysis.configuration.Context, var: Var)
  .decl CollapsedVarPointsTo(hctx: mainAnalysis.configuration.HContext, heap: mainAnalysis.Value, ctx: mainAnalysis.configuration.Context, var: Var)

  
  isContext(ctx),
  ImmutableContextFromHContext(hctx, ctx) :-
    isHContext(hctx),
    isImmutableContext(ctx),
    hctx = [partition, hctxVal],
    ctx = [partition, ctxVal1, ctxVal2],
    ctxVal1 = ctxVal1,
    ctxVal2 = ctxVal2,
    hctxVal = hctxVal.

  ImmutableContextFromContext(ctx1, ctx2) :-
    isContext(ctx1),
    isImmutableContext(ctx2),
    ctx1 = [partition, ctx1Val1, ctx1Val2],
    ctx2 = [partition, ctx2Val1, ctx2Val2],
    ctx1Val1 = ctx1Val1,
    ctx1Val2 = ctx1Val2,
    ctx2Val1 = ctx2Val1,
    ctx2Val2 = ctx2Val2.

  ImmutableHContextFromContext(ctx, hctx) :-
    isContext(ctx),
    isImmutableHContext(hctx),
    ctx = [partition, ctxVal1, ctxVal2],
    hctx = [partition, hctxVal],
    ctxVal1 = ctxVal1,
    ctxVal2 = ctxVal2,
    hctxVal = hctxVal.

  TypeInAllPartitions(type) :-
    isType(type),
    match("java\.util.*", type).

  PartitionForInvocation(invo, partitionId) :-
    Instruction_Method(invo, inmethod),
    Method_DeclaringType(inmethod, inClass),
    TypeToPartitionId(inClass, partitionId).

  PartitionForMethod(method, partitionId) :-
    Method_DeclaringType(method, inClass),
    TypeToPartitionId(inClass, partitionId).

  MethodInAllPartitions(method) :-
    Method_DeclaringType(method, type),
    TypeInAllPartitions(type).

  PartitionForVar(var, partitionId) :-
    Var_DeclaringMethod(var, method),
    PartitionForMethod(method, partitionId).

  VarInAllPartitions(var) :-
    Var_DeclaringMethod(var, inmethod),
    MethodInAllPartitions(inmethod).

  /// Base the decision on the partition of the target method
  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value,  valuetype),
      (TypeInAllPartitions(valuetype) ;
      (PartitionForMethod(tomethod, partition),
       PartitionForInvocation(invo, partition))),
    hctx = [__partition, __value1],
    calleeCtx = [__partition, __value1, value].

  ContextResponse(callerCtx, hctx, invo,value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value, valuetype),
    !(PartitionForMethod(tomethod, _)),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value, valuetype),
    PartitionForMethod(tomethod, partId),
    !PartitionForInvocation(invo, partId),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  // and for static methods
  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    ((PartitionForMethod(tomethod, partition),
      PartitionForInvocation(invo, partition));
     MethodInAllPartitions(tomethod)),
    calleeCtx = callerCtx.

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    !PartitionForMethod(tomethod, _),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    PartitionForMethod(tomethod, topartition),
    !PartitionForInvocation(invo, topartition),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).

  ThreadStartContextResponse(callerCtx, hctx, value, newCtx) :-
    ThreadStartContextRequest(callerCtx, hctx, value),
    hctx = [partition, hctxValue],
    newCtx = [partition, hctxValue, value].

  StartupContextResponse(hctx, value, newCtx) :-
    StartupContextRequest(hctx, value),
    hctx = [partition, hctxValue],
    newCtx = [partition, hctxValue, value].

  FinalizerRegisterContextResponse(callerCtx, inmethod, value, newCtx) :-
    FinalizerRegisterContextRequest(callerCtx, inmethod, value),
    callerCtx = [partition, callerCtxValue1, callerCtxValue2],
    newCtx = [partition, callerCtxValue2, value],
    callerCtxValue1 = callerCtxValue1.

  InitContextResponse(value, ctx) :-
    InitContextRequest(value),
    isPartition(partition),
    ctx = [partition, value, value].

  InitHContextResponse(value, hctx) :-
    InitHContextRequest(value),
    isPartition(partition),
    hctx = [partition, value].

  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value, var),
    ctx = [partition, ctxv1, ctxv2],
    (PartitionForVar(var, partition);
     VarInAllPartitions(var)),
    hctx = [partition, ctxv2],
    ctxv1 = ctxv1.

  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value, var),
    !PartitionForVar(var, partId),
    ctx = [partId, ctxv1, ctxv2],
    !VarInAllPartitions(var),
    ImmutableHContextFromContext(ctx, hctx),
    ctxv1 = ctxv1,
    ctxv2 = ctxv2.

  // Post-processing
  ValidCtxVar(ctx, var) :-
    mainAnalysis.ReachableContext(ctx, meth),
    Method_DeclaringType(meth, intype),
    Var_DeclaringMethod(var, meth),
    ((!TypeToPartitionId(intype, _));
     (TypeToPartitionId(intype, partition),
      !isImmutableContext(ctx),
      ctx = [partition, ctxv1, ctxv2],
      ctxv1 = ctxv1,
      ctxv2 = ctxv2)).

  CollapsedVarPointsTo(hctx, heap, ctx, var) :-
    mainAnalysis.VarPointsTo(hctx, heap, ctx, var),
    ValidCtxVar(ctx, var).

}
