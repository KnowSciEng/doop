// A sound may-point-to analysis ("shall"-point-to?
// "True-may"-point-to?). Does not conclude anything if it is not
// certain it over-approximates all possible points-to targets. That
// is, an empty points-to set means "anything can be pointed to".
.type String

.decl InitialRootMethodForMayAnalysis(?meth:Method)
.decl EmptyHeapContext(?hctx:MayHeapContext)
.decl InitialMayContext(?ctx:MayContext)
.decl MaxMayContextDepth(?num:number)
.decl AccessPath_MaxLength(?maxLen:number)
.decl FirstInstructionOfMethod(?meth:Method, ?firstInsn:Instruction)

.comp IntraproceduralMust {
  // Just for baseline comparisons. Should be very cheap to compute.

  // to be provided by other components
  .decl MayReachableMethodUnderMayContext(?ctx:MayContext, ?inMeth:Method)

  // intermediate relations to compute
  .decl AllCtxIntraproceduralMustPointToInMethod(?hctx:MayHeapContext, ?heap:HeapAllocation,
                                         ?var:Var, ?method:Method)
  .decl IntraproceduralMustPointToUpToPhiInstruction(?hctx:MayHeapContext, ?heap:HeapAllocation,
                                                     ?ctx:MayContext, ?insn:Instruction)

  // output relations
  .decl IntraproceduralMustPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?var:Var)
  .decl IntraproceduralCertainMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocation)
  .decl AppAllCtxIntraproceduralMustPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var)
  .output IntraproceduralMustPointTo
  .output IntraproceduralCertainMethodBase
  .output AppAllCtxIntraproceduralMustPointTo

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignNormalHeapAllocation(?heap, ?var, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  // strings and others
  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
    !HeapAllocation_Merge(?heap, _),
    EmptyHeapContext(?hctx),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
    HeapAllocation_Merge(?heap, ?heap),
    EmptyHeapContext(?hctx),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).

  // null assignments

  //RecordMacroMay(?ctx, ?heap, ?hctx),
  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    isAssignNull_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    HeapAllocation_Null(?heap),
    Instruction_Method(?insn, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?to) :-
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignLocal_From(?insn, ?from),
    !PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?to) :-
    AssignCast_From(?insn, ?from),
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignInstruction_To(?insn, ?to).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?lastInsn),
    !NextInSamePhiNode(?lastInsn, _),
    AssignInstruction_To(?lastInsn, ?var).

  IntraproceduralCertainMethodBase(?hctx, ?heap, ?ctx, ?invo) :-
    (SpecialMethodInvocation_Base(?invo, ?base);
	 VirtualMethodInvocation_Base(?invo, ?base)),
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?base).

  AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method) :-
    InitialMayContext(?initCtx),
    IntraproceduralMustPointTo(?hctx, ?heap, ?initCtx, ?var),
    Var_DeclaringMethod(?var, ?method).

  IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?var) :-
    MayReachableMethodUnderMayContext(?ctx, ?method),
    AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method).

  IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?headInsn) :-
    PhiNodeHead(_, ?headInsn),
    AssignLocal_From(?headInsn, ?from),
    IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from).

  IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?nextInsn) :-
   IntraproceduralMustPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?insn),
   NextInSamePhiNode(?insn, ?nextInsn),
   AssignLocal_From(?nextInsn, ?from),
   IntraproceduralMustPointTo(?hctx, ?heap, ?ctx, ?from).

  // for final stats
  AppAllCtxIntraproceduralMustPointTo(?hctx, ?heap, ?var) :-
    AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method),
    Method_DeclaringType(?method, ?class), ApplicationClass(?class).
}

#include "must-point-to.dl"

.comp SoundMay<MustPointToParameter> {
  //// =====================================
  //// The main computed concepts:

  // May-point-to information in a specific context (which may be an
  // all-contexts value).

  // Whenever (if) it is reached under context ?ctx, variable ?var may point to an object
  // allocated at site ?heap. Since we assume SSA and variables are ensured initialized before use,
  // there is no point in keeping this information per-instruction.
  .decl MayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?var:Var)
  .output MayPointTo

  // Only for access paths that are not plain local vars. Distinguished
  // from above, since MayPointTo doesn't need ?insn (SSA form
  // assumed). Represents relationships that hold *after* the
  // instruction. There is also a Before_ version.
  .decl AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  .decl Before_AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  .output Before_AccessPathMayPointTo
  .output AccessPathMayPointTo

  #include "must-alias.dl"
  .init MustAliasAnalysis = DummyMustAlias

  .init MustPointToAnalysis = MustPointToParameter
  //// =====================================
  //// BEGIN final relations for stats

  .decl AppAllCtxMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var)
  .output AppAllCtxMayPointTo

  AppAllCtxMayPointTo(?hctx, ?heap, ?var) :-
    MayReachableMethodUnderMayContext(?ctx, ?meth),
	InitialMayContext(?ctx),
    Method_DeclaringType(?meth, ?class), ApplicationClass(?class),
    MayPointTo(?hctx, ?heap, ?ctx, ?var).

  //// END final stats

  //// =====================================
  //// BEGIN core MayPointTo code

  // Need to identify relevant (i.e., reachable) methods for the
  // analysis, instead of blindly applying it to all available code.
  .decl MayReachableMethodUnderMayContext(?ctx:MayContext, ?meth:Method)
  .decl MayReachableMayContext(?ctx:MayContext)
  .decl RootMethodForMayAnalysis(?meth:Method)
  .decl MayCallGraphEdge(?ctx:MayContext, ?meth:Method, ?callerCtx:MayContext, ?invo:MethodInvocation)
  .decl MethodMayAssignField(?fld:Field, ?ctx: MayContext, ?toMethod:Method)
  .decl MethodHasUnresolvedInvocation(?ctx: MayContext, ?toMethod:Method)
  .output RootMethodForMayAnalysis
  .output MayCallGraphEdge
  .output MethodMayAssignField
  .output MethodHasUnresolvedInvocation

  .decl MayCallGraphEdge_Prev(?ctx:MayContext, ?meth:Method, ?callerCtx:MayContext, ?invo:MethodInvocation)
  .decl MayReachableMethodUnderMayContext_Prev(?ctx:MayContext, ?meth:Method)
  .output MayCallGraphEdge_Prev
  .output MayReachableMethodUnderMayContext_Prev

  MayReachableMethodUnderMayContext(?ctx, ?meth) :-
    RootMethodForMayAnalysis(?meth),
	InitialMayContext(?ctx).

  MayReachableMethodUnderMayContext(?ctx, ?meth) :-
    MayCallGraphEdge(?ctx, ?meth, _, _).

  MayReachableMayContext(?ctx) :-
    MayReachableMethodUnderMayContext(?ctx, _).

  // Root of all inferences. Assigning new heap allocations.
  // REVIEW: This introduces dependency on string-constants.logic
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignNormalHeapAllocation(?heap, ?var, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  // strings and others
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
    (!HeapAllocation_Merge(?heap, _); HeapAllocation_Merge(?heap, ?heap)),
    EmptyHeapContext(?hctx),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).

  // null assignments
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    isAssignNull_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    HeapAllocation_Null(?heap),
    Instruction_Method(?insn, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    EmptyHeapContext(?hctx).

  // Move, but not Phi nodes, which are also represented as local assignments.
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignLocal_From(?insn, ?from),
    !PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to).

  // Place an order to the access path factory for the creation of
  // access paths resulting from the Move instruction. Also for Phi nodes.
  AccessPathShouldBeRebased(?ap, ?from, ?to) :-
    AccessPathMayPointTo(_, _, ?ap, _, ?insn),
    AssignLocal_From(?insn, ?from),
    AccessPath_BaseVar(?ap, ?from),
    AssignInstruction_To(?insn, ?to).
   .plan 1: (3,2,1,4)

  AccessPathMayPointTo(?hctx, ?heap, ?toAp, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?fromAp, ?ctx, ?insn),
    AssignLocal_From(?insn, ?from),
    !PhiNodeHead(?insn, _),
    AccessPath_BaseVar(?fromAp, ?from),
    AssignInstruction_To(?insn, ?to),
    RebaseCompositeAccessPath(?fromAp, ?from, ?to, ?toAp).
   .plan 1: (3,2,1,4,5), 2: (5,3,2,1,4)

  // casts are like local assignments
  //// TODO: filter our badly typed values
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    AssignCast_From(?insn, ?from),
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignInstruction_To(?insn, ?to).

  AccessPathShouldBeRebased(?ap, ?from, ?to) :-
    AccessPathMayPointTo(_, _, ?ap, _, ?insn),
    AssignCast_From(?insn, ?from),
    AccessPath_BaseVar(?ap, ?from),
    AssignInstruction_To(?insn, ?to).
   .plan 1: (3,2,1,4)

  AccessPathMayPointTo(?hctx, ?heap, ?toAp, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, ?fromAp, ?ctx, ?insn),
    AssignCast_From(?insn, ?from),
    AccessPath_BaseVar(?fromAp, ?from),
    AssignInstruction_To(?insn, ?to),
    RebaseCompositeAccessPath(?fromAp, ?from, ?to, ?toAp).
   .plan 1: (3,2,1,4,5), 2: (5,2,3,1,4)

  .decl PhiNodeVarWithResolvedMayPointTo(?ctx:MayContext, ?var:Var)

  // Phi
  PhiNodeVarWithResolvedMayPointTo(?ctx, ?var),
  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?lastInsn),
    !(NextInSamePhiNode(?lastInsn, _)),
    AssignInstruction_To(?lastInsn, ?var).

  // phi node treatment of composite access paths

  // This logic turns out to be surprisingly simple and general:
  // If the base var is set (i.e., all paths had points-to for the
  // SSA sub-variables) then take the union of all access-path info
  // for all paths based on sub-variables. If such info has reached
  // the phi node, it means it wasn't invalidated in any of the
  // other paths!
  AccessPathMayPointTo(?hctx, ?heap, ?toAp, ?ctx, ?insn) :-
    PhiNodeVarWithResolvedMayPointTo(?ctx, ?to),
    AssignInstruction_To(?insn, ?to),
    AssignLocal_From(?insn, ?from),
    PhiNodeHead(?insn, _),
    AccessPath_BaseVar(?fromAp, ?from),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?fromAp, ?ctx, ?insn),
    RebaseCompositeAccessPath(?fromAp, ?from, ?to, ?toAp).
   .plan 1: (5,3,4,7,6,1,2), 2: (6,1,5,3,2,7,4), 3: (7,3,5,6,1,2,4)

  // Load and Store instructions

  .decl StoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)
  .decl StaticStoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)
  StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    StoreInstanceField_From(?insn, ?from).

  StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    StoreStaticField_From(?insn, ?from).

  // store instructions, strong update of AccessPathMayPointTo info for
  // the same access path
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    StoreInstanceField_Base(?insn, ?base),
    FieldInstruction_Signature(?insn, ?fld),
	?ap = [?base, [?fld, nil]].

  // store instructions, strong update of AccessPathMayPointTo info for
  // an access path with a must-aliased base.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    StoreInstanceField_Base(?insn, ?base),
    (MustPointToAnalysis.VarMustAlias(?base, ?base2, ?ctx);
     MustAliasAnalysis.MustAlias([?base, nil], [?base2, nil], ?ctx, ?insn)),
    FieldInstruction_Signature(?insn, ?fld),
	?ap = [?base2, [?fld, nil]].

  // weak update of access paths with the same field but different base
  // TODO extend to longer access paths
  AccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
    StoreFromVarMayPointTo(?hctx2, ?heap2, ?ctx, ?insn),
    FieldInstruction_Signature(?insn, ?fld),
    SingleFieldAccessPath(?fld, ?ap),
	AccessPath_Length(?ap, ?len), ?len = 2.
   .plan 1: (2,1,3,4,5), 2: (4,5,3,2,1), 3: (5,4,3,2,1)

  // similar for static stores
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    FieldInstruction_Signature(?insn, ?fld),
    AccessPath_ContainsStaticField(?ap, ?fld),
	?ap = [ ?fld, nil ].

  // load instructions
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    LoadInstanceField_Base(?insn, ?base),
    LoadInstanceField_To(?insn, ?to),
    FieldInstruction_Signature(?insn, ?fld),
	?ap = [ ?base, [?fld, nil] ].

  // static load instructions
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    LoadStaticField_To(?insn, ?to),
    FieldInstruction_Signature(?insn, ?fld),
	?ap = [ ?fld, nil ].

  .decl StaticFinalFieldMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?fld:Field)
  .decl FinalFieldMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?fld:Field)

  // Final static fields that must point to an object, at the end of a
  // class initializer, cannot change in the future; thus, we can make
  // closed-world assumptions about the field.
  StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld) :-
    InitialMayContext(?initCtx),
    AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?meth),
	AccessPath_ContainsStaticField(?ap, ?fld),
	?ap = [ ?fld, nil ],
    Method_SimpleName(?meth, "<clinit>"),
    Field_Modifier(?mod, ?fld),
	Modifier_final(?mod).

  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld),
    FieldInstruction_Signature(?insn, ?fld),
    LoadStaticField_To(?insn, ?to),
    Var_DeclaringMethod(?to, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth).
   .plan 1: (5,4,3,2,1)

  FinalFieldMayPointTo(?hctx, ?heap, ?fld) :-
    AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?meth),
    InitialMayContext(?initCtx),
    ThisVar(?meth, ?var),
	?ap = [ ?var, [ ?fld, nil ] ],
    Method_SimpleName(?meth, "<init>"),
    Field_Modifier(?mod, ?fld),
	Modifier_final(?mod).

  // Almost same rule as above, but different optimization
  FinalFieldMayPointTo(?hctx, ?heap, ?fld) :-
    AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?meth),
    MustPointToAnalysis.VarMustAliasThis(?var, ?meth, ?initCtx),
    Method_SimpleName(?meth, "<init>"),
    InitialMayContext(?initCtx),
	?ap = [ ?var, [ ?fld, nil ] ],
    Field_Modifier(?mod, ?fld),
	Modifier_final(?mod).

  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    FinalFieldMayPointTo(?hctx, ?heap, ?fld),
    FieldInstruction_Signature(?insn, ?fld),
	Instruction_Method(?insn, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    LoadInstanceField_To(?insn, ?to).


  // static or special method invocation

  .decl StaticOrSpecialInvocationInMethod(?invo:MethodInvocation, ?inMeth:Method)
  StaticOrSpecialInvocationInMethod(?invo, ?inMeth) :-
	(isStaticMethodInvocation_Insn(?invo);
	 isSpecialMethodInvocation_Insn(?invo)),
	Instruction_Method(?invo, ?inMeth).

  //MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
  ComputedContext([?invo, ?ctx]),
  MayCallGraphEdge([?invo, ?ctx], ?toMeth, ?ctx, ?invo) :-
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    MayContextDepth(?ctx, ?ctxDepth),
    MaxMayContextDepth(?maxCtxDepth),
    ?ctxDepth < ?maxCtxDepth,
    StaticOrSpecialInvocationInMethod(?invo, ?inMeth),
    MethodInvocation_Method(?invo, ?toMeth).
   .plan 1: (2,1,3,4,5) // caused a crash!

  // special method invocation "this" variable assignment
  .decl OptPotentialSpecialMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocation)
  OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?base),
    SpecialMethodInvocation_Base(?invo, ?base).

  MayPointTo(?hctx, ?heap, ?calleeCtx, ?this) :-
    MayCallGraphEdge(?calleeCtx, ?toMeth, ?ctx, ?invo),
    OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo),
    ThisVar(?toMeth, ?this).

  .decl OptPotentialVirtualMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocation)
  OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?base),
    VirtualMethodInvocation_Base(?invo, ?base).

  // virtual method invocation
  //MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
  ComputedContext([?invo, ?ctx]),
  MayCallGraphEdge([?invo, ?ctx], ?toMeth, ?ctx, ?invo),
  MayPointTo(?hctx, ?heap, [?invo, ?ctx], ?this) :-
    OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo),
    HeapAllocation_Type(?heap, ?heaptype),
    VirtualMethodInvocation_SimpleName(?invo, ?simplename),
    VirtualMethodInvocation_Descriptor(?invo, ?descriptor),
    basic.MethodLookup(?simplename, ?descriptor, ?heaptype, ?toMeth),
    ThisVar(?toMeth, ?this),
    MaxMayContextDepth(?maxCtxDepth),
    MayContextDepth(?ctx, ?ctxDepth),
    ?ctxDepth < ?maxCtxDepth.
   .plan 1: (8,7,1,2,3,4,5,6)

  // args
  .decl InvocationActualFormalAssignment(?calleeCtx:MayContext, ?formal:Var, ?callerCtx:MayContext, ?actual:Var)
  InvocationActualFormalAssignment(?calleeCtx, ?formal, ?callerCtx, ?actual) :-
    MayCallGraphEdge(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    FormalParam(?index, ?toMethod, ?formal),
    ActualParam(?index, ?invo, ?actual).

  MayPointTo(?hctx, ?heap, ?calleeCtx, ?formal) :-
    MayPointTo(?hctx, ?heap, ?callerCtx, ?actual),
    InvocationActualFormalAssignment(?calleeCtx, ?formal, ?callerCtx, ?actual).

  // args and this for composite access paths.
  // First, place an order to the access path factory to create them, if
  // needed.
  AccessPathShouldBeRebased(?actualAp, ?actual, ?formal) :-
    Before_AccessPathMayPointTo(_, _, ?actualAp, ?callerCtx, ?invo),
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
    ?actualAp = [ ?actual, ?flds ], ?flds=?flds,
    ActualParam(?index, ?invo, ?actual),
    FormalParam(?index, ?toMethod, ?formal).
   .plan 1: (2,1,3,4)

  .decl OptVirtualOrSpecialMethodInvocation_Base(?invo:MethodInvocation, ?base:Var)
  OptVirtualOrSpecialMethodInvocation_Base(?invo, ?base) :-
    VirtualMethodInvocation_Base(?invo, ?base);
    SpecialMethodInvocation_Base(?invo, ?base).

  AccessPathShouldBeRebased(?baseAp, ?base, ?this) :-
    Before_AccessPathMayPointTo(_, _, ?baseAp, ?callerCtx, ?invo),
    OptVirtualOrSpecialMethodInvocation_Base(?invo, ?base),
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
    ThisVar(?toMethod, ?this),
	?baseAp = [ ?base, ?flds ], ?flds = ?flds.
   .plan 1: (3,2,1,4)

  .decl AccessPathRebasedForCall(?newAp:AccessPath, ?ap:AccessPath, ?callerCtx:MayContext, ?invo:MethodInvocation)
  AccessPathRebasedForCall(?newAp, ?ap, ?callerCtx, ?invo)  :-
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
    FormalParam(?index, ?toMethod, ?formal),
    ActualParam(?index, ?invo, ?actual),
    RebaseCompositeAccessPath(?ap, ?actual, ?formal, ?newAp).
   .plan 1: (4,3,1,2)

  AccessPathRebasedForCall(?newAp, ?ap, ?callerCtx, ?invo)  :-
    MayCallGraphEdge(_, ?toMethod, ?callerCtx, ?invo),
	OptVirtualOrSpecialMethodInvocation_Base(?invo, ?base),
    ThisVar(?toMethod, ?this),
    RebaseCompositeAccessPath(?ap, ?base, ?this, ?newAp).
   .plan 1: (4,3,1,2)

  Before_AccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?firstInsn) :-
    MayCallGraphEdge(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?callerAp, ?callerCtx, ?invo),
    AccessPathRebasedForCall(?calleeAp, ?callerAp, ?callerCtx, ?invo),
    FirstInstructionOfMethod(?toMethod, ?firstInsn).
   .plan 1: (2,1,3,4), 2: (3,1,2,4)

  // Let's not forget static fields and unchanged access paths
  Before_AccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?calleeCtx, ?firstInsn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?callerCtx, ?invo),
    MayCallGraphEdge(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AccessPath_ContainsStaticField(?staticAp, _),
    FirstInstructionOfMethod(?toMethod, ?firstInsn).
   .plan 1: (2,1,3,4), 2: (3,1,2,4)

  ///// POINT1--unchanged access paths code goes here

  // Handle constructors and initialization to null.
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  Before_AccessPathMayPointTo(?hctx, ?nullHeap, [?this, [?fld, nil]], ?ctx, ?firstInsn) :-
    MayReachableMethodUnderMayContext(?ctx, ?ctorMethod),
    ThisVarOfConstructor(?ctorMethod, ?this),
    FirstInstructionOfMethod(?ctorMethod, ?firstInsn),
    Method_DeclaringType(?ctorMethod, ?heapType),
	Modifier_static(?staticMod),
    Field_DeclaringType(?fld, ?heapType),
    !Field_Modifier(?staticMod, ?fld),
    Field_Type(?fld, ?fldType),
    isReferenceType(?fldType),
    HeapAllocation_Null(?nullHeap),
    EmptyHeapContext(?hctx).


  // handling returns

  /// Soundness warning: we can't just take the heap image of one called
  /// method and propagate it back to the caller: when the call-site has
  /// multiple targets, one of them could be computing Top (i.e., empty).
  /// Need to use previous run call-graph, due to "forall" over it.

  .decl ReturnValueOfResolvedCallAssignedTo(?callerCtx:MayContext, ?to:Var, ?calleeCtx:MayContext, ?toMethod:Method)
  ReturnValueOfResolvedCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AssignReturnValue(?invo, ?to).

  MayPointTo(?hctx, ?heap, ?callerCtx, ?to) :-
    AllCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?toMethod),
    ReturnValueOfResolvedCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod).

  // return access paths

  // First order that the rebased ones (and a few more) be created.
  // Note that we don't know which return statement will be used, so, in
  // order to do a correct access path rebasing, we conservatively limit our
  // attention to the case that all return statements use the same var.
  AccessPathShouldBeRebased(?ap, ?var, ?to) :-
    AllReturn_AccessPathMayPointTo(_, _, ?ap, ?calleeCtx, ?toMethod),
    ReturnValueOfResolvedCallAssignedTo(_, ?to, ?calleeCtx, ?toMethod),
    AllReturn_SameRetVar(?toMethod, ?var),
    AccessPath_BaseVar(?ap, ?var).

  AccessPathShouldBeRebased(?formalAp, ?formal, ?actual) :-
    AllReturn_AccessPathMayPointTo(_, _, ?formalAp, ?calleeCtx, ?toMethod),
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, _, ?invo),
    AccessPath_BaseVar(?formalAp, ?formal),
    ActualParam(?index, ?invo, ?actual),
    FormalParam(?index, ?toMethod, ?formal).
   .plan 1: (3,1,2,4,5)

  AccessPathShouldBeRebased(?thisAp, ?this, ?base) :-
    AllReturn_AccessPathMayPointTo(_, _, ?thisAp, ?calleeCtx, ?toMethod),
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, _, ?invo),
     (VirtualMethodInvocation_Base(?invo, ?base);
      SpecialMethodInvocation_Base(?invo, ?base)),
    ThisVar(?toMethod, ?this),
    AccessPath_BaseVar(?thisAp, ?this).
   .plan 1: (5,4,2,1,3)

  // Now collect the rebasing transformations
  .decl AccessPathRebasedForReturn(?callerAp:AccessPath, ?calleeAp:AccessPath, ?callerCtx:MayContext, ?invo:MethodInvocation)
  AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(_, ?toMethod, ?callerCtx, ?invo),
    AllReturn_SameRetVar(?toMethod, ?ret),
    AssignReturnValue(?invo, ?to),
    RebaseCompositeAccessPath(?calleeAp, ?ret, ?to, ?callerAp).

  AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(_, ?toMethod, ?callerCtx, ?invo),
    ActualParam(?index, ?invo, ?actual),
    FormalParam(?index, ?toMethod, ?formal),
    RebaseCompositeAccessPath(?calleeAp, ?formal, ?actual, ?callerAp).

  AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo) :-
    MayCallGraphEdge_Prev(_, ?toMethod, ?callerCtx, ?invo),
    ThisVar(?toMethod, ?this),
    (VirtualMethodInvocation_Base(?invo, ?base);
     SpecialMethodInvocation_Base(?invo, ?base)),
    RebaseCompositeAccessPath(?calleeAp, ?this, ?base, ?callerAp).

  AccessPathMayPointTo(?hctx, ?heap, ?callerAp, ?callerCtx, ?invo) :-
    AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?toMethod),
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AccessPathRebasedForReturn(?callerAp, ?calleeAp, ?callerCtx, ?invo).

  // Let's not forget static fields and unchanged access paths
  AccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?callerCtx, ?invo) :-
    AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?staticAp, ?calleeCtx, ?toMethod),
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AccessPath_ContainsStaticField(?staticAp, _).

  // This is quite expensive in principle, but is mostly restricted to the
  // access paths that we haven't decided are safe to ignore (propagated
  // by frame rule) based on the pre-analysis.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?callerCtx, ?invo) :-
    AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?ap, ?calleeCtx, ?toMethod),
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?callerCtx, ?invo),
    AccessPath_BaseVar(?ap, ?baseVar),
    !Var_DeclaringMethod(?baseVar, ?toMethod).

  // //// ====================================
  // //// Use must-alias information

  // Catch-all access path inference from MustAlias
  AccessPathMayPointTo(?hctx, ?heap, ?ap1, ?ctx, ?insn) :-
    MustAliasAnalysis.MustAlias(?ap1, ?ap2, ?ctx, ?insn),
    AccessPathMayPointTo(?hctx, ?heap, ?ap2, ?ctx, ?insn),
    (AccessPath_IsComposite(?ap1);
     AccessPath_ContainsStaticField(?ap1, _)).
   .plan 1: (2,1,3)

  .decl RepresentativeAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var, ?fld:Field, ?ctx:MayContext, ?insn:Instruction)

  RepresentativeAccessPathMayPointTo(?hctx, ?heap, ?varRepr, ?fld, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, [?var, [?fld, nil]], ?ctx, ?insn),
    MustPointToAnalysis.VarMustAliasRepresentative(?var, ?varRepr, ?ctx).

  ComputedAccessPath([?var, [?fld, nil]]),
  AccessPathMayPointTo(?hctx, ?heap, [?var, [?fld, nil]], ?ctx, ?insn) :-
    RepresentativeAccessPathMayPointTo(?hctx, ?heap, ?varRepr, ?fld, ?ctx, ?insn),
    MustPointToAnalysis.VarMustAliasRepresentative(?var, ?varRepr, ?ctx).

    //// Below is the best result of the insane optimization efforts I
    //// made before introducing representatives for VarMustAlias. Still way too
    //// slow.
    //   .decl OptAccessPathWithVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var, ?fld:Field, ?ctx:MayContext, ?insn:Instruction)

    //   OptAccessPathWithVarMayPointTo(?hctx, ?heap, ?var, ?fld, ?ctx, ?insn) :-
    //     AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    //     ?ap = [?var, [?fld, nil]].

    //   .decl Opt2AccessPathWithVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var, ?fld:Field, ?ctx:MayContext, ?insn:Instruction)

    //   Opt2AccessPathWithVarMayPointTo(?hctx, ?heap, ?base2, ?fld, ?ctx, ?insn) :-
    //     OptAccessPathWithVarMayPointTo(?hctx, ?heap, ?base1, ?fld, ?ctx, ?insn),
    //     MustPointToAnalysis.VarMustAlias(?base2, ?base1, ?ctx).
    // // No longer recursive
    // //   .plan 1: (2,1)

    //   AccessPathMayPointTo(?hctx, ?heap, [?base2, [?fld, nil]], ?ctx, ?insn) :-
    //     Opt2AccessPathWithVarMayPointTo(?hctx, ?heap, ?base2, ?fld, ?ctx, ?insn).

    //   .decl OptAccessPathWithVarExists(?fld:Field, ?base:Var, ?ctx:MayContext)
    //   OptAccessPathWithVarExists(?fld, ?base, ?ctx) :-
    //     OptAccessPathWithVarMayPointTo(_, _, ?base, ?fld, ?ctx, _).
    //   .decl ComputedVarFieldAP(?var:Var, ?fld:Field)
    //   .output ComputedVarFieldAP
    //
    //   ComputedVarFieldAP(?base2, ?fld) :-
    //     OptAccessPathWithVarExists(?fld, ?base1, ?ctx),
    //     MustPointToAnalysis.VarMustAlias(?base2, ?base1, ?ctx).
    // //   .plan 1: (2,1)

    //   ComputedAccessPath([?base, [?fld, nil]]) :-
    //     ComputedVarFieldAP(?base, ?fld).


  // //// ====================================
  // //// Weakening rules

  MayPointTo(?hctx, ?heap, ?ctx, ?var) :-
    MayPointTo(?hctx, ?heap, ?initCtx, ?var),
    InitialMayContext(?initCtx),
    Var_DeclaringMethod(?var, ?method),
    MayReachableMethodUnderMayContext(?ctx, ?method).
   .plan 1: (4,3,2,1)

  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?insn),
    InitialMayContext(?initCtx),
    Instruction_Method(?insn, ?method),
    MayReachableMethodUnderMayContext(?ctx, ?method).
   .plan 1: (4,3,2,1)

  Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?initCtx, ?insn),
    InitialMayContext(?initCtx),
    Instruction_Method(?insn, ?method),
    MayReachableMethodUnderMayContext(?ctx, ?method).
   .plan 1: (4,3,2,1)

  // //// END weakening rules
  // //// ====================================

  // //// ====================================
  // //// BEGIN frame rules, control-flow join rules

  Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?prev),
    PrevInSameBasicBlock(?insn, ?prev).

  //// Should be unnecessary.
  // Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
  //   AllPredecessors_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn).

  //// Establishing Before_AccessPathMayPointTo at beginning of basic block.
  .decl AccessPathMayPointToAtSomePredecessor(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  .output AccessPathMayPointToAtSomePredecessor

  AccessPathMayPointToAtSomePredecessor(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?tail),
    BasicBlockEnd(?tail),
    BasicBlockHead(?tail, ?pred),
    MaySuccessorBBModuloThrow(?insn, ?pred).

  // The linchpin: putting together all CFG predecessor info
  Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointToAtSomePredecessor(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AllRelevantPredecessors_HasAccessPathMayPointTo(?ap, ?ctx, ?insn).
   .plan 1: (2,1)

  //// Infer info after instruction from info before it
  // First, uniform treatment of easy case for any length non-collection AP
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    !AccessPath_IsCollection(?ap),
    !isMonitorInstruction(?insn),
    (!isMethodInvocation(?insn);
     IgnorableMethodInvocation(?insn);
     IgnorableForNonCollectionsMethodInvocation(?insn)),
    !StoreInstruction(?insn).

  // Now for store instructions. Also handles static field
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    SingleFieldAccessPath(?fld, ?ap),
    FieldInstruction_Signature(?insn, ?fldOther),
    ?fld != ?fldOther.
   .plan 1: (2,1,3)

  // also for length 3.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    DoubleFieldAccessPath(?fld1, ?fld2, ?ap),
    FieldInstruction_Signature(?insn, ?fld),
    ?fld != ?fld1,
    ?fld != ?fld2.

  // TODO extend to longer access paths, refactor to clean up

  // additions for static
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_ContainsStaticField(?ap, _),
	AccessPath_Length(?ap, 1),
    IgnorableForStaticsMethodInvocation(?insn).
   .plan 1: (2,3,1,4), 2: (3,2,1,4)

  .decl AccessPath_IsFinalStaticField(?ap:AccessPath)
  AccessPath_IsFinalStaticField(?ap) :-
    AccessPath_ContainsStaticField(?ap, ?fld),
	AccessPath_Length(?ap, 1),
    Field_Modifier(?mod, ?fld),
    Modifier_final(?mod).

  // REVIEW: final static fields (see below)
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    AccessPath_IsFinalStaticField(?ap),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn).
   .plan 1: (2,1)

  // *Collections*
  // Also propagating the information for collection access paths.
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    !isMonitorInstruction(?insn),
    (!isMethodInvocation(?insn);
     IgnorableMethodInvocation(?insn);
     LibraryCollectionLoadOperation(?insn)),
    !StoreArrayIndex_Base(?insn,_).

  // if it's a non-array operation on collections but the info concerns an array
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    LibraryCollectionStoreOperation(?insn),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    ?ap = [?base, ["dummyCollection", nil]],
    Var_Type(?base, ?type),
    isArrayType(?type).

  // and the converse. TODO: more fine-grained distinction of library collections?
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    StoreArrayIndex_Base(?insn,_),
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    ?ap = [?base, ["dummyCollection", nil]],
    Var_Type(?base, ?type),
    LibraryCollectionType(?type).

  /// Final fields

  ///// REVIEW: Logic below commented out until further review. The issue is
  ///// that it's not sound to check ...HasUnresolvedInvocation predicates
  ///// for methods that may have become reachable only in the current phase.
  ///// All unresolved invocation logic uses _Prev predicates and should be
  ///// joined with _Prev reachability for soundness. Need to think whether a
  ///// mere reachable_prev is enough here, but for now disabling non-crucial logic.
  // // The logic below is often subsumed by the handling of final fields
  // // at the end of the constructor. But it is not subsumed in cases the
  // // final value is dependent on the calling context.
  // AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
  //   Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
  //   SingleFieldAccessPath(?fld, ?ap),
  //   Field_Modifier(?mod, ?fld),
  //   Modifier_final(?mod),
  //   Instruction_Method(?insn, ?method),
  //   !MethodReachableFromConstructorOfClassOfField(?fld, ?method),
  //   !ConstructorOfClassOfFieldHasUnresolvedInvocation(?fld).
  //  .plan 1: (2,3,4,1,5)
  // // It's not enough to have the instruction not in the constructor,
  // // it needs to be after the end of the constructor.  Is this huge?
  // // Probably not, by nature of constructors and the sound callgraph.


  // TODO: also, for freshly allocated objects, it should be enough to have
  //       instance field points-to information for one path. The object doesn't
  //       exist in others. This needs escape reasoning? The object may come back
  //       to the same program point through the other path.

  // Now method calls. We use an overapproximation of the method's
  // effects, rather than passing all the access paths in.  Interesting
  // rules!

  .decl CalleeMayAssignField(?fld:Field, ?ctx:MayContext, ?insn:Instruction)
  CalleeMayAssignField(?fld, ?ctx, ?insn) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?ctx, ?insn),
    MethodMayAssignField(?fld, ?calleeCtx, ?toMethod).

  .decl CalleeHasUnresolvedInvocation(?ctx:MayContext, ?insn:Instruction)
  CalleeHasUnresolvedInvocation(?ctx, ?insn) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?toMethod, ?ctx, ?insn),
    MethodHasUnresolvedInvocation(?calleeCtx, ?toMethod).

  .decl Temp1(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  .output Temp1

  Temp1(?hctx, ?heap, ?ap, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    SingleFieldAccessPath(?fld, ?ap),
    MayCallGraphEdge_Prev(_, _, ?ctx, ?insn),
    !CalleeMayAssignField(?fld, ?ctx, ?insn),
    !CalleeHasUnresolvedInvocation(?ctx, ?insn).
   .plan 1: (2,1,3)

  .decl Temp2(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  .output Temp2

  Temp2(?hctx, ?heap, ?ap, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    DoubleFieldAccessPath(?fld1, ?fld2, ?ap),
    MayCallGraphEdge_Prev(_, _, ?ctx, ?insn),
    !CalleeMayAssignField(?fld1, ?ctx, ?insn),
    !CalleeMayAssignField(?fld2, ?ctx, ?insn),
    !CalleeHasUnresolvedInvocation(?ctx, ?insn).

  //// POINT4 insert here


  // //// END frame rules, control-flow join rules
  // //// ====================================

  // //// ====================================
  // //// BEGIN escape-like logic
  // //// for computing the highly useful concepts of "Method/Call Does
  // //// Not Invalidate Field", "method can reach other" (underapprox.),
  // //// etc.  REVIEW: Maybe base such logic on a type-based escape
  // //// analysis?

  // note that the "InitialMayContext" is an overapproximation. It's
  // stronger than what we typically need.
  .decl InvocationSiteFullyResolved(?ctx: MayContext, ?invo:Instruction)
  InvocationSiteFullyResolved(?ctx, ?invo) :-
    MayCallGraphEdge_Prev(_, _, ?ctx, ?invo).

  .decl MethodHasInvocationSite(?invo:Instruction, ?method:Method)
  MethodHasInvocationSite(?invo, ?method) :-
    isMethodInvocation(?invo),
    Instruction_Method(?invo, ?method).

  .decl MethodCanCallOther(?ctxFrom:MayContext, ?method:Method, ?ctxTo:MayContext, ?toMethod:Method)
  MethodCanCallOther(?ctxFrom, ?method, ?ctxTo, ?toMethod) :-
    MayCallGraphEdge_Prev(?ctxTo, ?toMethod, ?ctxFrom, ?invo),
    Instruction_Method(?invo, ?method).

  // transitive unresolved call
  MethodHasUnresolvedInvocation(?ctx, ?method) :-
    MayReachableMethodUnderMayContext_Prev(?ctx, ?method),
    MethodHasInvocationSite(?invo, ?method),
    !InvocationSiteFullyResolved(?ctx, ?invo),
    !IgnorableMethodInvocation(?invo).

  MethodHasUnresolvedInvocation(?ctx, ?method) :-
    MethodHasUnresolvedInvocation(?ctxTo, ?toMethod),
    MethodCanCallOther(?ctx, ?method, ?ctxTo, ?toMethod).

  // transitive may-assign-field based on sound-callgraph
  MethodMayAssignField(?fld, ?ctx, ?method) :-
    MayReachableMethodUnderMayContext_Prev(?ctx, ?method),
    Instruction_Method(?insn, ?method),
    FieldInstruction_Signature(?insn, ?fld).

  MethodMayAssignField(?fld, ?ctx, ?method) :-
    MethodMayAssignField(?fld, ?ctxTo, ?toMethod),
    MethodCanCallOther(?ctx, ?method, ?ctxTo, ?toMethod).

  // Now we can do a lazy check for definite ?fld, ?method pairs
  // to see whether a method is certain to *not* destroy a field
  // value by saying:
  // !MethodMayAssignField(?fld, ?ctx, ?method),
  // !MethodHasUnresolvedInvocation(?ctx, ?method).

  //// POINT5: DominatedPathMayInvalidateFieldPointsTo, enter here

  // Some auxiliary predicates on the above, used for constructor analysis
  .decl ConstructorOfClassOfField(?fld:Field, ?consMeth:Method)
  ConstructorOfClassOfField(?fld, ?consMeth) :-
    Method_SimpleName(?consMeth, "<init>"),
    Method_DeclaringType(?consMeth, ?cls),
    Field_DeclaringType(?fld, ?cls).

  // REVIEW: should this be a context-sensitive concept? I think not.
  .decl MethodReachableFromConstructorOfClassOfField(?fld:Field, ?consMeth:Method)
  MethodReachableFromConstructorOfClassOfField(?fld, ?meth) :-
    ConstructorOfClassOfField(?fld, ?meth).
  MethodReachableFromConstructorOfClassOfField(?fld, ?meth) :-
    MethodReachableFromConstructorOfClassOfField(?fld, ?otherMeth),
    MethodCanCallOther(_, ?otherMeth, _, ?meth).

  // REVIEW: should this be a context-sensitive concept? I think not.
  .decl ConstructorOfClassOfFieldHasUnresolvedInvocation(?fld:Field)
  ConstructorOfClassOfFieldHasUnresolvedInvocation(?fld) :-
    ConstructorOfClassOfField(?fld, ?consMeth),
    MethodHasUnresolvedInvocation(_, ?consMeth).

  // //// END escape-like logic
  // //// ====================================

  // //// ====================================
  // //// BEGIN configuration

  // The real root methods may be more than the initial ones, detected
  // dynamically, while the analysis proceeds. E.g., the initial ones are a
  // pre-analysis notion that can apply to the MustPointTo pre-analysis,
  // while the real root methods for the may-analysis include the class
  // initializers of reachable classes.
  RootMethodForMayAnalysis(?meth) :-
    InitialRootMethodForMayAnalysis(?meth).

  // Heuristic: if you can reach it in the analysis and it's a static
  // initializer, start a cons search (with zero context depth) from it.
  // There are lots of static final fields in the library that see heavy
  // use.
  RootMethodForMayAnalysis(?clinitMeth) :-
    MayReachableMethodUnderMayContext(_, ?meth),
    Method_DeclaringType(?meth, ?class),
    ClinitMethodOfClass(?clinitMeth, ?class).

  // For the legit, official main of a standard Java program, provide
  // dummy argument (String[] args).
  MayPointTo(?hctx, ?argsArray, ?ctx, ?args),
  ComputedAccessPath([?args, ["dummyCollection", nil]]),
  AccessPathMayPointTo(?hctx, ?argHeap, [?args, ["dummyCollection", nil]], ?ctx, ?firstInsn) :-
    MainClass(?mainClass),
    Method_DeclaringType(?mainMethod, ?mainClass),
    MayReachableMethodUnderMayContext(?ctx, ?mainMethod),
    Method_Descriptor(?mainMethod, "void(java.lang.String[])"),
    FormalParam(0, ?mainMethod, ?args),
    MainMethodArgArray(?argsArray),
    MainMethodArgArrayContent(?argHeap),
    EmptyHeapContext(?hctx),
    FirstInstructionOfMethod(?mainMethod, ?firstInsn).

  // RootMethodForMayAnalysis(?meth) :-
  //    MayReachableMethodUnderMayContext(_, ?meth).

  // RootMethodForMayAnalysis(?meth) :-
  //    AppMainMethod(?meth).

  // // Heuristic: if you can reach it in the analysis and it's an app
  // // method, start a new search (with zero context depth) from it.
  // RootMethodForMayAnalysis(?meth) :-
  //    MayReachableMethodUnderMayContext(_, ?meth),
  //    Method_DeclaringType(?meth, ?class),
  //    ApplicationClass(?class).

  // //// END configuration
  // //// ====================================

  // //// ====================================
  // //// AUXILIARY. Helper relations, "forall" emulations.

  // For all Phi node instructions, the "to" var (implicit in the
  // predicate) may point to...
  .decl MayPointToUpToPhiInstruction(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?lastInsn:Instruction)

  MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?headInsn) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    AssignLocal_From(?headInsn, ?from),
    PhiNodeHead(_, ?headInsn).

  MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?nextInsn),
  MayPointToUpToPhiInstruction(?hctx2, ?heap2, ?ctx, ?nextInsn) :-
    MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?insn),
    NextInSamePhiNode(?insn, ?nextInsn),
    AssignLocal_From(?nextInsn, ?from),
    MayPointTo(?hctx2, ?heap2, ?ctx, ?from).
   .plan 1:(4,3,2,1)

  // special case: propagate info unchanged if "from" var is same as "to"
  MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?nextInsn) :-
    MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?insn),
    NextInSamePhiNode(?insn, ?nextInsn),
    AssignLocal_From(?nextInsn, ?from),
    AssignInstruction_To(?nextInsn, ?from).

  // for all returns of a method, the return variable has a known upper bound
  // for its points-to, and we take the union of all such bounds
  .decl UpToReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?return:Instruction)
  UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?var),
    ReturnNonvoid_Var(?return, ?var),
    isReturnInstruction(?return),
    !ExistsPreviousReturn(?return).

  UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?return),
  UpToReturnMayPointTo(?hctx2, ?heap2, ?ctx, ?return) :-
    UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?prevReturn),
    NextReturn(?prevReturn, ?return),
    ReturnNonvoid_Var(?return, ?var),
    MayPointTo(?hctx2, ?heap2, ?ctx, ?var).

  .decl ExistsNextReturn(?ret:Instruction)
  ExistsNextReturn(?ret) :- NextReturn(?ret, _).
  .decl AllReturn_MayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?method:Method)
  AllReturn_MayPointTo(?hctx, ?heap, ?ctx, ?method) :-
    UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return),
    !ExistsNextReturn(?return),
    Instruction_Method(?return, ?method).

  // same for composite access paths
  .decl UpToReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?ret:Instruction)
  UpToReturnAccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?return) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?return),
    isReturnInstruction(?return),
    !ExistsPreviousReturn(?return).

  UpToReturnAccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?return),
  UpToReturnAccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?return) :-
    UpToReturnAccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?prevReturn),
    NextReturn(?prevReturn, ?return),
    Before_AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?return).
   .plan 1: (3,2,1)

  .decl AllReturn_AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?m:Method)
  AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?method) :-
    UpToReturnAccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?return),
    !ExistsNextReturn(?return),
    Instruction_Method(?return, ?method).

  // all returns of a method have the same return var
  .decl UpToReturnSameRetVar(?return:Instruction, ?var:Var)
  UpToReturnSameRetVar(?return, ?var) :-
    isReturnInstruction(?return),
    !ExistsPreviousReturn(?return),
    ReturnNonvoid_Var(?return, ?var).

  UpToReturnSameRetVar(?return, ?var) :-
    UpToReturnSameRetVar(?prevReturn, ?var),
    NextReturn(?prevReturn, ?return),
    ReturnNonvoid_Var(?return, ?var).

  .decl AllReturn_SameRetVar(?method:Method, ?var:Var)
  AllReturn_SameRetVar(?method, ?var) :-
    UpToReturnSameRetVar(?return, ?var),
    !ExistsNextReturn(?return),
    Instruction_Method(?return, ?method).

  // all returns of a callee is not enough. We also need "all callee" reasoning
  .decl CalleeFromSameCallsite(?calleeCtx:MayContext, ?meth1:Method, ?meth2:Method)
  CalleeFromSameCallsite(?calleeCtx, ?meth1, ?meth2) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?meth1, ?callerCtx, ?invo),
    MayCallGraphEdge_Prev(?calleeCtx, ?meth2, ?callerCtx, ?invo),
    ord(?meth1) < ord(?meth2).
   .plan 1: (2,1)

  .decl FirstCalleeFromCallsite(?calleeCtx:MayContext, ?meth:Method)
  FirstCalleeFromCallsite(?calleeCtx, ?meth) :-
    MayCallGraphEdge_Prev(?calleeCtx, ?meth, _, _),
    !CalleeFromSameCallsite(?calleeCtx, _, ?meth).

  .decl NotNextCalleeFromCallsite(?calleeCtx:MayContext, ?meth:Method, ?methNext:Method)
  NotNextCalleeFromCallsite(?calleeCtx, ?meth, ?methNext) :-
    CalleeFromSameCallsite(?calleeCtx, ?meth, ?methNext),
    CalleeFromSameCallsite(?calleeCtx, ?meth, ?methOther),
    ord(?methOther) < ord(?methNext).
   .plan 1: (2,1)

  .decl NextCalleeFromCallsite(?calleeCtx:MayContext, ?meth:Method, ?methNext:Method)
  NextCalleeFromCallsite(?calleeCtx, ?meth, ?methNext) :-
    CalleeFromSameCallsite(?calleeCtx, ?meth, ?methNext),
    !NotNextCalleeFromCallsite(?calleeCtx, ?meth, ?methNext).

  .decl UpToCallee_ReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeCtx:MayContext, ?meth:Method)
  UpToCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth) :-
    AllReturn_MayPointTo(?hctx, ?heap, ?calleeCtx, ?meth),
    MayCallGraphEdge_Prev(?calleeCtx, ?meth, _, _),
    FirstCalleeFromCallsite(?calleeCtx, ?meth).

  UpToCallee_ReturnMayPointTo(?hctx1, ?heap1, ?calleeCtx, ?meth),
  UpToCallee_ReturnMayPointTo(?hctx2, ?heap2, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnMayPointTo(?hctx1, ?heap1, ?calleeCtx, ?prevMeth),
    NextCalleeFromCallsite(?calleeCtx, ?prevMeth, ?meth),
    AllReturn_MayPointTo(?hctx2, ?heap2, ?calleeCtx, ?meth).

  .decl AllCallee_ReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeCtx:MayContext, ?meth:Method)
  AllCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnMayPointTo(?hctx, ?heap, ?calleeCtx, ?meth),
    !NextCalleeFromCallsite(?calleeCtx, ?meth, _).

  // same (all callee) reasoning for access paths
  .decl UpToCallee_ReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeAp:AccessPath, ?calleeCtx:MayContext, ?meth:Method)
  UpToCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth) :-
	AllReturn_AccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth),
    MayCallGraphEdge_Prev(?calleeCtx, ?meth, _, _),
	FirstCalleeFromCallsite(?calleeCtx, ?meth).

  UpToCallee_ReturnAccessPathMayPointTo(?hctx1, ?heap1, ?calleeAp, ?calleeCtx, ?meth),
  UpToCallee_ReturnAccessPathMayPointTo(?hctx2, ?heap2, ?calleeAp, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnAccessPathMayPointTo(?hctx1, ?heap1, ?calleeAp, ?calleeCtx, ?prevMeth),
    NextCalleeFromCallsite(?calleeCtx, ?prevMeth, ?meth),
    AllReturn_AccessPathMayPointTo(?hctx2, ?heap2, ?calleeAp, ?calleeCtx, ?meth).

  .decl AllCallee_ReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeAp:AccessPath, ?calleeCtx:MayContext, ?meth:Method)
  AllCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth) :-
    UpToCallee_ReturnAccessPathMayPointTo(?hctx, ?heap, ?calleeAp, ?calleeCtx, ?meth),
    !NextCalleeFromCallsite(?calleeCtx, ?meth, _).


  /// AccessPathMayPointTo for predecessors

  // The interesting concept is that of relevant predecessors for some
  // access path.  E.g., if a predecessor is not reachable from the
  // first instruction of the method via a path that can set the access
  // path, then it's not a relevant predecessor.

  // does the predecessor BB ?pred of ?insn have (at its end) point-to info for ?ap ?
  .decl OptHasAccessPathPointToAtPredecessor(?pred:Instruction, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  OptHasAccessPathPointToAtPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointTo(_, _, ?ap, ?ctx, ?tail),
    BasicBlockEnd(?tail),
    BasicBlockHead(?tail, ?pred),
    MaySuccessorBBModuloThrow(?insn, ?pred).

  .decl AccessPathRelevantToMethod(?ap:AccessPath, ?meth:Method)
  AccessPathRelevantToMethod(?ap, ?meth) :-
    (AccessPathMayPointTo(_, _, ?ap, _, ?insn);
     MustAliasAnalysis.MustAlias(_, ?ap, _, ?insn)),
    Instruction_Method(?insn, ?meth).

  .decl AccessPathUnaffectedByPredecessorBB(?ap:AccessPath, ?pred:Instruction)
  AccessPathUnaffectedByPredecessorBB(?ap, ?pred) :-
    AccessPathRelevantToMethod(?ap, ?meth),
    SingleFieldAccessPath(?fld, ?ap),
    Instruction_Method(?pred, ?meth),
    BasicBlockBegin(?pred),
	!SomePathFromFirstInstructionMayAffectField(?pred, ?fld),
	!SomePathFromFirstInstructionContainsUnresolvedCall(?pred).

  // TODO: currently only defined for single-field access paths and
  //       collection access paths.

  // does the first one have *some* access path points-to info, or is irrelevant?
  .decl HasAccessPathMayPointToUpToRelevantPredecessor(?pred:Instruction, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  .output HasAccessPathMayPointToUpToRelevantPredecessor

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
//// Remove? Seems completely unnecessary
//    AccessPathMayPointToAtSomePredecessor(_, _, ?ap, ?ctx, ?insn),
    OptHasAccessPathPointToAtPredecessor(?pred, ?ap, ?ctx, ?insn),
    MayPredecessorBBModuloThrow(?pred, ?insn),
    !ExistsPreviousPredecessorToSameBB(?pred, ?insn).

  .decl OptAccessPathUnaffectedByInsnPredecessorBB(?pred:Instruction, ?insn:Instruction, ?ap:AccessPath)
  .output OptAccessPathUnaffectedByInsnPredecessorBB

  OptAccessPathUnaffectedByInsnPredecessorBB(?pred, ?insn, ?ap) :-
    AccessPathUnaffectedByPredecessorBB(?ap, ?pred),
    MaySuccessorBBModuloThrow(?insn, ?pred).

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointToAtSomePredecessor(_, _, ?ap, ?ctx, ?insn),
    !ExistsPreviousPredecessorToSameBB(?pred, ?insn),
    OptAccessPathUnaffectedByInsnPredecessorBB(?pred, ?insn, ?ap).
    // the above can be weakened to eliminate collection method calls,
    // but below (for collections) we need to be careful. We should not
    // assume we know all operations, so we should be conservative with
    // method calls.

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    AccessPathMayPointToAtSomePredecessor(_, _, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    MayPredecessorBBModuloThrow(?pred, ?insn),
    !ExistsPreviousPredecessorToSameBB(?pred, ?insn),
    !SomePathFromFirstInstructionContainsCall(?pred).

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?prevPred, ?ap, ?ctx, ?insn),
    NextPredecessorToSameBB(?insn, ?prevPred, ?pred),
    OptHasAccessPathPointToAtPredecessor(?pred, ?ap, ?ctx, ?insn).
   .plan 1: (3,2,1)

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?prevPred, ?ap, ?ctx, ?insn),
    NextPredecessorToSameBB(?insn, ?prevPred, ?pred),
    AccessPathUnaffectedByPredecessorBB(?ap, ?pred).
   .plan 1: (3,2,1)

  HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?prevPred, ?ap, ?ctx, ?insn),
    AccessPath_IsCollection(?ap),
    NextPredecessorToSameBB(?insn, ?prevPred, ?pred),
    !SomePathFromFirstInstructionContainsCall(?pred).

  .decl ExistsNextPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)
    ExistsNextPredecessorToSameBB(?pred, ?insn) :-
    NextPredecessorToSameBB(?insn, ?pred, _).

  .decl AllRelevantPredecessors_HasAccessPathMayPointTo(?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  AllRelevantPredecessors_HasAccessPathMayPointTo(?ap, ?ctx, ?insn) :-
    HasAccessPathMayPointToUpToRelevantPredecessor(?pred, ?ap, ?ctx, ?insn),
	!ExistsNextPredecessorToSameBB(?pred, ?insn),
    !ExceptionHandlerFirstInstruction(?insn).

  /// ----------------------------------

  // //// END AUXILIARY. Helper relations, "forall" emulations.

  //// END core MayPointTo code
  //// ====================================

  //// ====================================
  //// BEGIN access path definitions, creation and other auxiliary

  // The next one needs to be explicitly marked at creation point!

  // Any access path relevant to the analysis should be marked. This
  // lazy creation is what makes access path concepts be
  // analysis-phase-specific, as opposed to having a single global
  // definition
  .decl ComputedAccessPath(?ap:AccessPath)
  .output ComputedAccessPath

  // These are computed uniformly:
  .decl AccessPath_IsSimple(?ap:AccessPath)
  .decl AccessPath_IsComposite(?ap:AccessPath)
  // Is access path a special one, based on a variable of collection type?
  // Incompatible with all other access path types. The access paths represents
  // all the *contents* of the collection (not the collection that the var
  // points-to, but all the objects that the collection points-to internally).
  .decl AccessPath_IsCollection(?ap:AccessPath)
  .decl AccessPath_ContainsField(?fld:Field, ?ap:AccessPath)
  .decl FieldListContains(?fld:Field, ?fldList:AccessPathSuffix)
  // Access path has static field as base
  .decl AccessPath_ContainsStaticField(?ap:AccessPath, ?fld:Field)
  .decl AccessPath_Length(?ap:AccessPath, ?len:number)
  .decl FieldList_Length(?fldList:AccessPathSuffix, ?len:number)
  // static or var.instance
  .decl SingleFieldAccessPath(?fld:Field, ?ap:AccessPath)
  .decl DoubleFieldAccessPath(?fld1:Field, ?fld2:Field, ?ap:AccessPath)
  .decl AccessPath_BaseVar(?ap:AccessPath, ?var:Var)
  .output AccessPath_BaseVar


  AccessPath_IsSimple(?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, nil ], ?base = ?base. // suppress warning

  AccessPath_IsComposite(?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, [ ?fld, ?rest] ],
    ?base = ?base, ?fld = ?fld, ?rest = ?rest.

  .decl ComputedFieldList(?fldList:AccessPathSuffix)
  .output ComputedFieldList

  ComputedFieldList(?fldList) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, ?fldList ], ?base = ?base. // suppress warning

  ComputedFieldList(?rest) :-
    ComputedFieldList(?fldList),
    ?fldList = [ ?fld, ?rest ], ?fld = ?fld.

  FieldListContains(?fld, ?fldList) :-
    ComputedFieldList(?fldList),
    ?fldList = [ ?fld, ?rest ], ?rest = ?rest. // suppress warning

  AccessPath_ContainsField(?fld, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, ?flds ], ?base = ?base, // suppress warning
    FieldListContains(?fld, ?flds).

  FieldList_Length(nil, 0).
  FieldList_Length(?fldList, ?len+1) :-
    ComputedFieldList(?fldList),
    ?fldList = [ ?fld, ?rest ], ?fld = ?fld, // suppress warning
    FieldList_Length(?rest, ?len).

  AccessPath_Length(?ap, ?len+1) :-
	ComputedAccessPath(?ap),
    ?ap = [ ?base, ?fldList ], ?base = ?base, // suppress warning
    FieldList_Length(?fldList, ?len).
  // .plan 1: (2,1)

  SingleFieldAccessPath(?fld, ?ap) :-
    AccessPath_ContainsStaticField(?ap, ?fld),
    AccessPath_Length(?ap, 1).

  SingleFieldAccessPath(?fld, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?base, [ ?fld, nil ] ], ?base = ?base, // suppress
    Var_Type(?base, _). // to be sure it's a var

  DoubleFieldAccessPath(?fld1, ?fld2, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?fld1, [ ?fld2, nil ] ],
    AccessPath_ContainsStaticField(?ap, ?fld1).

  DoubleFieldAccessPath(?fld1, ?fld2, ?ap) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?var, [ ?fld2, [ ?fld1, nil ] ] ], ?var = ?var, // suppress
    Var_Type(?var, _). // to be sure it's a var

  AccessPath_ContainsStaticField(?ap, ?fld) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?fld, ?fldList ], ?fldList = ?fldList, // suppress
    Field_DeclaringType(?fld, _). // to be sure it's a field

  AccessPath_BaseVar(?ap, ?var) :-
    ComputedAccessPath(?ap),
    ?ap = [ ?var, ?fldList ], ?fldList = ?fldList, // suppress
    Var_Type(?var, _). // to be sure it's a var

  //// REVIEW/TODO: current policy of access-path creation is roughly:
  ////  -create APs for all local vars, anywhere
  ////  -create APs for all var.fld load/store expressions in the program text
  ////  -create APs by rebasing APs that may point somewhere at calls/returns

  // The rules below create access paths from all variables
  // and all access fields in the program.
  ComputedAccessPath(?ap) :- InitialComputedAccessPath(?ap).

  // implies it's computed
  .decl AccessPathShouldBeRebased(?ap:AccessPath, ?from:Var, ?to:Var)
  .decl RebaseCompositeAccessPath(?ap:AccessPath, ?from:Var, ?to:Var, ?newAp:AccessPath)
  .output AccessPathShouldBeRebased
  .output RebaseCompositeAccessPath

  // If some access path is to be rebased, its non-var prefixes are as well.
  AccessPathShouldBeRebased(?newAp, ?from, ?to) :-
    AccessPathShouldBeRebased(?ap, ?from, ?to),
    ?ap = [ ?from, [ ?lastFld, [ ?nextFld, ?rest] ] ], ?lastFld = ?lastFld, // suppress warning
    ?newAp = [ ?from, [ ?nextFld, ?rest ] ].

  ComputedAccessPath(?newAp),
  RebaseCompositeAccessPath(?ap, ?from, ?to, ?newAp) :-
    AccessPathShouldBeRebased(?ap, ?from, ?to),
    ?newAp = [?to, ?rest],
    ?ap = [?from, ?rest].

  AccessPath_IsCollection(?ap) :-
    ?ap = [?base,  ["dummyCollection", nil]],
    Var_Type(?base, ?type),
    (isArrayType(?type);
     LibraryCollectionType(?type)).

  //// END access path definitions, auxiliary
  //// ====================================
  //// BEGIN context management

  // Again, component-specific only because of "computed" concept

  EmptyHeapContext("emptyHeapContext").
  InitialMayContext(nil).

  .decl MayContextDepth(?ctx:MayContext, ?depth:number)
  .decl ComputedContext(?ctx:MayContext)

  MayContextDepth(?ctx, 0) :-
    InitialMayContext(?ctx).
  ComputedContext(?ctx) :-
    InitialMayContext(?ctx).

  MayContextDepth([?invo,?poppedCtx], ?depth+1) :-
    ComputedContext(?ctx),
    ?ctx = [?invo,?poppedCtx],
    MayContextDepth(?poppedCtx, ?depth).

  //// END context management
  //// ====================================

  // //// ====================================
  // //// BEGIN special handling of collections.
  // ////  Not entirely self-contained. Some logic in frame rules as well.

  // collection loads and stores. For arrays and library collections.
  // initialize arrays and library collections to null at allocation
  //RecordMacroMay(?ctx, ?heap, ?hctx),
  AccessPathMayPointTo(?hctx, ?nullHeap, [?to, ["dummyCollection", nil]], ?ctx, ?insn) :-
    AssignHeapAllocation(?arrayHeap, ?to, ?inMeth),
    MayReachableMethodUnderMayContext(?ctx, ?inMeth),
    HeapAllocation_Type(?arrayHeap, ?type),
    (isArrayType(?type); LibraryCollectionType(?type)),
    AssignInstruction_To(?insn, ?to),
    HeapAllocation_Null(?nullHeap),
    EmptyHeapContext(?hctxArray),
    EmptyHeapContext(?hctx).

  .decl CollectionStoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)
  CollectionStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) :-
    MayPointTo(?hctx, ?heap, ?ctx, ?from),
    StoreCollection_From(?insn, ?from).

  .decl TentativeCollectionBaseApMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)
  TentativeCollectionBaseApMayPointTo(?hctx, ?heap, [?base, ["dummyCollection", nil]], ?ctx, ?insn) :-
    CollectionStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
    StoreCollection_Base(?insn, ?base).

  // store instructions, weak update of AccessPathMayPointTo info! Need
  // to know over-estimate to add more. Also propagate existing.
  AccessPathMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
  AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?insn) :-
    TentativeCollectionBaseApMayPointTo(?hctx1, ?heap1, ?ap, ?ctx, ?insn),
    Before_AccessPathMayPointTo(?hctx2, ?heap2, ?ap, ?ctx, ?insn).
   .plan 1:(2,1)

  // now loads
  .decl TempMayPointTo(?heap:HeapAllocation, ?ctx:MayContext, ?to:Var)
  .output TempMayPointTo

  TempMayPointTo(?heap, ?ctx, ?to),
  MayPointTo(?hctx, ?heap, ?ctx, ?to) :-
    Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?ctx, ?insn),
    LoadCollection_Base(?insn, ?base),
    AccessPath_IsCollection(?ap),
    ?ap = [?base, ["dummyCollection", nil]],
    LoadCollection_To(?insn, ?to).

  // //// END handling of collections
  // //// ====================================

  // //// ====================================
  // //// BEGIN Utilities for establishing relevant predecessors

  .decl BasicBlockMayAffectField(?fld:Field, ?headInsn:Instruction)
  .decl BasicBlockContainsUnresolvedCall(?headInsn:Instruction)
  .decl SomePathBetweenBasicBlocksMayAffectField(?prev:Instruction, ?next:Instruction, ?fld:Field)
  .decl SomePathBetweenBasicBlocksContainsUnresolvedCall(?prev:Instruction, ?next:Instruction)
  .decl SomePathFromFirstInstructionMayAffectField(?blockHead:Instruction, ?fld:Field)
  .decl SomePathFromFirstInstructionContainsUnresolvedCall(?blockHead:Instruction)

  // Before_AccessPathMayPointTo should be established not just when all
  // predecessor basic blocks have APMPT info, but also when some
  // predecessors have no way to have set it (and all others have
  // it). We speak of "Relevant" predecessors.
  BasicBlockMayAffectField(?fld, ?headInsn) :-
    MayReachableMethodUnderMayContext_Prev(_, ?method),
    Instruction_Method(?insn, ?method),
    BasicBlockHead(?insn, ?headInsn),
    FieldInstruction_Signature(?insn, ?fld).

  BasicBlockMayAffectField(?fld, ?headInsn) :-
    MayCallGraphEdge_Prev(?toCtx, ?toMethod, _, ?insn),
    BasicBlockHead(?insn, ?headInsn),
    MethodMayAssignField(?fld, ?toCtx, ?toMethod).

  BasicBlockContainsUnresolvedCall(?headInsn) :-
    MayReachableMethodUnderMayContext_Prev(_, ?method),
    Instruction_Method(?insn, ?method),
    isMethodInvocation(?insn),
    BasicBlockHead(?insn, ?headInsn),
    InitialMayContext(?initCtx),
    !IgnorableMethodInvocation(?insn),
    !MayCallGraphEdge_Prev(_, _, ?initCtx, ?insn).

  BasicBlockContainsUnresolvedCall(?headInsn) :-
    MayCallGraphEdge_Prev(?toCtx, ?toMethod, _, ?insn),
    BasicBlockHead(?insn, ?headInsn),
    !IgnorableMethodInvocation(?insn),
    MethodHasUnresolvedInvocation(?toCtx, ?toMethod).

  SomePathBetweenBasicBlocksMayAffectField(?prev, ?next, ?fld) :-
    BasicBlockMayAffectField(?fld, ?prev),
    MaySuccessorBBModuloThrow(?next, ?prev).

  SomePathBetweenBasicBlocksMayAffectField(?prev, ?next, ?fld) :-
    SomePathBetweenBasicBlocksMayAffectField(?prev, ?interm, ?fld),
    MaySuccessorBBModuloThrow(?next, ?interm).

  SomePathBetweenBasicBlocksContainsUnresolvedCall(?prev, ?next) :-
    BasicBlockContainsUnresolvedCall(?prev),
    MaySuccessorBBModuloThrow(?next, ?prev).

  SomePathBetweenBasicBlocksContainsUnresolvedCall(?prev, ?next) :-
    SomePathBetweenBasicBlocksContainsUnresolvedCall(?prev, ?interm),
    MaySuccessorBBModuloThrow(?next, ?interm).

  SomePathFromFirstInstructionMayAffectField(?blockHead, ?fld) :-
    BBHeadIsFirstInstruction(?firstInsn),
    SomePathBetweenBasicBlocksMayAffectField(?firstInsn, ?blockHead, ?fld).

  SomePathFromFirstInstructionContainsUnresolvedCall(?blockHead) :-
    BBHeadIsFirstInstruction(?firstInsn),
    SomePathBetweenBasicBlocksContainsUnresolvedCall(?firstInsn, ?blockHead).
  // //// END Utilities for establishing relevant predecessors
  // //// ====================================

}  // END .comp SoundMay


.decl LibraryCollectionRoot(?type:Type)
.decl LibraryCollectionType(?type:Type)
.output LibraryCollectionType

LibraryCollectionRoot(?type) :-
  ?type = "java.util.AbstractCollection";
  ?type = "java.util.AbstractMap".
LibraryCollectionType(?type) :-
  basic.SubtypeOf(?type, ?collRoot),
  LibraryCollectionRoot(?collRoot).

//// TODO: model iterators
.decl LibraryCollectionStoreOperation(?invo:MethodInvocation)
.decl LibraryCollectionLoadOperation(?invo:MethodInvocation)
LibraryCollectionStoreOperation(?invo) :-
  VirtualMethodInvocation_SimpleName(?invo, "add");
  VirtualMethodInvocation_SimpleName(?invo, "push");
  VirtualMethodInvocation_SimpleName(?invo, "set");
  VirtualMethodInvocation_SimpleName(?invo, "put").
LibraryCollectionLoadOperation(?invo) :-
  VirtualMethodInvocation_SimpleName(?invo, "peek");
  VirtualMethodInvocation_SimpleName(?invo, "pop");
  VirtualMethodInvocation_SimpleName(?invo, "elementAt");
  VirtualMethodInvocation_SimpleName(?invo, "firstElement");
  VirtualMethodInvocation_SimpleName(?invo, "lastElement");
  VirtualMethodInvocation_SimpleName(?invo, "remove");
  VirtualMethodInvocation_SimpleName(?invo, "get"). // TODO: better match in future

.decl StoreCollection_From(?insn:Instruction, ?from:Var)
StoreCollection_From(?insn, ?from) :-
  StoreArrayIndex_From(?insn, ?from).
StoreCollection_From(?invo, ?from) :-
  LibraryCollectionStoreOperation(?invo),
  (ActualParam(1, ?invo, ?from);
   ActualParam(2, ?invo, ?from)).

.decl StoreCollection_Base(?insn:Instruction, ?from:Var)
StoreCollection_Base(?insn, ?var) :-
  StoreArrayIndex_Base(?insn, ?var).
StoreCollection_Base(?invo, ?var) :-
  LibraryCollectionStoreOperation(?invo),
  VirtualMethodInvocation_Base(?invo, ?var).

// now loads
.decl LoadCollection_Base(?insn:Instruction, ?to:Var)
.decl LoadCollection_To(?insn:Instruction, ?to:Var)
LoadCollection_To(?insn, ?to) :-
  LoadArrayIndex_To(?insn, ?to).
LoadCollection_To(?invo, ?to) :-
  LibraryCollectionLoadOperation(?invo),
  AssignReturnValue(?invo, ?to).

LoadCollection_Base(?insn, ?var) :-
  LoadArrayIndex_Base(?insn, ?var).
LoadCollection_Base(?invo, ?var) :-
  LibraryCollectionLoadOperation(?invo),
  VirtualMethodInvocation_Base(?invo, ?var).


//// POINT2---IgnorableMethodInvocation to go here

//// ====================================
//// BEGIN configuration
////  Different ways to kick-start the analysis.

MaxMayContextDepth(5).

AccessPath_MaxLength(3).

.init SoundMayPhase1 = SoundMay<DummyMustPointTo>
.init SoundMayPhase2 = SoundMay<DummyMustPointTo>
SoundMayPhase2.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase1.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase2.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase1.MayReachableMethodUnderMayContext(?ctx, ?meth).

.init SoundMayPhase3 = SoundMay<DummyMustPointTo>
SoundMayPhase3.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase2.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase3.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase2.MayReachableMethodUnderMayContext(?ctx, ?meth).

/*
.init SoundMayPhase4 = SoundMay<DummyMustPointTo>
SoundMayPhase4.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase3.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase4.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase3.MayReachableMethodUnderMayContext(?ctx, ?meth).

.init SoundMayPhase5 = SoundMay<DummyMustPointTo>
SoundMayPhase5.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase4.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase5.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase4.MayReachableMethodUnderMayContext(?ctx, ?meth).

.init SoundMayPhase6 = SoundMay<DummyMustPointTo>
SoundMayPhase6.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase5.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase6.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase5.MayReachableMethodUnderMayContext(?ctx, ?meth).

.init SoundMayPhase7 = SoundMay<DummyMustPointTo>
SoundMayPhase7.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase6.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase7.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase6.MayReachableMethodUnderMayContext(?ctx, ?meth).

.init SoundMayPhase8 = SoundMay<DummyMustPointTo>
SoundMayPhase8.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase7.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase8.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase7.MayReachableMethodUnderMayContext(?ctx, ?meth).

.init SoundMayPhase9 = SoundMay<DummyMustPointTo>
SoundMayPhase9.MayCallGraphEdge_Prev(?ctx, ?meth, ?callerCtx, ?invo) :-
  SoundMayPhase8.MayCallGraphEdge(?ctx, ?meth, ?callerCtx, ?invo).
SoundMayPhase9.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth) :-
  SoundMayPhase8.MayReachableMethodUnderMayContext(?ctx, ?meth).
*/

.init IntraprocMustForStats = IntraproceduralMust
IntraprocMustForStats.MayReachableMethodUnderMayContext(?ctx, ?meth) :-
  SoundMayPhase1.MayReachableMethodUnderMayContext(?ctx, ?meth).

InitialRootMethodForMayAnalysis(?meth) :-
//  Reachable(?meth), // just for benchmarking against unsound VPT analysis
  Method_DeclaringType(?meth, ?class), ApplicationClass(?class).

//// END configuration


//// ====================================
//// BEGIN client: assumenosideeffects, assumenoexternalsideeffects

#define SoundMay SoundMayPhase3

.comp SideEffectsAnalysis {
  .decl VarHasNoSideEffects(?var:Var)
  .decl VarHasNoExternalSideEffects(?var:Var)
  .decl InvocationHasNoSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation)
  .decl InvocationHasNoExternalSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation)
  .decl MethodHasNoSideEffects(?callerCtx:MayContext, ?meth:Method)
  .decl MethodHasNoExternalSideEffects(?callerCtx:MayContext, ?meth:Method)

  // First the implicit set up: "no side effects" is stronger than "no external side effects"
  VarHasNoExternalSideEffects(?var) :- VarHasNoSideEffects(?var).
  // Same for methods. The rest should follow.
  MethodHasNoExternalSideEffects(?callerCtx, ?meth) :- MethodHasNoSideEffects(?callerCtx, ?meth).

  // Strong base cases
  VarHasNoSideEffects(?var) :-
    Var_Type(?var, ?type),
    !isReferenceType(?type),
    Var_DeclaringMethod(?var, ?meth),
    SoundMay.MayReachableMethodUnderMayContext(_, ?meth).

  VarHasNoSideEffects(?var) :-
    (AssignNormalHeapAllocation(_, ?var, ?meth);
     AssignContextInsensitiveHeapAllocation(_, ?var, ?meth)),
    SoundMay.MayReachableMethodUnderMayContext(_, ?meth).

  VarHasNoSideEffects(?var) :-
    isAssignNull_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    Instruction_Method(?insn, ?inMeth),
    SoundMay.MayReachableMethodUnderMayContext(_, ?inMeth).

  // This base case distinguishes a "no side effects" from a "no external side effects"
  VarHasNoExternalSideEffects(?var) :-
    (FormalParam(_, ?meth, ?var);
     ThisVar(?meth, ?var)),
    SoundMay.MayReachableMethodUnderMayContext(_, ?meth).

  // The rest of the rules go in matching pairs
  VarHasNoSideEffects(?to) :-
    VarHasNoSideEffects(?from),
    AssignLocal_From(?insn, ?from),
    !PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to).
  VarHasNoExternalSideEffects(?to) :-
    VarHasNoExternalSideEffects(?from),
    AssignLocal_From(?insn, ?from),
    !PhiNodeHead(?insn, _),
    AssignInstruction_To(?insn, ?to).

  VarHasNoSideEffects(?to) :-
    AssignCast_From(?insn, ?from),
    VarHasNoSideEffects(?from),
    AssignInstruction_To(?insn, ?to).
  VarHasNoExternalSideEffects(?to) :-
    AssignCast_From(?insn, ?from),
    VarHasNoExternalSideEffects(?from),
    AssignInstruction_To(?insn, ?to).

  VarHasNoSideEffects(?var) :-
    VarHasNoSideEffectsUpToPhiInstruction(?lastInsn),
    !NextInSamePhiNode(?lastInsn, _),
    AssignInstruction_To(?lastInsn, ?var).
  VarHasNoExternalSideEffects(?var) :-
    VarHasNoExternalSideEffectsUpToPhiInstruction(?lastInsn),
    !NextInSamePhiNode(?lastInsn, _),
    AssignInstruction_To(?lastInsn, ?var).

  .decl VarHasNoSideEffectsUpToPhiInstruction(?insn:Instruction)
  .decl VarHasNoExternalSideEffectsUpToPhiInstruction(?insn:Instruction)

  VarHasNoSideEffectsUpToPhiInstruction(?headInsn) :-
    PhiNodeHead(_, ?headInsn),
    AssignLocal_From(?headInsn, ?from),
    VarHasNoSideEffects(?from).
  VarHasNoExternalSideEffectsUpToPhiInstruction(?headInsn) :-
    PhiNodeHead(_, ?headInsn),
    AssignLocal_From(?headInsn, ?from),
    VarHasNoExternalSideEffects(?from).
  VarHasNoSideEffectsUpToPhiInstruction(?nextInsn) :-
    VarHasNoSideEffectsUpToPhiInstruction(?insn),
    NextInSamePhiNode(?insn, ?nextInsn),
    AssignLocal_From(?nextInsn, ?from),
    VarHasNoSideEffects(?from).
  VarHasNoExternalSideEffectsUpToPhiInstruction(?nextInsn) :-
    VarHasNoExternalSideEffectsUpToPhiInstruction(?insn),
    NextInSamePhiNode(?insn, ?nextInsn),
    AssignLocal_From(?nextInsn, ?from),
    VarHasNoExternalSideEffects(?from).

  VarHasNoSideEffects(?to) :-
    VarHasNoExternalSideEffects(?base),
    LoadInstanceField_Base(?insn, ?base),
    LoadInstanceField_To(?insn, ?to).
  VarHasNoSideEffects(?to) :-
    VarHasNoExternalSideEffects(?base),
    LoadInstanceField_Base(?insn, ?base),
    LoadInstanceField_To(?insn, ?to).

  // All straightforward up to here. Now the tough part. First stores...

  .decl UpToInstanceFieldStoreHasNoSideEffects(?meth:Method, ?storeInsn:Instruction)
  .decl UpToInstanceFieldStoreHasNoExternalSideEffects(?meth:Method, ?storeInsn:Instruction)

  UpToInstanceFieldStoreHasNoSideEffects(?meth, ?storeInsn) :-
    FirstInstanceStoreInMethod(?storeInsn, ?meth),
    StoreInstanceField_Base(?storeInsn, ?base),
    VarHasNoSideEffects(?base).
  UpToInstanceFieldStoreHasNoExternalSideEffects(?meth, ?storeInsn) :-
    FirstInstanceStoreInMethod(?storeInsn, ?meth),
    StoreInstanceField_Base(?storeInsn, ?base),
    VarHasNoExternalSideEffects(?base).
  UpToInstanceFieldStoreHasNoSideEffects(?meth, ?storeInsn) :-
    UpToInstanceFieldStoreHasNoSideEffects(?meth, ?prevStoreInsn),
    NextInstanceStoreInSameMethod(?prevStoreInsn, ?storeInsn, ?meth),
    StoreInstanceField_Base(?storeInsn, ?base),
    VarHasNoSideEffects(?base).
  UpToInstanceFieldStoreHasNoExternalSideEffects(?meth, ?storeInsn) :-
    UpToInstanceFieldStoreHasNoExternalSideEffects(?meth, ?prevStoreInsn),
    NextInstanceStoreInSameMethod(?prevStoreInsn, ?storeInsn, ?meth),
    StoreInstanceField_Base(?storeInsn, ?base),
    VarHasNoExternalSideEffects(?base).

  .decl AllInstanceFieldStoresHasNoSideEffects(?meth:Method)
  .decl AllInstanceFieldStoresHasNoExternalSideEffects(?meth:Method)
  AllInstanceFieldStoresHasNoSideEffects(?meth) :-
    SoundMay.MayReachableMethodUnderMayContext(_, ?meth),
    !FirstInstanceStoreInMethod(_, ?meth).
  AllInstanceFieldStoresHasNoExternalSideEffects(?meth) :-
    SoundMay.MayReachableMethodUnderMayContext(_, ?meth),
    !FirstInstanceStoreInMethod(_, ?meth).
  AllInstanceFieldStoresHasNoSideEffects(?meth) :-
    UpToInstanceFieldStoreHasNoSideEffects(?meth, ?lastStoreInsn),
    !NextInstanceStoreInSameMethod(?lastStoreInsn, _, ?meth).
  AllInstanceFieldStoresHasNoExternalSideEffects(?meth) :-
    UpToInstanceFieldStoreHasNoExternalSideEffects(?meth, ?lastStoreInsn),
    !NextInstanceStoreInSameMethod(?lastStoreInsn, _, ?meth).

  // ... then calls.

  // Up to a certain actual param, the method call is safe
  .decl UpToParamCalleeHasNoSideEffects(?index:number, ?callerCtx:MayContext,
                 ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)
  .decl UpToParamCalleeHasNoExternalSideEffects(?index:number, ?callerCtx:MayContext,
                 ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)
  UpToParamCalleeHasNoSideEffects(0, ?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    SoundMay.MayCallGraphEdge(?calleeCtx, ?toMeth, ?callerCtx, ?invo),
    ActualParam(0, ?invo, ?var),
    VarHasNoSideEffects(?var).
  UpToParamCalleeHasNoExternalSideEffects(0, ?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    SoundMay.MayCallGraphEdge(?calleeCtx, ?toMeth, ?callerCtx, ?invo),
    ActualParam(0, ?invo, ?var),
    VarHasNoExternalSideEffects(?var).
  UpToParamCalleeHasNoSideEffects(?index+1, ?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    UpToParamCalleeHasNoSideEffects(?index, ?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    ActualParam(?index+1, ?invo, ?var),
    VarHasNoSideEffects(?var).
  UpToParamCalleeHasNoExternalSideEffects(?index+1, ?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    UpToParamCalleeHasNoExternalSideEffects(?index, ?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    ActualParam(?index+1, ?invo, ?var),
    VarHasNoExternalSideEffects(?var).

  .decl AllParamsCalleeHasNoSideEffects(?callerCtx:MayContext,
                 ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)
  .decl AllParamsCalleeHasNoExternalSideEffects(?callerCtx:MayContext,
                 ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)
  AllParamsCalleeHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth),
  AllParamsCalleeHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    SoundMay.MayCallGraphEdge(?calleeCtx, ?toMeth, ?callerCtx, ?invo),
    !ActualParam(_, ?invo, _).
  AllParamsCalleeHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    UpToParamCalleeHasNoSideEffects(?index, ?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    !ActualParam(?index+1, ?invo, _).
  AllParamsCalleeHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    UpToParamCalleeHasNoExternalSideEffects(?index, ?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    !ActualParam(?index+1, ?invo, _).

  // ... and up to a callee, we are fine...
  // Here's the part that's getting interesting. The two analyses are now
  // intertwined and their logic needs to be separate.
  //  A) callee has no external side effects + we pass vars with no side effects ->
  //       invo has no side effects
  //  B) callee has no side effects -> invo has no side effects
  //  C) callee has no external side effects + we pass vars with no external side effects ->
  //       invo has no external side effects
  .decl UpToCallee_CallHasNoSideEffects(?callerCtx:MayContext,
                 ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)
  .decl UpToCallee_CallHasNoExternalSideEffects(?callerCtx:MayContext,
                 ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)

  // Establishing the strong version is enough for the weak
  UpToCallee_CallHasNoExternalSideEffects(?callerCtx, ?invocation, ?calleeCtx, ?toMeth) :-
    UpToCallee_CallHasNoSideEffects(?callerCtx, ?invocation, ?calleeCtx, ?toMeth).

  // Case (A)
  UpToCallee_CallHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    SoundMay.FirstCalleeFromCallsite(?calleeCtx, ?toMeth),
    AllParamsCalleeHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    MethodHasNoExternalSideEffects(?calleeCtx, ?toMeth).
  // Case (B)
  UpToCallee_CallHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    SoundMay.MayCallGraphEdge(?calleeCtx, ?toMeth, ?callerCtx, ?invo),
    SoundMay.FirstCalleeFromCallsite(?calleeCtx, ?toMeth),
    MethodHasNoSideEffects(?calleeCtx, ?toMeth).
  // Case (C)
  UpToCallee_CallHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    SoundMay.FirstCalleeFromCallsite(?calleeCtx, ?toMeth),
    AllParamsCalleeHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    MethodHasNoExternalSideEffects(?calleeCtx, ?toMeth).

  // Case (A)
  UpToCallee_CallHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    UpToCallee_CallHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?prevMeth),
    SoundMay.NextCalleeFromCallsite(?calleeCtx, ?prevMeth, ?toMeth),
    MethodHasNoExternalSideEffects(?calleeCtx, ?toMeth),
    AllParamsCalleeHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth).
  // Case (B)
  UpToCallee_CallHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    UpToCallee_CallHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?prevMeth),
    SoundMay.NextCalleeFromCallsite(?calleeCtx, ?prevMeth, ?toMeth),
    MethodHasNoSideEffects(?calleeCtx, ?toMeth).
  // Case (C)
  UpToCallee_CallHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth) :-
    UpToCallee_CallHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?prevMeth),
    SoundMay.NextCalleeFromCallsite(?calleeCtx, ?prevMeth, ?toMeth),
    MethodHasNoExternalSideEffects(?calleeCtx, ?toMeth),
    AllParamsCalleeHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth).

  // ... and back to matching pairs
  InvocationHasNoSideEffects(?callerCtx, ?invo) :-
    UpToCallee_CallHasNoSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    !SoundMay.NextCalleeFromCallsite(?calleeCtx, ?toMeth, _).
  InvocationHasNoExternalSideEffects(?callerCtx, ?invo) :-
    UpToCallee_CallHasNoExternalSideEffects(?callerCtx, ?invo, ?calleeCtx, ?toMeth),
    !SoundMay.NextCalleeFromCallsite(?calleeCtx, ?toMeth, _).

  .decl UpToInvocationMethodHasNoSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation, ?meth:Method)
  .decl UpToInvocationMethodHasNoExternalSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation, ?meth:Method)

  UpToInvocationMethodHasNoSideEffects(?callerCtx, ?invo, ?meth) :-
    FirstInvocationInMethod(?invo, ?meth),
    InvocationHasNoSideEffects(?callerCtx, ?invo).
  UpToInvocationMethodHasNoExternalSideEffects(?callerCtx, ?invo, ?meth) :-
    FirstInvocationInMethod(?invo, ?meth),
    InvocationHasNoExternalSideEffects(?callerCtx, ?invo).

  UpToInvocationMethodHasNoSideEffects(?callerCtx, ?invo, ?meth) :-
    UpToInvocationMethodHasNoSideEffects(?callerCtx, ?prevInvo, ?meth),
    NextInvocationInSameMethod(?prevInvo, ?invo, ?meth),
    InvocationHasNoSideEffects(?callerCtx, ?invo).
  UpToInvocationMethodHasNoExternalSideEffects(?callerCtx, ?invo, ?meth) :-
    UpToInvocationMethodHasNoExternalSideEffects(?callerCtx, ?prevInvo, ?meth),
    NextInvocationInSameMethod(?prevInvo, ?invo, ?meth),
    InvocationHasNoExternalSideEffects(?callerCtx, ?invo).

  .decl AllInvocationsMethodHasNoSideEffects(?ctx:MayContext, ?meth:Method)
  .decl AllInvocationsMethodHasNoExternalSideEffects(?ctx:MayContext, ?meth:Method)
  AllInvocationsMethodHasNoExternalSideEffects(?ctx, ?meth),
  AllInvocationsMethodHasNoSideEffects(?ctx, ?meth) :-
    SoundMay.MayReachableMethodUnderMayContext(?ctx, ?meth),
    !MethodInvocation_Method(_, ?meth).

  AllInvocationsMethodHasNoSideEffects(?ctx, ?meth) :-
    UpToInvocationMethodHasNoSideEffects(?ctx, ?invo, ?meth),
    !NextInvocationInSameMethod(?invo, _, ?meth).
  AllInvocationsMethodHasNoExternalSideEffects(?ctx, ?meth) :-
    UpToInvocationMethodHasNoExternalSideEffects(?ctx, ?invo, ?meth),
    !NextInvocationInSameMethod(?invo, _, ?meth).

  // Wow! Strange soundness warning: MethodHasUnresolvedInvocation applies to the *previous*
  // call graph edge.
  MethodHasNoSideEffects(?ctx, ?meth) :-
    SoundMay.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth),
    AllInvocationsMethodHasNoSideEffects(?ctx, ?meth),
    !SoundMay.MethodHasUnresolvedInvocation(?ctx, ?meth),
    AllInstanceFieldStoresHasNoSideEffects(?meth),
    !Method_SimpleName(?meth, "<init>"),
       // Constructors disallowed because Proguard removes them and verification fails!
    !_MethodHasSideEffectInstruction(?meth),
    !_MethodIsNative(?meth).
  MethodHasNoExternalSideEffects(?ctx, ?meth) :-
    SoundMay.MayReachableMethodUnderMayContext_Prev(?ctx, ?meth),
    AllInvocationsMethodHasNoExternalSideEffects(?ctx, ?meth),
    !SoundMay.MethodHasUnresolvedInvocation(?ctx, ?meth),
    AllInstanceFieldStoresHasNoExternalSideEffects(?meth),
    !Method_SimpleName(?meth, "<init>"),
       // Constructors disallowed because Proguard removes them and verification fails!
    !_MethodHasSideEffectInstruction(?meth),
    !_MethodIsNative(?meth).

  // Debugging
  .output VarHasNoSideEffects
  .output InvocationHasNoSideEffects
  .output MethodHasNoSideEffects
  .output VarHasNoSideEffectsUpToPhiInstruction
  .output UpToInstanceFieldStoreHasNoSideEffects
  .output AllInstanceFieldStoresHasNoSideEffects
  .output UpToParamCalleeHasNoSideEffects
  .output AllParamsCalleeHasNoSideEffects
  .output UpToCallee_CallHasNoSideEffects
  .output AllInvocationsMethodHasNoSideEffects
  .output UpToInvocationMethodHasNoSideEffects

  .output VarHasNoExternalSideEffects
  .output InvocationHasNoExternalSideEffects
  .output MethodHasNoExternalSideEffects
  .output VarHasNoExternalSideEffectsUpToPhiInstruction
  .output UpToInstanceFieldStoreHasNoExternalSideEffects
  .output AllInstanceFieldStoresHasNoExternalSideEffects
  .output UpToParamCalleeHasNoExternalSideEffects
  .output AllParamsCalleeHasNoExternalSideEffects
  .output UpToCallee_CallHasNoExternalSideEffects
  .output AllInvocationsMethodHasNoExternalSideEffects
  .output UpToInvocationMethodHasNoExternalSideEffects


  // Preparing final output

  .decl MethodHasOverridingMethodWithSideEffects(?methodSuper:Method)
  .decl MethodHasOverridingMethodWithExternalSideEffects(?methodSuper:Method)
  MethodHasOverridingMethodWithSideEffects(?methodSuper) :-
    basic.MethodOverridesOther(?methodSub, ?methodSuper),
    SideEffects.MethodHasNoSideEffects(?initCtx, ?methodSuper),
    !SideEffects.MethodHasNoSideEffects(?initCtx, ?methodSub).
  MethodHasOverridingMethodWithExternalSideEffects(?methodSuper) :-
    basic.MethodOverridesOther(?methodSub, ?methodSuper),
    SideEffects.MethodHasNoExternalSideEffects(?initCtx, ?methodSuper),
    !SideEffects.MethodHasNoExternalSideEffects(?initCtx, ?methodSub).

  .decl Output_MethodHasNoSideEffects(?meth:Method)
  .decl Output_MethodHasNoExternalSideEffects(?meth:Method)

  Output_MethodHasNoSideEffects(cat("-assumenosideeffects class ", cat(?type, cat(" { ", cat(?retType, cat(" ", cat(?simpleName, cat(substr(?descriptor, strlen(?retType), strlen(?descriptor)), "; }")))))))) :-
    MethodHasNoSideEffects(?initCtx, ?m),
    !MethodHasOverridingMethodWithSideEffects(?m),
    InitialMayContext(?initCtx),
    basic.MethodLookup(?simpleName, _, _, ?m),
    Method_DeclaringType(?m, ?type),
    Method_Descriptor(?m, ?descriptor),
    Method_SimpleName(?m, ?simpleName),
    Method_ReturnType(?m, ?retType).

  Output_MethodHasNoExternalSideEffects(cat("-assumenoexternalsideeffects class ", cat(?type, cat(" { ", cat(?retType, cat(" ", cat(?simpleName, cat(substr(?descriptor, strlen(?retType), strlen(?descriptor)), "; }")))))))) :-
    MethodHasNoExternalSideEffects(?initCtx, ?m),
    !MethodHasOverridingMethodWithExternalSideEffects(?m),
    InitialMayContext(?initCtx),
    basic.MethodLookup(?simpleName, _, _, ?m),
    Method_DeclaringType(?m, ?type),
    Method_Descriptor(?m, ?descriptor),
    Method_SimpleName(?m, ?simpleName),
    Method_ReturnType(?m, ?retType).

  .output Output_MethodHasNoSideEffects
  .output Output_MethodHasNoExternalSideEffects

}

.init SideEffects = SideEffectsAnalysis


//// Utilities
.decl _MethodHasSideEffectInstruction(?meth:Method)
_MethodHasSideEffectInstruction(?meth) :-
  (isMonitorInstruction(?insn);
   isUnsupportedInstruction(?insn);
   isAssignPhantomInvoke(?insn);
   isStoreArrayIndex_Insn(?insn);  // REVIEW: too conservative, can instead check if safe
   StoreStaticField_From(?insn, _)),
  Instruction_Method(?insn, ?meth).

.decl _MethodIsNative(?meth:Method)
_MethodIsNative(?meth) :-
  Method_Modifier("native", ?meth).

.decl _StoreInstanceFieldInMethod(?storeInsn:Instruction, ?meth:Method)
_StoreInstanceFieldInMethod(?storeInsn, ?meth) :-
  StoreInstanceField_Base(?storeInsn, _),
  Instruction_Method(?storeInsn, ?meth).

.decl InstanceStoreInSameMethod(?storeInsn1:Instruction, ?storeInsn2:Instruction, ?meth:Method)
InstanceStoreInSameMethod(?storeInsn1, ?storeInsn2, ?meth) :-
  _StoreInstanceFieldInMethod(?storeInsn1, ?meth),
  _StoreInstanceFieldInMethod(?storeInsn2, ?meth),
  ord(?storeInsn1) < ord(?storeInsn2).

.decl FirstInstanceStoreInMethod(?storeInsn:Instruction, ?meth:Method)
FirstInstanceStoreInMethod(?storeInsn, ?meth) :-
  _StoreInstanceFieldInMethod(?storeInsn, ?meth),
  !InstanceStoreInSameMethod(_, ?storeInsn, ?meth).

.decl NotNextInstanceStoreInSameMethod(?storeInsn1:Instruction, ?storeInsn2:Instruction, ?meth:Method)
NotNextInstanceStoreInSameMethod(?storeInsn1, ?storeInsn2, ?meth) :-
  InstanceStoreInSameMethod(?storeInsn1, ?storeInsn2, ?meth),
  InstanceStoreInSameMethod(?storeInsn1, ?storeInsnOther, ?meth),
  ord(?storeInsnOther) < ord(?storeInsn2).

.decl NextInstanceStoreInSameMethod(?storeInsn1:Instruction, ?storeInsn2:Instruction, ?meth:Method)
NextInstanceStoreInSameMethod(?storeInsn1, ?storeInsn2, ?meth) :-
  InstanceStoreInSameMethod(?storeInsn1, ?storeInsn2, ?meth),
  !NotNextInstanceStoreInSameMethod(?storeInsn1, ?storeInsn2, ?meth).

.decl _InvocationsPerMethod(?meth:Method, ?n:number)
_InvocationsPerMethod(?meth, ?n) :-
  MethodInvocation_Method(_, ?meth),
  ?n = count:{MethodInvocation_Method(_, ?meth)}.

.decl _ReasonableMethod(?meth:Method)
_ReasonableMethod(?meth) :-
  _InvocationsPerMethod(?meth, ?n),
  ?n < 6.

.decl InvocationInSameMethod(?invo1:Instruction, ?invo2:Instruction, ?meth:Method)
InvocationInSameMethod(?invo1, ?invo2, ?meth) :-
  _ReasonableMethod(?meth),
  MethodInvocation_Method(?invo1, ?meth),
  MethodInvocation_Method(?invo2, ?meth),
  ord(?invo1) < ord(?invo2).

.decl FirstInvocationInMethod(?invo:Instruction, ?meth:Method)
FirstInvocationInMethod(?invo, ?meth) :-
  _ReasonableMethod(?meth),
  MethodInvocation_Method(?invo, ?meth),
  !InvocationInSameMethod(_, ?invo, ?meth).

.decl NotNextInvocationInSameMethod(?invo1:Instruction, ?invo2:Instruction, ?meth:Method)
NotNextInvocationInSameMethod(?invo1, ?invo2, ?meth) :-
  _ReasonableMethod(?meth),
  InvocationInSameMethod(?invo1, ?invo2, ?meth),
  InvocationInSameMethod(?invo1, ?invoOther, ?meth),
  ord(?invoOther) < ord(?invo2).

.decl NextInvocationInSameMethod(?invo1:Instruction, ?invo2:Instruction, ?meth:Method)
NextInvocationInSameMethod(?invo1, ?invo2, ?meth) :-
  _ReasonableMethod(?meth),
  InvocationInSameMethod(?invo1, ?invo2, ?meth),
  !NotNextInvocationInSameMethod(?invo1, ?invo2, ?meth).

// Debugging
.output _ReasonableMethod
.output _InvocationsPerMethod
.output _MethodIsNative
.output _MethodHasSideEffectInstruction
.output _StoreInstanceFieldInMethod
.output InstanceStoreInSameMethod
.output FirstInstanceStoreInMethod
.output NotNextInstanceStoreInSameMethod
.output NextInstanceStoreInSameMethod
.output InvocationInSameMethod
.output FirstInvocationInMethod
.output NotNextInvocationInSameMethod
.output NextInvocationInSameMethod

//// END client: *sideeffects


//// ====================================
//// BEGIN type definitions

.type MayContext = [ ?invo:MethodInvocation, ?rest:MayContext ]
.type MayHeapContext

.type AccessPathBase = Var | Field   // the latter for static fields
.type AccessPathSuffix = [ ?fld:Field, ?rest:AccessPathSuffix ]
.type AccessPath = [ ?base:AccessPathBase, ?flds:AccessPathSuffix ]
// This is the main entity that represents Access Paths.
// Access Paths are expressions of the form: v(.fi)* or fi.(.fi)*, for static first field
// In our Field list, the last field is first. I.e., [ var, [fld1, [fld2, [fld3, nil]]]] is
// the access path var.fld3.fld2.fld1

/*
.type AccessPathBase = Var | Field   // the latter for static fields
.type AccessPathSuffix = [ ?base:AccessPathSuffix, ?fld:Field ]
// This is the main entity that represents Access Paths.
// Access Paths are expressions of the form: v(.fi)* or fi.(.fi)*, for static first field
.type AccessPath = [ ?base:AccessPathBase, ?flds:AccessPathSuffix ]
*/

//// END type definitions
//// ====================================


//// ====================================
//// BEGIN utilities

.decl AppMainMethod(?mainMeth:Method)
.decl ClinitMethodOfClass(?meth:Method, ?class:Type)

// Try to discover hidden "main" heuristically
AppMainMethod(?mainMeth) :-
  Method_SimpleName(?mainMeth, "main"),
  Method_DeclaringType(?mainMeth, ?class),
  ApplicationClass(?class).

// Heuristic: if you can reach it in the analysis and it's a static
// initializer, start a new search (with zero context depth) from it.
// There are lots of static final fields in the library that see heavy
// use.
ClinitMethodOfClass(?meth, ?class) :-
  Method_SimpleName(?meth, "<clinit>"),
  Method_DeclaringType(?meth, ?class).


FirstInstructionOfMethod(?meth, ?firstInsn) :-
  Instruction_Index(?firstInsn, 1),
  !IsJumpTarget(?firstInsn),
  Instruction_Method(?firstInsn, ?meth).

.decl IgnorableMethodInvocation(?invo:MethodInvocation)
.decl IgnorableForNonCollectionsMethodInvocation(?invo:MethodInvocation)
.decl IgnorableForStaticsMethodInvocation(?invo:MethodInvocation)

.decl StoreInstruction(?insn:Instruction)
StoreInstruction(?insn) :-
  StoreStaticField_From(?insn, _);
  StoreInstanceField_From(?insn, _).

.decl ThisVarOfConstructor(?method:Method, ?this:Var)
ThisVarOfConstructor(?method, ?this) :-
   Method_SimpleName(?method, "<init>"),
   ThisVar(?method, ?this).

.decl BBHeadIsFirstInstruction(?firstInsn:Instruction)
BBHeadIsFirstInstruction(?firstInsn) :-
  BasicBlockBegin(?firstInsn),
  FirstInstructionOfMethod(_, ?firstInsn).

// Just a dumb overapproximation: is there any call site at all,
// resolved or otherwise? Used only for collections.
.decl BasicBlockContainsCall(?headInsn:Instruction)
.decl SomePathBetweenBasicBlocksContainsCall(?prev:Instruction, ?next:Instruction)
.decl SomePathFromFirstInstructionContainsCall(?blockHead:Instruction)

BasicBlockContainsCall(?headInsn) :-
  BasicBlockHead(?insn, ?headInsn),
  isMethodInvocation(?insn),
  !IgnorableMethodInvocation(?insn).

SomePathBetweenBasicBlocksContainsCall(?prev, ?next) :-
  BasicBlockContainsCall(?prev),
  MaySuccessorBBModuloThrow(?next, ?prev).

SomePathFromFirstInstructionContainsCall(?blockHead) :-
  BBHeadIsFirstInstruction(?firstInsn),
  SomePathBetweenBasicBlocksContainsCall(?firstInsn, ?blockHead).

// Initial computed access paths. Faster than doing the same thing all over?
.decl InitialComputedAccessPath(?ap:AccessPath)

// The rules below create access paths from all variables
// and all access fields in the program.
InitialComputedAccessPath([?var, nil]) :-
  Var_Type(?var, ?type),
  isReferenceType(?type).

// Invariant: all computed access paths are type safe: the fields
// exist in the static type of the prefix. REVIEW: This may (rarely)
// prevent detection of valid aliasing.
InitialComputedAccessPath([?base, [ ?fld, nil ] ]) :-
  LoadInstanceField_Base(?insn, ?base),
  FieldInstruction_Signature(?insn, ?fld),
  Field_Type(?fld, ?type),
  isReferenceType(?type).
InitialComputedAccessPath([?base, [ ?fld, nil ] ]) :-
  StoreInstanceField_Base(?insn, ?base),
  FieldInstruction_Signature(?insn, ?fld),
  Field_Type(?fld, ?type),
  isReferenceType(?type).

InitialComputedAccessPath([?fld, nil ]) :-
  LoadStaticField_To(?insn, _),
  FieldInstruction_Signature(?insn, ?fld),
  Field_Type(?fld, ?type),
  isReferenceType(?type).
InitialComputedAccessPath([?fld, nil ]) :-
  StoreStaticField_From(?insn, _),
  FieldInstruction_Signature(?insn, ?fld),
  Field_Type(?fld, ?type),
  isReferenceType(?type).

//// END utilities



/*
// Friendly API for access path display
AccessPath_ToString(?ap, ?str) ->
   AccessPath(?ap), string(?str).

// loses lots of information, which may be confusing during debugging.
AccessPath_ToString(?ap, ?str) :-
   AccessPath_ByVarInv(?ap, ?v),
   _NameFromRefMode(?v, ?str).
//   Var_Value(?v,?vs),
//   OptVar_DeclaringMethod(?m,?v),
//   Method_Value(?m_?ms),
//   ?str = ?vs + ?ms.

AccessPath_ToString(?ap, ?str) :-
   AccessPath_ByStaticFieldInv(?ap, ?f),
   _NameFromRefMode(?f, ?str).

AccessPath_ToString(?ap, ?str2) :-
   AccessPath_ByCollectionVarInv(?ap, ?v),
   _NameFromRefMode(?v, ?str),
   ?str2 = "collection on " + ?str.

AccessPath_ToString(?ap, ?str) :-
   AccessPath_Base(?ap, ?base),
   AccessPath_LastField(?ap, ?fld),
   AccessPath_ToString(?base, ?strBase),
   _NameFromRefMode(?fld, ?fldName),
   ?baseDot = ?strBase + ".",
   ?str = ?baseDot + ?fldName.

_NameFromRefMode(?ref, ?name) ->
   string(?ref), string(?name).

_NameFromRefMode(?ref, ?varName) :-
   Var_Value(_:?ref),
   _VarRefModeLastTokenIndex(?ref, ?maxIdx),
   string_split[?ref, "/", ?maxIdx] = ?varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_NameFromRefMode(?ref, ?varName) :-
   Field_Value(_:?ref),
   _FieldRefModeLastTokenIndex(?ref, ?maxIdx),
   string_split[?ref, "/", ?maxIdx] = ?varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_VarRefModeLastTokenIndex(?ref, ?maxIdx) :-
   agg<<?maxIdx = max(?idx)>>
   Var_Value(_:?ref),
   string_split[?ref, "/", ?idx] = _.

_FieldRefModeLastTokenIndex(?ref, ?maxIdx) :-
   agg<<?maxIdx = max(?idx)>>
   Field_Value(_:?ref),
   string_split[?ref, "/", ?idx] = _.
*/


/*
  ///// POINT1--unchanged access paths code

  //// Dealing with unchanged access paths (below) hasn't proven
  //// worthwhile. It's not surprising. The callee has no name for
  //// this access path. The only hope is that it will survive through
  //// virtual calls and will come back to the caller (whereas the
  //// conservative must-pre-analysis won't consider virtual calls it
  //// cannot resolve in its naive way).

  // This is quite expensive if not restricted. Currently used only for
  // non-resolved virtual calls. For resolved ones, we have a frame rule
  // to propagate the information right over the method call in many
  // cases (and we ignore the rest for now).
  // ChangedBaseAtInvocation(?var, ?invo) :-
  //   ActualParam(_, ?invo, ?var);
  //   VirtualMethodInvocation_Base(?invo, ?var);
  //   SpecialMethodInvocation_Base(?invo, ?var).

  // OptPotentialAccessPathMayPointToPropagation(?hctx, ?heap, ?invo, ?calleeCtx, ?toMethod, ?ap) :-
  //   MayCallGraphEdge_ToMethod(?toMethod, ?callerCtx, ?invo),
  //   !May_MustCallGraphEdge_ToMethod(?callerCtx, ?invo, ?toMethod),
  //   MayCallGraphEdge_Context(?callerCtx, ?invo, ?calleeCtx),
  //   Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?callerCtx, ?invo).

  // Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?calleeCtx, ?firstInsn) :-
  //    OptPotentialAccessPathMayPointToPropagation(?hctx, ?heap, ?invo, ?calleeCtx, ?toMethod, ?ap),
  //    AccessPath_BaseVar(?ap, ?baseVar),
  //    !ChangedBaseAtInvocation(?baseVar, ?invo),
  //    SingleFieldAccessPath(?fld, ?ap),
  //    (MethodMayAssignField(?fld, ?toMethod);
  //     MethodHasUnresolvedInvocation(?toMethod)),
  //    FirstInstructionOfMethod(?toMethod, ?firstInsn).

  // Before_AccessPathMayPointTo(?hctx, ?heap, ?ap, ?calleeCtx, ?firstInsn) :-
  //    OptPotentialAccessPathMayPointToPropagation(?hctx, ?heap, ?invo, ?calleeCtx, ?toMethod, ?ap),
  //    AccessPath_BaseVar(?ap, ?baseVar),
  //    !ChangedBaseAtInvocation(?baseVar, ?invo),
  //    _DoubleFieldAccessPath(?fld1, ?fld2, ?ap),
  //    (MethodMayAssignField(?fld1, ?toMethod);
  //     MethodMayAssignField(?fld2, ?toMethod);
  //     MethodHasUnresolvedInvocation(?toMethod)),
  //    FirstInstructionOfMethod(?toMethod, ?firstInsn).
*/


//// Enter at POINT2---IgnorableMethodInvocation
//// ====================================
//// BEGIN configuration of ignorable method calls

// Some calls to native or otherwise complex methods need to be
// modeled, i.e., ignored. E.g., fillInStackTrace is a native method
// called in the constructor of a (ubiquitous) java.lang.Throwable. If
// not ignored, no image of the heap propagates anywhere.
// TODO: do a better match (on full sig) than just on SimpleName.

// IgnorableMethodInvocation(?invo) :-
//    VirtualMethodInvocation_SimpleName(?invo, "fillInStackTrace"); // Throwable
//    VirtualMethodInvocation_SimpleName(?invo, "equals");  // Object
//    VirtualMethodInvocation_SimpleName(?invo, "hashCode");
//    VirtualMethodInvocation_SimpleName(?invo, "toString");
//    VirtualMethodInvocation_SimpleName(?invo, "println"); // PrintStream
//    StaticMethodInvocation_SimpleName(?invo, "parseInt"); // Integer
//    VirtualMethodInvocation_SimpleName(?invo, "endsWith"); // String
//    StaticMethodInvocation_SimpleName(?invo, "floatToRawIntBits"); // Float
//    // these are used in the HashMap "put" method!
//    StaticMethodInvocation_SimpleName(?invo, "intBitsToFloat");
//    // From this point on, it's just a test to see if these natives matter.
//    StaticMethodInvocation_SimpleName(?invo, "encoding"); // Console
//    StaticMethodInvocation_SimpleName(?invo, "echo");
//    StaticMethodInvocation_SimpleName(?invo, "istty");
//    VirtualMethodInvocation_SimpleName(?invo, "sync"); // FileDescriptor
//    StaticMethodInvocation_SimpleName(?invo, "initIDs");
//    VirtualMethodInvocation_SimpleName(?invo, "open"); // FileInputStream
//    VirtualMethodInvocation_SimpleName(?invo, "read0");
//    VirtualMethodInvocation_SimpleName(?invo, "readBytes");
//    VirtualMethodInvocation_SimpleName(?invo, "skip");
//    VirtualMethodInvocation_SimpleName(?invo, "available");
//    VirtualMethodInvocation_SimpleName(?invo, "close0");
//    VirtualMethodInvocation_SimpleName(?invo, "write"); // FileOutputStream
//    VirtualMethodInvocation_SimpleName(?invo, "writeBytes");
//    VirtualMethodInvocation_SimpleName(?invo, "availableProcessors"); // Runtime
//    VirtualMethodInvocation_SimpleName(?invo, "freeMemory");
//    VirtualMethodInvocation_SimpleName(?invo, "totalMemory");
//    VirtualMethodInvocation_SimpleName(?invo, "maxMemory");
//    VirtualMethodInvocation_SimpleName(?invo, "gc");
//    StaticMethodInvocation_SimpleName(?invo, "runFinalization0");
//    StaticMethodInvocation_SimpleName(?invo, "sin"); // StrictMath
//    StaticMethodInvocation_SimpleName(?invo, "cos");
//    StaticMethodInvocation_SimpleName(?invo, "tan");
//    StaticMethodInvocation_SimpleName(?invo, "log");
//    StaticMethodInvocation_SimpleName(?invo, "pow");
//    StaticMethodInvocation_SimpleName(?invo, "currentThread"); // Thread
//    StaticMethodInvocation_SimpleName(?invo, "yield");
//    StaticMethodInvocation_SimpleName(?invo, "sleep");
//    VirtualMethodInvocation_SimpleName(?invo, "start0");
//    VirtualMethodInvocation_SimpleName(?invo, "isInterrupted");
//    VirtualMethodInvocation_SimpleName(?invo, "isAlive");
//    StaticMethodInvocation_SimpleName(?invo, "holdsLock");
//    StaticMethodInvocation_SimpleName(?invo, "getThreads");
//    StaticMethodInvocation_SimpleName(?invo, "dumpThreads");
//    VirtualMethodInvocation_SimpleName(?invo, "setPriority");
//    VirtualMethodInvocation_SimpleName(?invo, "stop0");
//    VirtualMethodInvocation_SimpleName(?invo, "suspend0");
//    VirtualMethodInvocation_SimpleName(?invo, "resume0");
//    VirtualMethodInvocation_SimpleName(?invo, "interrupt0");
//    VirtualMethodInvocation_SimpleName(?invo, "isAlive");
//    VirtualMethodInvocation_SimpleName(?invo, "getStackTraceDepth"); // Throwable
//    VirtualMethodInvocation_SimpleName(?invo, "getStackTraceElement");
//    VirtualMethodInvocation_SimpleName(?invo, "forkAndExec");  // UnixProcess
//    VirtualMethodInvocation_SimpleName(?invo, "wait"); // Object
//    VirtualMethodInvocation_SimpleName(?invo, "notify");
//    VirtualMethodInvocation_SimpleName(?invo, "notifyAll").

// IgnorableForStaticsMethodInvocation(?invo) :-
//    VirtualMethodInvocation_SimpleName(?invo, "intern"); // String
//    VirtualMethodInvocation_SimpleName(?invo, "clone"); // Object
//    VirtualMethodInvocation_SimpleName(?invo, "append"). // StringBuilder

// // *Collections*
// IgnorableForNonCollectionsMethodInvocation(?invo) :-
//   LibraryCollectionStoreOperation(?invo);
//   LibraryCollectionLoadOperation(?invo).

StaticMethodInvocation_SimpleName(?invocation, ?simplename) :-
   MethodInvocation_Method(?invocation, ?signature),
   isStaticMethodInvocation_Insn(?invocation),
   Method_SimpleName(?signature, ?simplename).

//// END configuration of ignorable method calls


/*
//// POINT4 code
// //// Commented out for now. Does not make that much difference.
// //// InstanceFieldMayPointTo inferences rarely get stopped because of
// //// library calls.
// //// ------------------------------
// // Logic for assuming the library does not affect application fields,
// // except via reflection.
// ApplicationField(?fld) :-
//    Field_DeclaringType(?fld, ?class),
//    ApplicationClass(?class).

// ApplicationMethod(?meth) :-
//    Method_DeclaringType(?meth, ?declaringType),
//    ApplicationClass(?declaringType).

// MethodCallsReflection(?meth) :-
//    Instruction_Method(?invo, ?meth),
//    MethodInvocation_Method(?invo, ?sig),
//    string_substring(?sig, 0, _, "<java.lang.reflect").

// _Opt2MethodInvocation_Method(?invo, ?inMeth, ?toMeth) :-
//    (isStaticMethodInvocation_Insn(?invo);
//     isSpecialMethodInvocation_Insn(?invo)),
//    MethodInvocation_Method(?invo, ?toMeth),
//    Instruction_Method(?invo, ?inMeth).

// // exact resolution for static/special
// MethodCallsReflection(?inMeth) :-
//    _Opt2MethodInvocation_Method(_, ?inMeth, ?toMeth),
//    MethodCallsReflection(?toMeth).

// // underapproximation of virtual method resolution, as if static
// _Opt2MethodInvocation_Method(?invo, ?inMeth, ?toMeth) :-
//    isVirtualMethodInvocation_Insn(?invo),
//    MethodInvocation_Method(?invo, ?toMeth),
//    Instruction_Method(?invo, ?inMeth).

// // Naive virtual method resolution, based on name. REVIEW: too conservative?
// _OptVirtualMethodInvocation_Simplename(?inMeth, ?simpleName) :-
//    VirtualMethodInvocation_SimpleName(?invo, ?simpleName),
//    Instruction_Method(?invo, ?inMeth).

// MethodCallsReflection(?inMeth) :-
//    MethodCallsReflection(?toMeth),
//    Method_SimpleName(?toMeth, ?toMethSimpleName),
//    _OptVirtualMethodInvocation_Simplename(?inMeth, ?toMethSimpleName).

// InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) :-
//    AllPredecessors_InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
//    MethodInvocation_Method(?insn, ?calledMethod), // underapproximate
// //   string_substring[?calledMethod, 0, string_length[?str]] != ?str, ?str = "<java.lang.reflect",
//    !MethodCallsReflection(?calledMethod),
//    ApplicationField(?fld),
//    !ApplicationMethod(?calledMethod).

// StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) :-
//    AllPredecessors_StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
//    MethodInvocation_Method(?insn, ?calledMethod),
// //   string_substring[?calledMethod, 0, string_length[?str]] != ?str, ?str = "<java.lang.reflect",
//    !MethodCallsReflection(?calledMethod),
//    ApplicationField(?fld),
//    !ApplicationMethod(?calledMethod).

// // TODO: also extend to collections
*/


/*
//// POINT5: DominatedPathMayInvalidateFieldPointsTo
// // TODO: currently has no impact. Comment out and re-check when non-invalidating
// //       method calls are added?

// // Interesting addition to frame rules:
// // propagate in case of non-invalidating dominated predecessors.

// // The path (dominated by ?dominator) that ends at ?insn
// // may invalidate some field.
// DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) :-
//    Dominates(?dominator, ?insn),
//    BasicBlockMayInvalidateFieldPointsTo(?fld, ?insn).

// DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) :-
//    DominatedPathMayInvalidateFieldPointsTo(?fld, ?otherInsn, ?dominator),
//    MaySuccessorBBModuloThrow(?insn, ?otherInsn),
//    Dominates(?dominator, ?insn).

// ExistsFieldInvalidatingPathToPredecessor(?fld, ?prevHead, ?dominator) :-
//    DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
//    BasicBlockHead(?prevInsn, ?prevHead),
//    DominatedPathMayInvalidateFieldPointsTo(?fld, ?prevHead, ?dominator).

// ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?dominator) :-
//    ExistsFieldInvalidatingPathToPredecessor(?fld, _, ?dominator).

// BasicBlockMayInvalidateAllFieldsPointsTo(?headInsn) :-
//    BasicBlockHead(?insn, ?headInsn),
//    !IndifferentInstruction(?insn),
//    !FieldInstruction(?insn).

// // The path (dominated by ?dominator) that ends at ?insn
// // may invalidate any field.
// DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) :-
//    Dominates(?dominator, ?insn),
//    BasicBlockMayInvalidateAllFieldsPointsTo(?insn).

// DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) :-
//    DominatedPathMayInvalidateAllFieldsPointsTo(?otherInsn, ?dominator),
//    MaySuccessorBBModuloThrow(?insn, ?otherInsn),
//    Dominates(?dominator, ?insn).

// ExistsAllFieldsInvalidatingPathToPredecessor(?prevHead, ?dominator) :-
//    DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
//    BasicBlockHead(?prevInsn, ?prevHead),
//    DominatedPathMayInvalidateAllFieldsPointsTo(?prevHead, ?dominator).

// ExistsAllFieldsInvalidatingPathToSomePredecessor(?dominator) :-
//    ExistsAllFieldsInvalidatingPathToPredecessor(_, ?dominator).

// InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) :-
//    AllNonDomPredecessors_InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
//    DominatesItsPredecessorInstruction(_, ?insn).

// StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) :-
//    AllNonDomPredecessors_StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
//    DominatesItsPredecessorInstruction(_, ?insn).

// // TODO: update with collections
*/


//// Work area
// Good regexp for most functional predicate replacement:
// 		 \[\([\?a-zA-Z0-9_, ]+\)\] = \([\?a-zA-Z0-9_"<>]+\) -> (\1, \2)
// misses [] and nested []s.
// Many [] are replaced with the following (preferably to run before!):
//       \([_A-Za-z_]+\)\[\] = \([\?a-zA-Z0-9_]+\) -> \1(\2)
// 		 \([\?a-zA-Z0-9_]+\) = \([_A-Za-z_]+\)\[\] -> \2(\1)
