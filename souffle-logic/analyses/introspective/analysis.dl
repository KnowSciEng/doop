#include "../context-insensitive/analysis.dl"

.init preAnalysis = BasicContextSensitivity<ContextInsensitiveConfiguration>

.type UniqueContext
.type UniqueHContext
.type InstrospectiveComponent = mainAnalysis.Value | UniqueContext | UniqueHContext

.comp IntrospectiveConfiguration : AbstractConfiguration {
  
.type Context  = [ c1:InstrospectiveComponent, c2:InstrospectiveComponent ]
.type HContext = [ c1:InstrospectiveComponent, c2:InstrospectiveComponent ]

.decl UContext(?ctx:UniqueContext)
.decl UHContext(?hctx:UniqueHContext)

#define UNIQUE_CONTEXT  "<<unique-context>>"
#define UNIQUE_HCONTEXT "<<unique-hcontext>>"

UContext(UNIQUE_CONTEXT).
UHContext(UNIQUE_HCONTEXT).

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invo, ?method),
  !InOutFlowDirectTwoValues(?method),
  !InOutFlowAnyTwoValues(?method),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp, ?calleeCtxComp].

ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?calleeCtx) :-
  ContextRequest(?callerCtx, ?hctx, ?invo, ?value),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invo, ?method),    
  (InOutFlowDirectTwoValues(?method);
   InOutFlowAnyTwoValues(?method)),
  ?hctx = [?hctxValue1, ?hctxValue2],
  ?calleeCtx = [?hctxValue2, ?value],
  ?hctxValue1 = ?hctxValue1.

StaticContextResponse(?callerCtx, ?invo, ?calleeCtx) :-
  StaticContextRequest(?callerCtx, ?invo),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp, ?calleeCtxComp].

RecordContextResponse(?ctx, ?value, ?var, ?hctx) :-
  RecordContextRequest(?ctx, ?value, ?var),      
  ?ctx = [?component1, ?component2],
  ?hctx = [?component1, ?component2].

// MergeThreadStart, MergeStartup, and MergeFinalizerRegisterContext
// have the same logic as plain Merge for this analysis.
ThreadStartContextResponse(?callerCtx, ?hctx, ?value, ?newCtx) :-
  ThreadStartContextRequest(?callerCtx, ?hctx, ?value),
  UContext(?newCtxComp),
  ?newCtx = [?newCtxComp, ?newCtxComp].

StartupContextResponse(?hctx, ?value, ?calleeCtx) :-
  StartupContextRequest(?hctx, ?value),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp, ?calleeCtxComp].
              
FinalizerRegisterContextResponse(?callerCtx, ?inmethod, ?value, ?calleeCtx) :-
  FinalizerRegisterContextRequest(?callerCtx, ?inmethod, ?value),
  UContext(?calleeCtxComp),
  ?calleeCtx = [?calleeCtxComp, ?calleeCtxComp].

InitContextResponse(?s, ?ctx) :-
  ?ctx = [?comp, ?comp],
  UContext(?comp),                   
  InitContextRequest(?s).

InitHContextResponse(?s, ?hctx) :-
  ?hctx = [?comp, ?comp],                  
  UHContext(?comp),
  InitHContextRequest(?s).
         
.decl InOutFlowDirectValue(?method:Method, ?value:Value)

/** Direct in out flow:
 *
 *   arg -> value
 *   ret -> value
 */
InOutFlowDirectValue(?method, ?value) :-
  FormalParam(_, ?method, ?var),
  preAnalysis.VarPointsTo(_, ?value, _, ?var),
  ReturnVar(?returnVar, ?method),
  preAnalysis.VarPointsTo(_, ?value, _, ?returnVar).

.decl InOutFlowDirectTwoValues(?method:Method)

InOutFlowDirectTwoValues(?method) :-
  InOutFlowDirectValue(?method, ?value1),
  InOutFlowDirectValue(?method, ?value2),
  ?value1 != ?value2.

.output InOutFlowDirectTwoValues

/**
 * Wrapped in out flow:
 *
 * arg -> value
 * ret -> ... -> ... -> value
 */
.decl InOutFlowWrappedValue(?method:Method, ?value:Value) 

InOutFlowWrappedValue(?method, ?value) :-
  FormalParam(_, ?method, ?var),
  ReturnVar(?returnVar, ?method),
  preAnalysis.VarPointsTo(_, ?value, _, ?var),
  preAnalysis.VarPointsTo(_, ?baseValue, _, ?returnVar),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowWrappedTwoValues(?method:Method)

InOutFlowWrappedTwoValues(?method) :-
  InOutFlowWrappedValue(?method, ?value1),
  InOutFlowWrappedValue(?method, ?value2),
  ?value1 != ?value2.

.output InOutFlowWrappedTwoValues

/**
 * Unwrapped in out flow:
 *
 * arg -> ... -> ... -> ... -> value
 * ret -> value
 */
.decl InOutFlowUnwrappedValue(?method:Method, ?value:Value) 

InOutFlowUnwrappedValue(?method, ?value) :-
  FormalParam(_, ?method, ?var),
  ReturnVar(?returnVar, ?method),
  preAnalysis.VarPointsTo(_, ?baseValue, _, ?var),
  preAnalysis.VarPointsTo(_, ?value, _, ?returnVar),
  ValuePointsTo(?baseValue, ?value),
  ?value != ?baseValue.

.decl InOutFlowUnwrappedTwoValues(?method:Method)

InOutFlowUnwrappedTwoValues(?method) :-
  InOutFlowUnwrappedValue(?method, ?value1),
  InOutFlowUnwrappedValue(?method, ?value2),
  ?value1 != ?value2.

.output InOutFlowUnwrappedTwoValues
/** Utility rule: Value points to another value directly or indirectly **/
.decl ValuePointsTo(?baseValue:Value, ?value:Value)

ValuePointsTo(?baseValue, ?value) :-
  preAnalysis.InstanceFieldPointsTo(_, ?value, _, _, ?baseValue).

ValuePointsTo(?baseValue, ?value) :-
  preAnalysis.InstanceFieldPointsTo(_, ?value1, _, _, ?baseValue),
  ValuePointsTo(?value1, ?value).                         

/**
 * Any in out flow:
 *
 * arg -> ... -> ... -> ... -> value
 * ret -> ... -> ... -> ... -> value
 */

.decl InOutFlowAnyValue(?method:Method, ?value:Value) 

InOutFlowAnyValue(?method, ?value) :-
  FormalParam(_, ?method, ?var),
  ReturnVar(?returnVar, ?method),
  preAnalysis.VarPointsTo(_, ?baseValue1, _, ?var),
  preAnalysis.VarPointsTo(_, ?baseValue2, _, ?returnVar),
  ValuePointsTo(?baseValue1, ?value),
  ValuePointsTo(?baseValue2, ?value),
  ?baseValue1 != ?baseValue2.
             
.decl InOutFlowAnyTwoValues(?method:Method)
      
InOutFlowAnyTwoValues(?method) :-
  InOutFlowAnyValue(?method, ?value1),
  InOutFlowAnyValue(?method, ?value2),
  ?value1 != ?value2.

.output InOutFlowAnyTwoValues
}
