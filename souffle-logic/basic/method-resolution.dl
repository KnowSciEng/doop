MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    MethodImplemented(?simplename, ?descriptor, ?type, ?method).

MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    DirectSuperclass(?type, ?supertype),
    MethodLookup(?simplename, ?descriptor, ?supertype, ?method),
    ! MethodImplemented(?simplename, ?descriptor, ?type, _).

/**
 * Arrays
 *
 * TODO MethodLookup of clone in an array type now results in
 *      Object.clone. This is not according to the spec, but in the
 *      Sun JVM arrays don't have a declared clone method either. The
 *      bytecode does indicate a call to clone in the array class, but
 *      the Jimple code turns this into a call of
 *      java.lang.Object.clone()
 *
 * TODO Alternative, better implementation: just make java.lang.Object
 *      a direct superclass of array types, something we should do
 *      anyway.
 */
MethodLookup(?simplename, ?descriptor, ?arraytype, ?method) :-
    isArrayType(?arraytype),
    isType(?objectType),
    MethodImplemented(?simplename, ?descriptor, ?objectType, ?method),
    ?objectType = "java.lang.Object".

MethodImplemented(?simplename, ?descriptor, ?type, ?method) :-
    Method_SimpleName(?method, ?simplename),
    Method_Descriptor(?method, ?descriptor),
    Method_DeclaringType(?method, ?type),
    ! Method_Modifier("abstract", ?method).

// Relations used to find overridden methods with covariant return types.
// Guarded by a macro, so that they can be disabled (the rules are expensive).
#ifdef FEATHERWEIGHT_ANALYSIS
#undef COVARIANT_METHODS
#endif
 
#ifdef COVARIANT_METHODS

.decl MethodOverridesOther(?meth1:Method, ?meth2:Method)
.decl MethodDoesntOverrideOther(?meth1:Method, ?meth2:Method)
.decl MethodMightOverrideOther(?meth1:Method, ?meth2:Method)

// Method ?meth1 has the same name as ?meth2, in a subtype.
MethodMightOverrideOther(?meth1, ?meth2) :-
   Method_SimpleName(?meth1, ?sameName),
   Method_SimpleName(?meth2, ?sameName),
   ?sameName != "<clinit>",
   ?sameName != "<init>",
   !Type_void(?type1),
   !Type_void(?type2),
   Method_DeclaringType(?meth1, ?type1),
   Method_DeclaringType(?meth2, ?type2),
   SubtypeOfDifferent(?type1, ?type2).

// Limited to methods that have the same name, in subtypes. Method
// ?meth1 *could* override ?meth2, but has different arg types.
// REVIEW: using _Var_Type instead of Var_Type to avoid
// recursion-through-negation.
MethodDoesntOverrideOther(?meth1, ?meth2) :-
   MethodMightOverrideOther(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, ?formal1),
   _Var_Type(?formal1, ?type1),
   FormalParam(?sameIndex, ?meth2, ?formal2),
   _Var_Type(?formal2, ?type2),
   ?type1 != ?type2.

MethodDoesntOverrideOther(?meth1, ?meth2) :-
   MethodMightOverrideOther(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, _),
   !FormalParam(?sameIndex, ?meth2, _).

MethodDoesntOverrideOther(?meth1, ?meth2) :-
   MethodMightOverrideOther(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth2, _),
   !FormalParam(?sameIndex, ?meth1, _).

MethodOverridesOther(?meth1, ?meth2) :-
   MethodMightOverrideOther(?meth1, ?meth2),
   !MethodDoesntOverrideOther(?meth1, ?meth2).

// If another method is defined, having the same name & arguments but
// a covariant return type, also register it in MethodImplemented
// using the overridden method's descriptor.
MethodImplemented(?name, ?descriptor, ?type, ?comethod) :-
    MethodImplemented(?name, _, ?type, ?comethod),
    MethodOverridesOther(?comethod, ?method),
    Method_SimpleName(?method, ?name),
    Method_ReturnType(?method, ?type1),
    Method_ReturnType(?comethod, ?type2),
    SubtypeOf(?type2, ?type1),
    Method_Descriptor(?method, ?descriptor).

#endif // COVARIANT_METHODS

ResolveInvocation(?type, ?invocation, ?tomethod) :-
    VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
    VirtualMethodInvocation_Descriptor(?invocation, ?descriptor),
    VirtualMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype),
    MethodLookup(?simplename, ?descriptor, ?type, ?tomethod),
    SubtypeOf(?type, ?basetype).

OverridableMethod(?type, ?method) :-
    MethodLookup(_, _, ?type, ?method),
    ! Method_Modifier("static", ?method),
    ! Method_Modifier("final", ?method),
    Method_Modifier("public", ?method),
    Subclassable(?type).

OverridableMethod(?type, ?method) :-
    MethodLookup(_, _, ?type, ?method),
    ! Method_Modifier("static", ?method),
    ! Method_Modifier("final", ?method),
    Method_Modifier("protected", ?method),
    Subclassable(?type).

ClassConstructor(method, type) :-
    MethodLookup(_, _, type, method),
    isMethod(method),
    match(".*<init>.*", method).
