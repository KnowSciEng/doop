+LoadArrayIndex(?array, ?value, ?inmethod)/*,
+java:lang:reflect:Array:get(?invocation)*/ <-
  Method:Id(?sig:"<java.lang.reflect.Array: java.lang.Object get(java.lang.Object,int)>"),
  StaticMethodInvocation(?invocation, ?sig, ?inmethod),
  ActualParam@previous[0, ?invocation] = ?array,
  AssignReturnValue[?invocation] = ?value.

+StoreArrayIndex(?value, ?array, ?inmethod)/*,
+java:lang:reflect:Array:set(?invocation)*/ <-
  Method:Id(?sig:"<java.lang.reflect.Array: void set(java.lang.Object,int,java.lang.Object)>"),
  StaticMethodInvocation(?invocation, ?sig, ?inmethod),
  ActualParam@previous[0, ?invocation] = ?array,
  ActualParam@previous[2, ?invocation] = ?value.

+Type:Id(?proxyClass:?proxyClassId), +ProxyClass(?proxyClass),
+ClassModifier("public", ?proxyClass), +ClassModifier("final", ?proxyClass),
+DirectSuperclass[?proxyClass] = ?proxySuperclass,
+DirectSuperinterface(?proxyClass, ?interface) <-
  InterfaceType@previous(?interface),
  Type:Id@previous(?interface:?interfaceId),
  Type:Id@previous(?proxySuperclass:"java.lang.reflect.Proxy"),
  ClassType@previous(?proxySuperclass),
  ?proxyClassId = "Proxy$for$" + ?interfaceId.
  

/* == Dynamic proxy handling ==

   Java dynamic proxies are handled in two steps:

   1. For every interface, we create a dummy proxy class that will
      represent the type of objects returned by
      Proxy.newProxyInstance(). This proxy class is concrete and
      contains entry points for all methods declared in the interface
      it implements. All such methods are implemented as calls to the
      invoke() method of an InvocationHandler (which is passed to the
      constructor and stored in a local field).

   2. For every call to Proxy.newProxyInstance, such as the following:

        Object obj = Proxy.newProxyInstance(cl, is, h);   // e.g. instr. #4

      we generate facts as if we had seen the following code:

        // special proxy constructor variable
        Constructor c;
        Object obj = c.newInstance(h);
 
      Explanation: our handling of "newInstance" on
      java.lang.reflect.Constructor already takes care of the
      delegation pattern for "invoke". So we appeal to that. The
      values flowing into generated constructor var "c" will be
      inferred by analysis rules, depending on the values of "is":
      whenever the "is" argument can contain the class object of
      some interface I, then c is the constructor of the proxy class
      of I.

   For more details on each step, see below.

   == Step 1: Dummy proxy class generation ==

   To see how the methods of the proxy class are implemented, assume
   that the proxy is for an interface I:

     interface I {
       void report(String c);
       int count();
     }

   Then, we generate a proxy class for I, with the following method
   bodies:
     class G_I {
       ... // reference ih to actual handler and constructor
       public void report(String msg) {
         Method interfaceMethod = I$V$report$Ljava$lang$String;
         Object[] args = new Object[] {msg};
         ih.invoke(this, interfaceMethod, args);
       }

       public int count() {
         Method interfaceMethod = I$I$count$V;
         Object[] args = new Object[] { };
         return (Integer)ih.invoke(this, interfaceMethod, args);
       }
     }

   Notes about the code above:

     - In the second method, we depend on implicitly unboxing the
       Integer result of the call to int. The cast to Integer is
       needed when the above is written as Java code.

     - The Method variables are supposed to be initialized with
       special values. In practice, our logic records the existence of
       these Method variables here, and it later (during reflection
       analysis) makes them point to the appropriate reified method
       objects.

*/

/*
// For each 'interface' (with ID = 'interfaceId'), generate a
// 'proxyClassId'.
#define ProxiedInterfaceMacro(interface, interfaceId, proxyClassId) \
  InterfaceType@previous(interface), \
  Type:Id@previous(interface:interfaceId), \
  proxyClassId = "Proxy$for$" + interfaceId

// For a method named 'simple', with descriptor 'desc' and return type
// 'retType', generate a 'methodId' for a method to be declared inside
// 'proxyClassId'. Variables 'retTypeLen' and 'methodArgsSig' are
// reserved for this macro.
#define CalcMethodId(proxyClassId, retType, simple, desc, methodId) \
   string:length[retType] = retTypeLen, \
   string:substring[desc, retTypeLen, string:length[desc] - retTypeLen] = methodArgsSig, \
   methodId = "<" + proxyClassId + ": " + retType + " " + simple + methodArgsSig + ">"

// For a method inside a proxy class, generate IDs for the method
// variable, the Method.invoke() instruction, and the return
// instruction.
#define ProxyMethodMacro(methodId, proxyClassId, methodVarId, invokeId, retInstrId) \
   methodVarId = methodId + "$method", \
   invokeId = proxyClassId + "/" + methodVarId + "/0", \
   retInstrId = invokeId + "/return/0"

#include "proxyMacros.logic"

// Create declaration of proxy class.
+Type:Id(?proxyClass:?proxyClassId), +ProxyClass(?proxyClass),
+DirectSuperinterface(?proxyClass, ?interface),
// Create class initializer method.
+Method:Id(?clinit:?clinitId), +Method(?clinit),
+Method:DeclaringType[?clinit] = ?proxyClass,
+Method:SimpleName[?clinit] = "<clinit>",
+Method:ReturnType[?clinit] = Type:void@previous[],
+Method:Descriptor[?clinit] = "void()",
+Method:JVMDescriptor[?clinit] = "()V",
+Method:Modifier(?static, ?clinit),
// Create public constructor method.
+Method:Id(?constructor:?constructorId), +Method(?constructor),
+Method:DeclaringType[?constructor] = ?proxyClass,
+Method:SimpleName[?constructor] = "<init>",
+Method:ReturnType[?constructor] = Type:void@previous[],
+Method:Descriptor[?constructor] = "void(java.lang.reflect.InvocationHandler)",
+Method:JVMDescriptor[?constructor] = "(Ljava/lang/reflect/InvocationHandler;)V",
+Method:Modifier(?public, ?constructor),
// Create invocation handler field.
+Field:Id(?fieldIHandler:?fieldIHandlerId), +Field(?fieldIHandler),
+Field:DeclaringType[?fieldIHandler] = ?proxyClass,
+Field:SimpleName[?fieldIHandler] = "h",
+Field:Type[?fieldIHandler] = ?invocationHandlerType,
+Field:Modifier(?private, ?fieldIHandler)
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   // Proxy class constructor.
   ?constructorId = ConstrIdMacro(?proxyClassId),
   ?clinitId = "<" + ?proxyClassId + ": void <clinit>()>",
   // Field containing an InvocationHandler.
   Type:Id@previous(?invocationHandlerType:"java.lang.reflect.InvocationHandler"),
   ?fieldIHandlerId = ?proxyClassId + "$h",
   Modifier:Id@previous(?public:"public"),
   Modifier:Id@previous(?private:"private"),
   Modifier:Id@previous(?static:"static").

+Type:Id(?proxyClass:?proxyClassId), +ProxyClass(?proxyClass),
// For each proxy class of interface I, for every method m of I,
// generate a public method with the same signature and return type in
// the proxy class. The body of the method will call the invoke()
// method of the InvocationHandler object with the correct arguments.
+Method:Id(?method:?methodId), +Method(?method),
+Method:DeclaringType[?method] = ?proxyClass,
+Method:ReturnType[?method] = ?retType,
+Method:Descriptor[?method] = ?desc,
+Method:SimpleName[?method] = ?simple,
+Method:JVMDescriptor[?m] = ?jvmDesc,
// Here we create the variables that contain the Method object, and
// the arguments list. We will assign values to them later, in the
// analysis.
+Var:Id(?methodVar:?methodVarId), +Var(?methodVar),
+Var:Type[?methodVar] = ?methodType,
+Var:Id(?argsVar:?argsVarId), +Var(?argsVar),
+Var:Type[?argsVar] = ?argsType,
// Create the 'this' variable.
+Var:Id(?thisVar:?thisVarId), +Var(?thisVar),
+Var:Type[?thisVar] = ?proxyClass,
+ThisVar[?method] = ?thisVar,
// Create instruction 'Object[] args = new Object[]'.
+Instruction:Id(?createArgs:?createArgsId), +AssignHeapAllocation:Insn(?createArgs),
+Instruction:Index[?createArgs] = 3, +Instruction:Method[?createArgs] = ?method,
// Create heap object for Object[] arguments.
+HeapAllocation0:Normal(?argsNewId, ?argsType),
+AssignHeapAllocation0(?createArgs, ?argsNewId),
// Create the call to InvocationHandler.invoke().
+StaticMethodInvocation:Insn(?invoke), +Instruction:Id(?invoke:?invokeId),
+Instruction:Index[?invoke] = 4, +Instruction:Method[?invoke] = ?method,
+StaticMethodInvocation:SimpleName[?invoke] = "invoke",
+StaticMethodInvocation:Descriptor[?invoke] = "java.lang.Object(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])",
+MethodInvocation:Signature[?invoke] = "<java.lang.reflect.InvocationHandler: java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])>",
+ActualParam[0, ?invoke] = ?thisVar,
+ActualParam[1, ?invoke] = ?methodVar,
+ActualParam[2, ?invoke] = ?argsVar,
// Create the return instruction.
+Instruction:Id(?retInstr:?retInstrId), +Instruction(?retInstr),
// Register the proxy method, to find it later in the analysis.
+ProxyMethod(?method, ?m, ?methodVar, ?argsVar, ?argsNewId, ?invoke)
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   Method:DeclaringType@previous[?m] = ?interface,
   Method:ReturnType@previous[?m] = ?retType,
   Method:Descriptor@previous[?m] = ?desc,
   Method:SimpleName@previous[?m] = ?simple,
   Method:JVMDescriptor@previous[?m] = ?jvmDesc,
   CalcMethodId(?proxyClassId, ?retType, ?simple, ?desc, ?methodId),
   Type:Id@previous(?methodType:"java.lang.reflect.Method"),
   ?argsVarId = ?methodId + "$args",
   Type:Id@previous(?argsType:"java.lang.Object[]"),
   ProxyMethodMacro(?methodId, ?proxyClassId, ?methodVarId, ?invokeId, ?retInstrId),
   ?argsNewId = ?methodId + "/args",
   ?thisVarId = ?methodId + "/this",
   ?createArgsId = ?argsVarId + "/create"
.

// For proxied methods that have a non-void return type, we also
// create a variable to hold the return value of Method.invoke().
+Var:Id(?retVar:?retVarId), +Var(?retVar),
+Var:Type[?retVar] = ?retType,
// A bit redundancy here.
+Method:Id(?method:?methodId), +Method(?method),
+Instruction:Id(?invoke:?invokeId), +Instruction(?invoke),
+Instruction:Id(?retInstr:?retInstrId), +Instruction(?retInstr),
+StaticMethodInvocation(?invoke, "<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>", ?method),
+StaticMethodInvocation:Insn(?invoke),
// Register the return value connection.
+AssignReturnValue[?invoke] = ?retVar,
+ReturnNonvoid:Insn(?retInstr), +ReturnNonvoid:Var[?retInstr] = ?retVar
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   Method:DeclaringType@previous[?m] = ?interface,
   Method:ReturnType@previous[?m] = ?retType,
   Method:SimpleName@previous[?m] = ?simple,
   Method:Descriptor@previous[?m] = ?desc,
   ?voidType = Type:void@previous[],
   Type:Id@previous(?voidType:?voidTypeId),
   ?retType != ?voidTypeId,
   CalcMethodId(?proxyClassId, ?retType, ?simple, ?desc, ?methodId),
   ?retVarId = ?methodId + "/returnValue",
   ProxyMethodMacro(?methodId, ?proxyClassId, ?methodVarId, ?invokeId, ?retInstrId)
.

// For proxied methods returning void, create the return instruction.
// A bit redundancy here.
// +Method:Id(?method:?methodId), +Method(?method),
// +Instruction:Id(?invoke:?invokeId), +Instruction(?invoke),
+Instruction:Id(?retInstr:?retInstrId), +Instruction(?retInstr),
+ReturnVoid:Insn(?retInstr)
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   Method:DeclaringType@previous[?m] = ?interface,
   Method:ReturnType@previous[?m] = ?retType,
   Method:SimpleName@previous[?m] = ?simple,
   Method:Descriptor@previous[?m] = ?desc,
   ?voidType = Type:void@previous[],
   Type:Id@previous(?voidType:?voidTypeId),
   ?retType = ?voidTypeId,
   CalcMethodId(?proxyClassId, ?retType, ?simple, ?desc, ?methodId),
   ProxyMethodMacro(?methodId, ?proxyClassId, ?methodVarId, ?invokeId, ?retInstrId)
.
*/

/* == Step 2: Transformation of Proxy.newProxyInstance() ==

   This step generates the new constructor variable and records
   information for the reflection analysis to connect the dots.

   Notes:

   - In Java, java.lang.reflect.Constructor.newInstance() takes
     varargs (Object... ); these are implemented as Object[] arrays in
     Jimple. Thus, this code:

       Object obj = c.newInstance(h);

     should be expressed as:

       Object cArgs = new Object[];
       cArgs[0] = h;
       Object obj = c.newInstance(cArgs);

     The above contains two variables and a heap allocation (that are
     to be created in this delta) and an assignment that is filled in
     later by the analysis.

*/

/*
// Generate the new constructor variable 'c'.
+Var(?c), +Var:Id(?c:?cId), +Var:Type[?c] = ?constructorType,
// Generate the new constructor arguments 'cArgs'.
+Var(?cArgs), +Var:Id(?cArgs:?cArgsId), +Var:Type[?cArgs] = ?cArgsType,
// +java:lang:reflect:Constructor:newInstance(?newInstanceInstr, ?obj, ?c),
// The heap allocation of 'cArgs'.
+Instruction:Id(?cArgsInstr:?cArgsInstrId),
+AssignHeapAllocation:Insn(?cArgsInstr),
+HeapAllocation0:Normal(?cArgsNewId, ?cArgsType),
+AssignHeapAllocation0(?cArgsInstr, ?cArgsNewId),
// The 'c.newInstance(cArgs)' instruction.
+VirtualMethodInvocation:Insn(?newInstanceInstr),
+Instruction:Id(?newInstanceInstr:?newInstanceInstrId),
+Instruction:Index[?newInstanceInstr] = ?idx,
+Instruction:Method[?newInstanceInstr] = ?m,
+VirtualMethodInvocation:Base[?newInstanceInstr] = ?c,
+MethodInvocation:Signature[?newInstanceInstr] = ?newInstanceSig,
+VirtualMethodInvocation(?newInstanceInstr, ?newInstanceSig, ?m),
+VirtualMethodInvocation:SimpleName[?newInstanceInstr] = ?newInstanceSimple,
+VirtualMethodInvocation:Descriptor[?newInstanceInstr] = "java.lang.Object(java.lang.Object[])",
+AssignReturnValue[?newInstanceInstr] = ?obj,
+ActualParam[0, ?newInstanceInstr] = ?cArgs,
// Record the new facts about the Proxy.newProxyInstance() call.
+DynamicProxy(?i, ?newInstanceInstr, ?c, ?cArgs, ?interfaces, ?h, ?obj)
 <-
   StaticMethodInvocation:SimpleName@previous[?i] = "newProxyInstance",
   StaticMethodInvocation@previous(?i, ?sig, _),
   ?sig = "<java.lang.reflect.Proxy: java.lang.Object newProxyInstance(java.lang.ClassLoader,java.lang.Class[],java.lang.reflect.InvocationHandler)>",
   Instruction:Id@previous(?i:?id),
   Instruction:Index@previous[?i] = ?idx,
   Instruction:Method@previous[?i] = ?m,
   ?s = "interface$forName/" + ?id,
   ActualParam@previous[1, ?i] = ?interfaces,
   ActualParam@previous[2, ?i] = ?h,
   AssignReturnValue@previous[?i] = ?obj,
   // Constructor variable and instruction.
   ?cId = ?s + "/c",
   ?cArgsId = ?s + "/cArgs",
   ?cArgsNewId = ?s + "/cArgsNew",
   ?cArgsInstrId = ?s + "/cArgsInstr",
   ?newInstanceInstrId = ?cId + "/instr",
   ?newInstanceSig = "<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>",
   SimpleName:Id@previous(?newInstanceSimple:"newInstance"),
   Type:Id@previous(?cArgsType:"java.lang.Object[]"),
   Type:Id@previous(?constructorType:"java.lang.reflect.Constructor")
.
*/