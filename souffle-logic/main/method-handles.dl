/*************************************************************
 * MethodHandle constants
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
   isMethodHandleConstant(?heap).

#define LAMBDA_METAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"

#define LAMBDA_ALTMETAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>"

// Method references are wrapped by calling invokedynamic with
// boostrap method being the lambda metafactory and the second
// bootstrap argument being a constant method handle. The result
// 'value' of the invokedynamic is a lambda, which contains an
// instance method calling static method 'realMethod'.

.decl ConstantMethodHandleLambda(?value:Value, ?dynName:symbol, ?dynRet:Type, ?realMethod:Method)

.decl InvokedynamicBootstrap(?invo:DynamicMethodInvocation_Insn, ?ctx:configuration.Context)

#define MHDesc(type, method, real, ret, name) \
   cat("reference ", cat(type, cat ("::", cat(method, cat(" from ", cat(real, cat(" wrapped as ", cat(ret, cat(".", name)))))))))

#define MHValue(invo, ret, desc) \
   cat(invo, cat("::: ", cat(ret, cat("::: (Mock)::: ", desc))))

// Intermediate relation to make rules easier to read.
.decl ConstantMHLambdaVPT(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var, ?interface:InterfaceType, ?dynName:symbol, ?realMethod:Method, ?invo:MethodInvocation)

ConstantMHLambdaVPT(?hctx, MHValue(?invo, ?interface, MHDesc(?handleType, ?handleMeth, ?realMethod, ?interface, ?dynName)), ?ctx, ?var, ?interface, ?dynName, ?realMethod, ?invo) :-
   isDynamicMethodInvocation_Insn(?invo),
   BootstrapParam(1, ?invo, ?handleVar),
   DynamicMethodInvocation_Bootstrap(?invo, LAMBDA_METAFACTORY_ID),
   VarPointsTo(?hctx, ?handleVal, ?ctx, ?handleVar),
   MethodHandleConstant_Method(?handleVal, ?realMethod),
   DynamicMethodInvocation_DynName(?invo, ?dynName),
   DynamicMethodInvocation_DynReturnType(?invo, ?interface),
   isInterfaceType(?interface),
   AssignReturnValue(?invo, ?var),
   // Used to generate friendly description for the generated wrapper.
   Method_SimpleName(?realMethod, ?handleMeth),
   Method_DeclaringType(?realMethod, ?handleType).
   // ?desc = MHDesc(?handleType, ?handleMeth, ?interface, ?dynName),
   // ?value = MHValue(?invo, ?interface, ?desc).
   // ?value = MHValue(?invo, ?interface, MHDesc(?handleType, ?handleMeth, ?interface, ?dynName)).

// Unpack the information gathered above and populate appropriate relations.
VarPointsTo(?hctx, ?value, ?ctx, ?var),
MockValueConsMacro(?value, ?interface),
ConstantMethodHandleLambda(?value, ?dynName, ?interface, ?realMethod),
InvokedynamicBootstrap(?invo, ?ctx) :-
   ConstantMHLambdaVPT(?hctx, ?value, ?ctx, ?var, ?interface, ?dynName, ?realMethod, ?invo).

// Record invokedynamic invocations whose bootstrap methods are not
// handled at all.
.decl UnhandledInvokedynamic(?i:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)

UnhandledInvokedynamic(?i, ?bootMethodId) :-
   isDynamicMethodInvocation_Insn(?i),
   DynamicMethodInvocation_Bootstrap(?i, ?bootMethodId),
   // ?bootMethodId != LAMBDA_ALTMETAFACTORY_ID,
   ?bootMethodId != LAMBDA_METAFACTORY_ID.

// When invokeinterface is called on a lambda object constructed by a
// constant method handle, the real method is called. This can wrap a
// static method call as an instance method call. We create two call
// graph edges: (1) invokeinterface on the method handle lambda calls
// the real method and (2) invokedynamic calls the bootstrap method.

.decl InvokedynamicCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method)

InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?realMethod) :-
   ConstantMethodHandleLambda(?value, ?dynName, _, ?realMethod),
   VarPointsTo(_, ?value, ?callerCtx, ?var),
   VirtualMethodInvocation_Base(?i, ?var),
   VirtualMethodInvocation_SimpleName(?i, ?dynName),
   ImmutableContextFromContext(?callerCtx, ?calleeCtx).

InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, LAMBDA_METAFACTORY_ID) :-
   ImmutableContextFromContext(?callerCtx, ?calleeCtx),
   InvokedynamicBootstrap(?i, ?callerCtx).

ReachableContext(?calleeCtx, ?callee) :-
   InvokedynamicCallGraphEdge(_, _, ?calleeCtx, ?callee).

// Pass arguments to underlying method.
VarPointsTo(?hctx, ?val, ?ctx, ?formal) :-
   InvokedynamicCallGraphEdge(_, ?i, ?ctx, ?realMethod),
   FormalParam(?idx, ?realMethod, ?formal),
   ActualParam(?idx, ?i, ?actual),
   VarPointsTo(_, ?val, _, ?actual),
   ImmutableHContextFromContext(?ctx, ?hctx).

// Handle return values.
VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret) :-
   InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?realMethod),
   ReturnVar(?realReturnVar, ?realMethod),
   VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?realReturnVar),
   AssignReturnValue(?i, ?ret).

.decl Lambda_Method(?value:Value, ?realMethod:Method)
Lambda_Method(?value, ?realMethod) :-
   ConstantMethodHandleLambda(?value, _, _, ?realMethod).

.decl ConstructorReference(?var:Var, ?value:Value, ?i:MethodInvocation, ?realMethod:Method)

// Applications of constructor references construct values. However,
// these values do not come from a 'new' instruction in the code but
// are created here as special values, one per type.

#define ConstructorReferenceValue(type) cat(type, "::: (Mock)")

VarPointsTo(?hctx, ConstructorReferenceValue(?type), ?ctx, ?var),
ConstructorReference(?var, ConstructorReferenceValue(?type), ?i, ?realMethod),
MockValueConsMacro(ConstructorReferenceValue(?type), ?type) :-
   VarPointsTo(?hctx, ?baseVal, ?ctx, ?base),
   VirtualMethodInvocation_Base(?i, ?base),
   Lambda_Method(?baseVal, ?realMethod),
   Method_SimpleName(?realMethod, "<init>"),
   Method_DeclaringType(?realMethod, ?type),
   AssignReturnValue(?i, ?var).

// Method handles that interact with reflection are exprerimental, use
// corresponding command-line option to enable them.
#ifdef REFLECTION_METHOD_HANDLES

// We treat method descriptors as MethodType values (with slight
// changes, e.g. in the treatment of 'void' or constructors).

.decl MethodType_ReturnType(?descriptor:symbol, ?declType:Type, ?rType:Type)

// Return types for non-constructors.
MethodType_ReturnType(?descriptor, ?declType, ?rType) :-
  Method_Descriptor(?method, ?descriptor),
  Method_ReturnType(?method, ?rType),
  Method_SimpleName(?method, ?name),
  ?name != "<clinit>",
  ?name != "<init>",
  Method_DeclaringType(?method, ?declType).

// Return types for constructors are not "void" but the type constructed.
MethodType_ReturnType(?descriptor, ?rType, ?rType) :-
  Method_Descriptor(?method, ?descriptor),
  Method_SimpleName(?method, "<init>"),
  Method_DeclaringType(?method, ?rType).

.decl MethodType_ParamType(?descriptor:symbol, ?index:number, ?pType:Type)

MethodType_ParamType(?descriptor, ?index, ?pType) :-
  Method_Descriptor(?method, ?descriptor),
  FormalParam(?index, ?method, ?var),
  _Var_Type(?var, ?pType).

#ifdef REFLECTION

// MethodType API entry points. The actual logic: every methodType()
// invocation creates a single mock object that picks all descriptors
// that match its type.

#define MTEntryPoint(id, sig) \
.decl id(?invo:MethodInvocation) \
id(?invo) :- \
   ?signature = sig, \
   MethodInvocation_Method(?invo, ?signature)

MTEntryPoint(MethodType1, "<java.lang.invoke.MethodType: java.lang.invoke.MethodType methodType(java.lang.Class)>").
MTEntryPoint(MethodType2, "<java.lang.invoke.MethodType: java.lang.invoke.MethodType methodType(java.lang.Class,java.lang.Class)>").
MTEntryPoint(MethodType3, "<java.lang.invoke.MethodType: java.lang.invoke.MethodType methodType(java.lang.Class,java.lang.Class,java.lang.Class[])>").
MTEntryPoint(MethodType4, "<java.lang.invoke.MethodType: java.lang.invoke.MethodType methodType(java.lang.Class,java.lang.Class[])>").
MTEntryPoint(MethodType5, "<java.lang.invoke.MethodType: java.lang.invoke.MethodType methodType(java.lang.Class,java.lang.invoke.MethodType)>").
MTEntryPoint(MethodType6, "<java.lang.invoke.MethodType: java.lang.invoke.MethodType methodType(java.lang.Class,java.util.List)>").

.decl MTValue_Invocation(?value:Value, ?invo:MethodInvocation)

#define MTValue(i) cat("MethodType value from ", i)

.decl MTValue_ReturnType(?value:Value, ?type:Type)
.decl MTValue_ParamValue(?value:Value, ?index:number, ?classValue:Value)

// The first argument to methodType() is always the return type.
MockValueConsMacro(MTValue(?invo), "java.lang.invoke.MethodType"),
VarPointsTo(?hctx, MTValue(?invo), ?callerCtx, ?ret),
MTValue_Invocation(MTValue(?invo), ?invo),
MTValue_ReturnType(MTValue(?invo), ?type)
:-
   ( MethodType1(?invo) ; MethodType2(?invo) ; MethodType3(?invo) ;
     MethodType4(?invo) ; MethodType5(?invo) ; MethodType6(?invo) ),
   Instruction_Method(?invo, ?caller),
   ReachableContext(?callerCtx, ?caller),
   ActualParam(0, ?invo, ?param),
   VarPointsTo(?hctx, ?classValue, ?callerCtx, ?param),
   ReifiedClass(?type, ?classValue),
   AssignReturnValue(?invo, ?ret).

// MethodType2, MethodType4: second parameter.
MockValueConsMacro(MTValue(?invo), "java.lang.invoke.MethodType"),
VarPointsTo(?hctx, MTValue(?invo), ?callerCtx, ?ret),
MTValue_Invocation(MTValue(?invo), ?invo),
MTValue_ParamValue(MTValue(?invo), 0, ?classValue) :-
   ( MethodType2(?invo) ; MethodType4(?invo) ),
   ActualParam(1, ?invo, ?param),
   VarPointsTo(?hctx, ?classValue, ?callerCtx, ?param),
   // ReifiedClass(?type, ?classValue),
   AssignReturnValue(?invo, ?ret).

// MethodType1 lacks a parameter, so we use a dummy value instead.
#define MT_NOARGS_VALUE "<mock dummy methodType() class for first argument>"
MockValueConsMacro(MT_NOARGS_VALUE, "java.lang.Class"),
MTValue_ParamValue(MTValue(?invo), 0, MT_NOARGS_VALUE) :-
   MethodType1(?invo).

// Helper relation to treat 'void' and 'java.lang.Void' as the same
// type in descriptors.
.decl MTValueReturnTypeMatchesDescriptor(?value:Value, ?descriptor:symbol)

MTValueReturnTypeMatchesDescriptor(?value, ?descriptor) :-
   MTValue_ReturnType(?value, "java.lang.Void"),
   MethodType_ReturnType(?descriptor, _, "void").
MTValueReturnTypeMatchesDescriptor(?value, ?descriptor) :-
   MTValue_ReturnType(?value, ?rType),
   MethodType_ReturnType(?descriptor, _, ?rType).

.decl Descriptor_Arity(?descriptor:symbol, ?arity:number)

Descriptor_Arity(?descriptor, ?arity) :-
  Method_Descriptor(?method, ?descriptor),
  Method_Arity(?method, ?arity).

.decl MTValueMatchesDescriptor(?value:Value, ?descriptor:symbol)

// MethodType1.
MTValueMatchesDescriptor(?value, ?descriptor) :-
   MethodType1(?invo),
   MTValue_Invocation(?value, ?invo),
   MTValueReturnTypeMatchesDescriptor(?value, ?descriptor),
   MTValue_ParamValue(?value, 0, MT_NOARGS_VALUE),
   Descriptor_Arity(?descriptor, 0).

// MethodType2.
MTValueMatchesDescriptor(?value, ?descriptor) :-
   MethodType2(?invo),
   MTValue_Invocation(?value, ?invo),
   MTValueReturnTypeMatchesDescriptor(?value, ?descriptor),
   MTValue_ParamValue(?value, 0, ?classValue0),
   ReifiedClass(?pType0, ?classValue0),
   MethodType_ParamType(?descriptor, 0, ?pType0),
   Descriptor_Arity(?descriptor, 1).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES
