#include "../../main/single-phase-analysis.dl"
#include "../../main/configuration.dl"

.comp PartitionedTwoObjectSensitivePlusHeapConfiguration : AbstractConfiguration {

  .decl TypeToPartitionName(?type: Type, ?partitionRepresentativeType: symbol)
  .input TypeToPartitionName(IO="file", filename="TypeToPartition.facts", delimiter="\t")
  .output TypeToPartitionName

  .decl TypeToPartitionId(?type: Type, ?id: number)
  .output TypeToPartitionId

  TypeToPartitionId(?type, ?partitionId) :-
    TypeToPartitionName(?type, ?partitionRepresentativeType),
    ?partitionId = ord(?partitionRepresentativeType).

  .decl PrimaryPartitionName(?partitionRepresentativeType: symbol)
  .input PrimaryPartitionName(IO="file", filename="PrimaryPartition.facts")
  .output PrimaryPartitionName

  .decl PrimaryPartitionId(?partitionId: number)
  .output PrimaryPartitionId
  
  PrimaryPartitionId(?partitionId) :-
    PrimaryPartitionName(?partitionRepresentativeType),
    ?partitionId = ord(?partitionRepresentativeType).

  .decl PartitionId(?partitionId: number)
  .output PartitionId
  
  PartitionId(?partitionId) :-
    TypeToPartitionId(_, ?partitionId).

  .decl PartitionName(?partitionName: symbol)
  .output PartitionName
  
  PartitionName(?partitionName) :-
    TypeToPartitionName(_, ?partitionName).

  .output TypeToPartitionName

  .type Context  = [ value1:mainAnalysis.Value, value2:mainAnalysis.Value ]
  .type HContext = [ value:mainAnalysis.Value ]
  
  .decl InvocationInPrimaryPartition(invo: Instruction)
  .decl MethodInPrimaryPartition(method: Method)
  .decl VarInPrimaryPartition(var: Var)

  .decl TypeInAllPartitions(type: Type)
  .decl TypeInNoPartition(type: Type)

  .decl MethodInAllPartitions(method: Method)
  .decl MethodInNoPartition(method: Method)

  .decl VarInAllPartitions(var: Var)
  .decl VarInNoPartition(var: Var)

  .decl ValidCtxVar(ctx: mainAnalysis.configuration.Context, var: Var)
  .decl CollapsedVarPointsTo(hctx: mainAnalysis.configuration.HContext, heap: mainAnalysis.Value, ctx: mainAnalysis.configuration.Context, var: Var)
  
  TypeInAllPartitions(type) :-
    isType(type),
    match("java\.util.*", type).

  TypeInNoPartition(type) :-
      isType(type),
      !TypeToPartitionName(type, _).

  InvocationInPrimaryPartition(invo) :-
    Instruction_Method(invo, inmethod),
    Method_DeclaringType(inmethod, inClass),
    TypeToPartitionId(inClass, partitionId),
    PrimaryPartitionId(partitionId).

  MethodInPrimaryPartition(method) :-
    Method_DeclaringType(method, inClass),
    TypeToPartitionId(inClass, partitionId),
    PrimaryPartitionId(partitionId).

  MethodInNoPartition(method) :-
    Method_DeclaringType(method, inClass),
    TypeInNoPartition(inClass).

  VarInPrimaryPartition(var) :-
    Var_DeclaringMethod(var, method),
    MethodInPrimaryPartition(method).

  VarInNoPartition(var) :-
    Var_DeclaringMethod(var, method),
    MethodInNoPartition(method).

  MethodInAllPartitions(method) :-
    Method_DeclaringType(method, type),
    TypeInAllPartitions(type).

  VarInAllPartitions(var) :-
    Var_DeclaringMethod(var, inmethod),
    MethodInAllPartitions(inmethod).

  /// Base the decision on the partition of the target method
  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value,  valuetype),
    (TypeInAllPartitions(valuetype) ;
      (MethodInPrimaryPartition(tomethod),
       InvocationInPrimaryPartition(invo))),
    hctx = [hctxvalue],
    calleeCtx = [hctxvalue, value].

  ContextResponse(callerCtx, hctx, invo,value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value, valuetype),
    !MethodInPrimaryPartition(tomethod),
    !TypeInAllPartitions(valuetype),
    isImmutableContext(calleeCtx).

  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, tomethod),
    mainAnalysis.Value_Type(value, valuetype),
    MethodInPrimaryPartition(tomethod),
    !InvocationInPrimaryPartition(invo),
    !TypeInAllPartitions(valuetype),
    isImmutableContext(calleeCtx).

  // and for static methods
  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    (MethodInAllPartitions(tomethod);
      (MethodInPrimaryPartition(tomethod),
       InvocationInPrimaryPartition(invo))),
    calleeCtx = callerCtx.

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    !MethodInPrimaryPartition(tomethod),
    !MethodInAllPartitions(tomethod),
    isImmutableContext(calleeCtx).

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    MethodInPrimaryPartition(tomethod),
    !InvocationInPrimaryPartition(invo),
    !MethodInAllPartitions(tomethod),
    isImmutableContext(calleeCtx).

  ThreadStartContextResponse(callerCtx, hctx, value, newCtx) :-
    ThreadStartContextRequest(callerCtx, hctx, value),
    hctx = [hctxValue],
    newCtx = [hctxValue, value].

  StartupContextResponse(hctx, value, newCtx) :-
    StartupContextRequest(hctx, value),
    hctx = [hctxValue],
    newCtx = [hctxValue, value].

  FinalizerRegisterContextResponse(callerCtx, inmethod, value, newCtx) :-
    FinalizerRegisterContextRequest(callerCtx, inmethod, value),
    callerCtx = [callerCtxValue1, callerCtxValue2],
    newCtx = [callerCtxValue2, value],
    callerCtxValue1 = callerCtxValue1.

  InitContextResponse(value, ctx) :-
    InitContextRequest(value),
    ctx = [value, value].

  InitHContextResponse(value, hctx) :-
    InitHContextRequest(value),
    hctx = [value].

  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value, var),
    ctx = [ctxv1, ctxv2],
    (VarInPrimaryPartition(var);
     VarInAllPartitions(var)),
    hctx = [ctxv2],
    ctxv1 = ctxv1.

  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value, var),
    !VarInPrimaryPartition(var),
    ctx = [ctxv1, ctxv2],
    !VarInAllPartitions(var),
    isImmutableHContext(hctx),
    ctxv1 = ctxv1,
    ctxv2 = ctxv2.

  // Post-processing
  // ValidCtxVar(ctx, var) :-
  //   mainAnalysis.ReachableContext(ctx, meth),
  //   Method_DeclaringType(meth, intype),
  //   Var_DeclaringMethod(var, meth),
  //   ((!TypeToPartitionId(intype, _));
  //    (TypeToPartitionId(intype, partition),
  //     ctx = [partition, ctxv1, ctxv2],
  //     ctxv1 = ctxv1,
  //     ctxv2 = ctxv2)).

  // CollapsedVarPointsTo(hctx, heap, ctx, var) :-
  //   mainAnalysis.VarPointsTo(hctx, heap, ctx, var),
  //   ValidCtxVar(ctx, var).
}
