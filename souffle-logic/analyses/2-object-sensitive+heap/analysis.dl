#include "../../facts/flow-insensitive-schema.dl"
#include "../../facts/flow-sensitive-schema.dl"
#include "../../facts/to-flow-sensitive.dl"
#include "../../facts/import-facts.dl"
#include "../../facts/import-entities.dl"
#include "../../facts/post-process.dl"
#include "../../basic/basic.dl"
#include "../../basic/method-resolution.dl"
#include "../../basic/subclass.dl"
#include "../../basic/superinterface.dl"
#include "../../basic/type-hierarchy.dl"
#include "../../main/implicit-reachable.dl"
#include "../../main/class-initialization.dl"
#include "declarations.dl"


/*.type Type
.type Var 
.type MethodInvocation
.type MethodSignature
.type HeapAllocation
.type Field
.type Int
.type SimpleName
.type MethodDescriptor

.type Instruction = MethodInvocation
*/
// This part is specific to 2objH. 
.type Simple_Context = [ fst:HeapAllocation, snd:HeapAllocation]
.type Simple_HContext = HeapAllocation

#define RecordMacro(ctx, heap, hctx) \
   ctx=[fstsadfasd,sndaewrv], hctx = sndaewrv, fstsadfasd = fstsadfasd 
// last part is to avoid warning about var used once. Cannot be
// underscore here, sadly.
#define MergeMacro(callerCtx, invocation, hctx, heap, calleeCtx) \
   calleeCtx = [hctx,heap], callerCtx = callerCtx
// again, avoid warning
#define Simple_InitialContext(ctx) \
   ctx = ["<<initial-context>>","<<initial-context>>"]

/////////
// IDB //
/////////

// Declarations
.decl Reachable(?inMethod:Method)
.decl Simple_LocalAssign(?to:Var, ?from:Var) 
.decl Simple_Assign(?ctxTo:Simple_Context, ?to:Var, ?ctxFrom:Simple_Context, ?from:Var) 
.decl Simple_VarPointsTo(?hctx:Simple_HContext, ?heap:HeapAllocation, 
                         ?ctx:Simple_Context, ?var:Var) output
.decl Simple_FieldPointsTo(?hctx:Simple_HContext, ?heap:HeapAllocation, ?fld:Field,
                         ?baseHctx:Simple_HContext, ?baseheap:HeapAllocation)
.decl Simple_StaticFieldPointsTo(?hctx:Simple_HContext, ?heap:HeapAllocation, ?fld:Field)
.decl Simple_CallGraphEdge(?ctxInvo:Simple_Context, ?invocation:MethodInvocation, 
                         ?ctxMeth:Simple_Context, ?meth:Method) output
.decl Simple_ReachableContext(?ctx:Simple_Context, ?meth:Method) output
// also try without the two below
.decl Simple_StoreHeapInstanceField(?fld:Field, ?basehctx:Simple_HContext,
                         ?baseheap:HeapAllocation, ?ctx:Simple_Context, ?from:Var)
.decl Simple_LoadHeapInstanceField(?ctx: Simple_Context, ?to: Var, ?fld:Field, 
                         ?basehctx:Simple_HContext, ?baseheap:HeapAllocation) 


// Rules

// Intra-procedural assignment
Simple_LocalAssign(?to, ?from) :-
  AssignLocal(?from, ?to, _).

Simple_LocalAssign(?to, ?from) :-
  AssignCast(_, ?from, ?to, _).

Simple_VarPointsTo(?hctx, ?heap, ?ctx, ?to) :-
  Simple_VarPointsTo(?hctx, ?heap, ?ctx, ?from),
  Simple_LocalAssign(?to, ?from),
  HeapAllocation_Type(?heap, ?heaptype),
  Var_Type(?to, ?vartype),
  SubtypeOf(?heaptype, ?vartype).


// Inter-procedural assignment
Simple_Assign(?ctxMeth, ?formal, ?ctxInvo, ?actual) :-
  Simple_CallGraphEdge(?ctxInvo, ?invocation, ?ctxMeth, ?toMethod),
  FormalParam(?index, ?toMethod, ?formal),
  ActualParam(?index, ?invocation, ?actual).

Simple_Assign(?ctxInvo, ?local, ?ctxMeth, ?return) :-
  Simple_CallGraphEdge(?ctxInvo, ?invocation, ?ctxMeth, ?toMethod),
  ReturnVar(?return, ?toMethod),
  AssignReturnValue(?invocation, ?local).

Simple_VarPointsTo(?hctx, ?heap, ?toCtx, ?to) :-
  Simple_Assign(?toCtx, ?to, ?fromCtx, ?from),
  Simple_VarPointsTo(?hctx, ?heap, ?fromCtx, ?from).


// New object allocation
Simple_VarPointsTo(?hctx, ?heap, ?ctx, ?var) :-
  AssignHeapAllocation(?heap, ?var, ?inMethod),
  Simple_ReachableContext(?ctx, ?inMethod),
  RecordMacro(?ctx,?heap,?hctx).

// Heap: instance fields
Simple_StoreHeapInstanceField(?fld, ?basehctx, ?baseheap, ?ctx, ?from) :-
  StoreInstanceField(?from, ?base, ?fld, _),
  Simple_VarPointsTo(?basehctx, ?baseheap, ?ctx, ?base).

Simple_FieldPointsTo(?hctx, ?heap, ?fld, ?basehctx, ?baseheap) :-
  Simple_StoreHeapInstanceField(?fld, ?basehctx, ?baseheap, ?ctx, ?from),
  Simple_VarPointsTo(?hctx, ?heap, ?ctx, ?from).

Simple_LoadHeapInstanceField(?ctx, ?to, ?fld, ?basehctx, ?baseheap) :-
  LoadInstanceField(?base, ?fld, ?to, _),
  Simple_VarPointsTo(?basehctx, ?baseheap, ?ctx, ?base).

Simple_VarPointsTo(?hctx, ?heap, ?ctx, ?to) :-
  Simple_FieldPointsTo(?hctx, ?heap, ?fld, ?basehctx, ?baseheap),
  Simple_LoadHeapInstanceField(?ctx, ?to, ?fld, ?basehctx, ?baseheap).


// Heap: static fields
Simple_StaticFieldPointsTo(?hctx, ?heap, ?fld) :-
  StoreStaticField(?from, ?fld, _),
  Simple_VarPointsTo(?hctx, ?heap, _, ?from).

Simple_VarPointsTo(?hctx, ?heap, ?ctx, ?to) :-
  LoadStaticField(?fld, ?to, ?inmethod),
  Simple_ReachableContext(?ctx, ?inmethod),
  Simple_StaticFieldPointsTo(?hctx, ?heap, ?fld).


// Method calls
// Virtual:
Reachable(?inmethod),
Simple_CallGraphEdge(?ctxInvo, ?invocation, ?ctxMeth, ?toMethod)  :-
  Simple_VarPointsTo(?hctx, ?heap, ?ctxInvo, ?base),
  HeapAllocation_Type(?heap, ?heaptype),
  VirtualMethodInvocation_Base(?invocation, ?base),
  VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
  VirtualMethodInvocation_Descriptor(?invocation, ?descriptor),
  MethodLookup(?simplename, ?descriptor, ?heaptype, ?toMethod),
  Instruction_Method(?invocation, ?inmethod),
  MergeMacro(?ctxInvo, ?invocation, ?hctx, ?heap, ?ctxMeth).

Simple_VarPointsTo(?hctx, ?heap, ?ctxMeth, ?this) :-
  Simple_VarPointsTo(?hctx, ?heap, ?ctxInvo, ?base),
  HeapAllocation_Type(?heap, ?heaptype),
  VirtualMethodInvocation_Base(?invocation, ?base),
  VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
  VirtualMethodInvocation_Descriptor(?invocation, ?descriptor),
  MethodLookup(?simplename, ?descriptor, ?heaptype, ?toMethod),
  MergeMacro(?ctxInvo, ?invocation, ?hctx, ?heap, ?ctxMeth),
  ThisVar(?toMethod, ?this).

// Static:
Reachable(?inMethod),
Simple_CallGraphEdge(?ctxInvo, ?invocation, ?ctxInvo, ?toMethod) :-
  Simple_ReachableContext(?ctxInvo, ?inMethod),
  StaticMethodInvocation(?invocation, ?toMethod, ?inMethod).

// Special:
Reachable(?inmethod),
Simple_CallGraphEdge(?ctxInvo, ?invocation, ?ctxMeth, ?toMethod) :-
  MethodInvocation_Method(?invocation, ?toMethod),
  SpecialMethodInvocation_Base(?invocation, ?base),
  Simple_VarPointsTo(?hctx, ?heap, ?ctxInvo, ?base),
  Instruction_Method(?invocation, ?inmethod),
  MergeMacro(?ctxInvo, ?invocation, ?hctx, ?heap, ?ctxMeth).

Simple_VarPointsTo(?hctx, ?heap, ?ctxMeth, ?this) :-
  MethodInvocation_Method(?invocation, ?toMethod),
  SpecialMethodInvocation_Base(?invocation, ?base),
  Simple_VarPointsTo(?hctx, ?heap, ?ctxInvo, ?base),
  MergeMacro(?ctxInvo, ?invocation, ?hctx, ?heap, ?ctxMeth),
  ThisVar(?toMethod, ?this).


// Reachable contexts
Simple_ReachableContext(?ctx, ?method) :-
  Simple_CallGraphEdge(_, _, ?ctx, ?method).

// Context hack. Starts at initial on every method previously found
// reachable by regular VPT.
Simple_ReachableContext(?ctx, ?method) :-
  Reachable(?method),
  Simple_InitialContext(?ctx).

/**
 * Implicitly reachable methods are invoked by the JVM on startup.
 */
Reachable(?method) :-
    ImplicitReachable(?method).

/**
 * If a class needs to be initialized, then its class initializer is
 * invoked.
 *
 * Note that InitializedClass already deals with superclasses that
 * needs to be initialized as well, so we don't need to invoke class
 * initializers of the super class here.
 */
Reachable(?clinit) :-
   InitializedClass(?class),
   ClassInitializer(?class, ?clinit).