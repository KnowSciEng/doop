+LoadArrayIndex(?array, ?value, ?inmethod)/*,
+java:lang:reflect:Array:get(?invocation)*/ <-
  Method:Id(?sig:"<java.lang.reflect.Array: java.lang.Object get(java.lang.Object,int)>"),
  StaticMethodInvocation(?invocation, ?sig, ?inmethod),
  ActualParam@previous[0, ?invocation] = ?array,
  AssignReturnValue[?invocation] = ?value.

+StoreArrayIndex(?value, ?array, ?inmethod)/*,
+java:lang:reflect:Array:set(?invocation)*/ <-
  Method:Id(?sig:"<java.lang.reflect.Array: void set(java.lang.Object,int,java.lang.Object)>"),
  StaticMethodInvocation(?invocation, ?sig, ?inmethod),
  ActualParam@previous[0, ?invocation] = ?array,
  ActualParam@previous[2, ?invocation] = ?value.

/* == Proxy handling ==

   Java proxies are handled in two steps:

   1. For every interface, we create a dummy proxy class that will
      represent the type of objects returned by
      Proxy.newProxyInstance(). This proxy class is concrete and
      contains entry points for all methods declared in the interface
      it implements. All such methods are implemented as calls to the
      invoke() method of an InvocationHandler (which is passed to the
      constructor and stored in a local field).

   2. For every call to Proxy.newProxyInstance, such as the following:

        Object obj = Proxy.newProxyInstance(cl, is, h);   // e.g. instr. #4

      we generate facts as if we had seen the following code:

       // special proxy constructor variable
       Constructor c$interface$forName/#4;
       Object obj = c$interface$forName/#4.newInstance(h);

      Explanation: for every call to Proxy.newProxyInstance(), we
      generate a new constructor variable c. This special variable is
      connected by the analysis to the interfaces argument of
      newProxyInstance() via the VarPointsTo relation: whenever the
      interfaces argument can contain the class object of some
      interface I, then c is the constructor of the proxy class of I,
      e.g. 'Proxy$for$I' and thus the result of 'c.newInstance(h)'
      will be an object belonging to 'Proxy$for$I'.

   For more details on each step, see below.

   == Step 1: Dummy proxy class generation ==

   To see how the methods of the proxy class are implemented, assume
   that the proxy is for an interface I:

     interface I {
       void report(String c);
       int count();
     }

   Then, the following method bodies will have to be generated:

     public void report(String msg) {
         Method interfaceMethod = I$V$report$Ljava$lang$String;
         Object[] args = new Object[] {msg};
         ih.invoke(this, interfaceMethod, args);
     }

     public int count() {
         Method interfaceMethod = I$I$count$V;
         Object[] args = new Object[] { };
         return (Integer)ih.invoke(this, interfaceMethod, args);
     }

   Notes about the code above:

     - In the second method, we depend on implicitly unboxing the
       Integer result of the call to int. The cast to Integer is
       needed when the above is written as Java code.

     - The Method variables are supposed to be initialized with
       special values. In practice, our logic records the existence of
       these Method variables here and later (during reflection
       analysis) makes them point to the appropriate reified method
       objects.

     - In this delta, we do not create "return" instructions. We must
       model them directly in the reflection analysis ("the result of
       invoke() must flow into the return value of the proxied
       method").

*/

// For each 'interface' (with ID = 'interfaceId'), generate a
// 'proxyClassId'.
#define ProxiedInterfaceMacro(interface, interfaceId, proxyClassId) \
  InterfaceType@previous(interface), \
  Type:Id@previous(interface:interfaceId), \
  proxyClassId = "Proxy$for$" + interfaceId

// For a method named 'simple', with descriptor 'desc' and return type
// 'retType', generate a 'methodId' for a method to be declared inside
// 'proxyClassId'. Variables 'retTypeLen' and 'methodArgsSig' are
// reserved for this macro.
#define CalcMethodId(proxyClassId, retType, simple, desc, methodId) \
   string:length[retType] = retTypeLen, \
   string:substring[desc, retTypeLen, string:length[desc] - retTypeLen] = methodArgsSig, \
   methodId = "<" + proxyClassId + ": " + retType + " " + simple + methodArgsSig + ">"

// For a method inside a proxy class, generate IDs for the method
// variable, the Method.invoke() instruction, and the return
// instruction.
#define ProxyMethodMacro(methodId, proxyClassId, methodVarId, invokeId, retInstrId) \
   methodVarId = methodId + "$method", \
   invokeId = proxyClassId + "/" + methodVarId + "/0", \
   retInstrId = invokeId + "/return/0"

// Create declaration of proxy class.
+Type:Id(?proxyClass:?proxyClassId), +ProxyClass(?proxyClass),
+DirectSuperinterface(?proxyClass, ?interface),
// Create public constructor method.
+Method:Id(?constructor:?constructorId), +Method(?constructor),
+Method:DeclaringType[?constructor] = ?proxyClass,
+Method:SimpleName[?constructor] = "<init>",
+Method:ReturnType[?constructor] = Type:void@previous[],
+Method:Descriptor[?constructor] = "void(java.lang.reflect.InvocationHandler)",
+Method:JVMDescriptor[?constructor] = "(Ljava/lang/reflect/InvocationHandler;)V",
+Method:Modifier(?public, ?constructor),
// Create invocation handler field.
+Field:Id(?fieldIHandler:?fieldIHandlerId), +Field(?fieldIHandler),
+Field:DeclaringType[?fieldIHandler] = ?proxyClass,
+Field:SimpleName[?fieldIHandler] = "h",
+Field:Type[?fieldIHandler] = ?invocationHandlerType,
+Field:Modifier(?private, ?fieldIHandler)
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   // Proxy class constructor.
   ?constructorId = "<" + ?proxyClassId + ": void <init>(java.lang.reflect.InvocationHandler)>",
   // Field containing an InvocationHandler.
   Type:Id@previous(?invocationHandlerType:"java.lang.reflect.InvocationHandler"),
   ?fieldIHandlerId = ?proxyClassId + "$h",
   Modifier:Id@previous(?public:"public"),
   Modifier:Id@previous(?private:"private").

+Type:Id(?proxyClass:?proxyClassId), +ProxyClass(?proxyClass),
// For each proxy class of interface I, for every method m of I,
// generate a public method with the same signature and return type in
// the proxy class. The body of the method will call the invoke()
// method of the InvocationHandler object with the correct arguments.
+Method:Id(?method:?methodId), +Method(?method),
+Method:DeclaringType[?method] = ?proxyClass,
+Method:ReturnType[?method] = ?retType,
+Method:Descriptor[?method] = ?desc,
+Method:SimpleName[?method] = ?simple,
+Method:JVMDescriptor[?m] = ?jvmDesc,
// Here we create the variables that contain the Method object, and
// the arguments list. We will assign values to them later, in the
// analysis.
+Var:Id(?methodVar:?methodVarId), +Var(?methodVar),
+Var:Type[?methodVar] = ?methodType,
+Var:Id(?argsVar:?argsVarId), +Var(?argsVar),
+Var:Type[?argsVar] = ?argsType,
// Create the 'this' variable.
+Var:Id(?thisVar:?thisVarId), +Var(?thisVar),
+Var:Type[?thisVar] = ?proxyClass,
+ThisVar[?method] = ?thisVar,
// Create instruction 'Object[] args = new Object[]'.
+Instruction:Id(?createArgs:?createArgsId), +AssignHeapAllocation:Insn(?createArgs),
+Instruction:Index[?createArgs] = 3, +Instruction:Method[?createArgs] = ?method,
// Create heap object for Object[] arguments.
+HeapAllocation0:Normal(?argsNewId, ?argsType),
+AssignHeapAllocation0(?createArgs, ?argsNewId),
// Create the call to InvocationHandler.invoke().
+StaticMethodInvocation:Insn(?invoke), +Instruction:Id(?invoke:?invokeId),
+Instruction:Index[?invoke] = 4, +Instruction:Method[?invoke] = ?method,
+StaticMethodInvocation:SimpleName[?invoke] = "invoke",
+StaticMethodInvocation:Descriptor[?invoke] = "java.lang.Object(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])",
+MethodInvocation:Signature[?invoke] = "<java.lang.reflect.InvocationHandler: java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])>",
+ActualParam[0, ?invoke] = ?thisVar,
+ActualParam[1, ?invoke] = ?methodVar,
+ActualParam[2, ?invoke] = ?argsVar,
// Create the return instruction.
+Instruction:Id(?retInstr:?retInstrId), +Instruction(?retInstr),
// Register the proxy method, to find it later in the analysis.
+ProxyMethod(?method, ?m, ?methodVar, ?argsVar, ?argsNewId, ?invoke)
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   Method:DeclaringType@previous[?m] = ?interface,
   Method:ReturnType@previous[?m] = ?retType,
   Method:Descriptor@previous[?m] = ?desc,
   Method:SimpleName@previous[?m] = ?simple,
   Method:JVMDescriptor@previous[?m] = ?jvmDesc,
   CalcMethodId(?proxyClassId, ?retType, ?simple, ?desc, ?methodId),
   Type:Id@previous(?methodType:"java.lang.reflect.Method"),
   ?argsVarId = ?methodId + "$args",
   Type:Id@previous(?argsType:"java.lang.Object[]"),
   ProxyMethodMacro(?methodId, ?proxyClassId, ?methodVarId, ?invokeId, ?retInstrId),
   ?argsNewId = ?methodId + "/args",
   ?thisVarId = ?methodId + "/this",
   ?createArgsId = ?argsVarId + "/create"
.

// For proxied methods that have a non-void return type, we also
// create a variable to hold the return value of Method.invoke().
+Var:Id(?retVar:?retVarId), +Var(?retVar),
+Var:Type[?retVar] = ?retType,
// A bit redundancy here.
+Method:Id(?method:?methodId), +Method(?method),
+Instruction:Id(?invoke:?invokeId), +Instruction(?invoke),
+Instruction:Id(?retInstr:?retInstrId), +Instruction(?retInstr),
+StaticMethodInvocation(?invoke, "<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>", ?method),
+StaticMethodInvocation:Insn(?invoke),
// Register the return value connection.
+AssignReturnValue[?invoke] = ?retVar,
+ReturnNonvoid:Insn(?retInstr), +ReturnNonvoid:Var[?retInstr] = ?retVar
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   Method:DeclaringType@previous[?m] = ?interface,
   Method:ReturnType@previous[?m] = ?retType,
   Method:SimpleName@previous[?m] = ?simple,
   Method:Descriptor@previous[?m] = ?desc,
   ?voidType = Type:void@previous[],
   Type:Id@previous(?voidType:?voidTypeId),
   ?retType != ?voidTypeId,
   CalcMethodId(?proxyClassId, ?retType, ?simple, ?desc, ?methodId),
   ?retVarId = ?methodId + "/returnValue",
   ProxyMethodMacro(?methodId, ?proxyClassId, ?methodVarId, ?invokeId, ?retInstrId)
.

// For proxied methods returning void, create the return instruction.
// A bit redundancy here.
// +Method:Id(?method:?methodId), +Method(?method),
// +Instruction:Id(?invoke:?invokeId), +Instruction(?invoke),
+Instruction:Id(?retInstr:?retInstrId), +Instruction(?retInstr),
+ReturnVoid:Insn(?retInstr)
 <-
   ProxiedInterfaceMacro(?interface, ?interfaceId, ?proxyClassId),
   Method:DeclaringType@previous[?m] = ?interface,
   Method:ReturnType@previous[?m] = ?retType,
   Method:SimpleName@previous[?m] = ?simple,
   Method:Descriptor@previous[?m] = ?desc,
   ?voidType = Type:void@previous[],
   Type:Id@previous(?voidType:?voidTypeId),
   ?retType = ?voidTypeId,
   CalcMethodId(?proxyClassId, ?retType, ?simple, ?desc, ?methodId),
   ProxyMethodMacro(?methodId, ?proxyClassId, ?methodVarId, ?invokeId, ?retInstrId)
.

/* == Step 2: Transformation of Proxy.newProxyInstance() ==

   This step generates the new constructor variable and records
   information for the reflection analysis to connect the dots.

   Notes:

   - In Java, java.lang.reflect.Constructor.newInstance() takes
     varargs (Object... ); these are implemented as Object[] arrays in
     Jimple. Thus, this code:

       Object obj = c.newInstance(h);

     should be expressed as:

       Object cArgs = new Object[];
       cArgs[0] = h;
       Object obj = c.newInstance(cArgs);

     The above contains two variables and a heap allocation (that are
     to be created in this delta) and an assignment that is filled in
     later by the analysis.

*/

// Generate the new constructor variable 'c'.
+Var(?c), +Var:Id(?c:?cId), +Var:Type[?c] = ?constructorType,
// Generate the new constructor arguments 'cArgs'.
+Var(?cArgs), +Var:Id(?cArgs:?cArgsId), +Var:Type[?cArgs] = ?cArgsType,
// +java:lang:reflect:Constructor:newInstance(?newInstanceInstr, ?obj, ?c),
// The heap allocation of 'cArgs'.
+Instruction:Id(?cArgsInstr:?cArgsInstrId),
+AssignHeapAllocation:Insn(?cArgsInstr),
+HeapAllocation0:Normal(?cArgsNewId, ?cArgsType),
+AssignHeapAllocation0(?cArgsInstr, ?cArgsNewId),
// The 'c.newInstance(cArgs)' instruction.
+Instruction:Id(?newInstanceInstr:?newInstanceInstrId),
+VirtualMethodInvocation:Insn(?newInstanceInstr),
+VirtualMethodInvocation:Base[?newInstanceInstr] = ?c,
+VirtualMethodInvocation:SimpleName[?newInstanceInstr] = "newInstance",
+VirtualMethodInvocation:Descriptor[?newInstanceInstr] = "java.lang.Object(java.lang.Object[])",
// Record the new facts about the Proxy.newProxyInstance() call.
+ProxiedInterfaceForName(?i, ?c, ?cArgs, ?interfaces, ?h, ?obj)
 <-
   // This identifies the call to Proxy.newProxyInstance(), to
   // populate the ProxiedInterfaceForName relation.
   StaticMethodInvocation:SimpleName@previous[?i] = "newProxyInstance",
   StaticMethodInvocation@previous(?i, ?sig, _),
   ?sig = "<java.lang.reflect.Proxy: java.lang.Object newProxyInstance(java.lang.ClassLoader,java.lang.Class[],java.lang.reflect.InvocationHandler)>",
   Instruction:Id@previous(?i:?id),
   ?s = "interface$forName/" + ?id,
   ActualParam@previous[1, ?i] = ?interfaces,
   ActualParam@previous[2, ?i] = ?h,
   AssignReturnValue@previous[?i] = ?obj,
   // Constructor variable and instruction.
   ?cId = ?s + "/c",
   ?cArgsId = ?s + "/cArgs",
   ?cArgsNewId = ?s + "/cArgsNew",
   ?cArgsInstrId = ?s + "/cArgsInstr",
   ?newInstanceInstrId = ?cId + "/instr",
   Type:Id@previous(?cArgsType:"java.lang.Object[]"),
   Type:Id@previous(?constructorType:"java.lang.reflect.Constructor")
.
