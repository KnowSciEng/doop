/*************************************************************
 * MethodHandle constants
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
   isMethodHandleConstant(?heap).

#define LAMBDA_METAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"

#define LAMBDA_ALTMETAFACTORY_ID "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>"

// Find invocations to the lambda metafactories.
.decl LambdaMetafactoryInvoke(?invo:MethodInvocation, ?dynName:symbol, ?interface:InterfaceType)
LambdaMetafactoryInvoke(?invo, ?dynName, ?interface) :-
   DynamicMethodInvocation_Bootstrap(?invo, ?method),
   (?method = LAMBDA_METAFACTORY_ID ; ?method = LAMBDA_ALTMETAFACTORY_ID),
   DynamicMethodInvocation_DynName(?invo, ?dynName),
   DynamicMethodInvocation_DynReturnType(?invo, ?interface).

// Method references are wrapped by calling invokedynamic with
// boostrap method being the lambda metafactory and the second
// bootstrap argument being a constant method handle. The result
// 'value' of the invokedynamic is a lambda, which contains an
// instance method calling static method 'realMethod'.

#define MHDesc(type, method, real, ret, name) \
   cat("reference ", cat(type, cat ("::", cat(method, cat(" from ", cat(real, cat(" wrapped as ", cat(ret, cat(".", name)))))))))

#define MHValue(invo, ret, desc) \
   cat(invo, cat("::: ", cat(ret, cat("::: (Mock)::: ", desc))))

.decl ConstantMethodHandleLambda(?value:Value, ?dynName:symbol, ?dynRet:Type, ?realMethod:Method)

// Intermediate relation to make rules easier to read.
.decl ConstantMHLambdaVPT(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var, ?interface:InterfaceType, ?dynName:symbol, ?realMethod:Method)

InvokedynamicBootstrapCtx(?invo, ?ctx),
ConstantMHLambdaVPT(?hctx, MHValue(?invo, ?interface, MHDesc(?handleType, ?handleMeth, ?realMethod, ?interface, ?dynName)), ?ctx, ?var, ?interface, ?dynName, ?realMethod) :-
   BootstrapParam(1, ?invo, ?handleVar),
   LambdaMetafactoryInvoke(?invo, ?dynName, ?interface),
   VarPointsTo(?hctx, ?handleVal, ?ctx, ?handleVar),
   MethodHandleConstant_Method(?handleVal, ?realMethod),
   isInterfaceType(?interface),
   AssignReturnValue(?invo, ?var),
   // Used to generate friendly description for the generated wrapper.
   Method_SimpleName(?realMethod, ?handleMeth),
   Method_DeclaringType(?realMethod, ?handleType).

// Unpack the information gathered above and populate appropriate relations.
VarPointsTo(?hctx, ?value, ?ctx, ?var),
MockValueConsMacro(?value, ?interface),
ConstantMethodHandleLambda(?value, ?dynName, ?interface, ?realMethod) :-
   ConstantMHLambdaVPT(?hctx, ?value, ?ctx, ?var, ?interface, ?dynName, ?realMethod).

.decl InvokedynamicBootstrapCtx(?invo:DynamicMethodInvocation_Insn, ?ctx:configuration.Context)

// Record invokedynamic invocations whose bootstrap methods are not
// handled at all.
.decl UnhandledInvokedynamic(?i:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)

UnhandledInvokedynamic(?i, ?bootMethodId) :-
   DynamicMethodInvocation_Bootstrap(?i, ?bootMethodId),
   !LambdaMetafactoryInvoke(?i, _, _).

// When invokeinterface is called on a lambda object constructed by a
// constant method handle, the real method is called. This can wrap a
// static method call as an instance method call. We create two call
// graph edges: (1) invokeinterface on the method handle lambda calls
// the real method and (2) invokedynamic calls the bootstrap method.

.decl InvokedynamicCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method)

InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?realMethod) :-
   ConstantMethodHandleLambda(?value, ?dynName, _, ?realMethod),
   VarPointsTo(_, ?value, ?callerCtx, ?var),
   VirtualMethodInvocation_Base(?i, ?var),
   VirtualMethodInvocation_SimpleName(?i, ?dynName),
   isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
   InvokedynamicCallGraphEdge(_, _, ?calleeCtx, ?callee).

.decl InvokedynamicMetafactoryCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?metafactory:Method)
InvokedynamicMetafactoryCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?metafactory) :-
   LambdaMetafactoryInvoke(?i, _, _),
   DynamicMethodInvocation_Bootstrap(?i, ?metafactory),
   isImmutableContext(?calleeCtx),
   InvokedynamicBootstrapCtx(?i, ?callerCtx).

ReachableContext(?calleeCtx, ?callee) :-
   InvokedynamicMetafactoryCallGraphEdge(_, _, ?calleeCtx, ?callee).

// Pass arguments to underlying method.
VarPointsTo(?hctx, ?val, ?ctx, ?formal) :-
   InvokedynamicCallGraphEdge(_, ?i, ?ctx, ?realMethod),
   FormalParam(?idx, ?realMethod, ?formal),
   ActualParam(?idx, ?i, ?actual),
   VarPointsTo(_, ?val, _, ?actual),
   isImmutableHContext(?hctx).

// Handle return values.
VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret) :-
   InvokedynamicCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?realMethod),
   ReturnVar(?realReturnVar, ?realMethod),
   VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?realReturnVar),
   AssignReturnValue(?i, ?ret).

// Pass arguments to bootstrap methods.
VarPointsTo(?hctx, ?val, ?ctx, ?formal) :-
   InvokedynamicMetafactoryCallGraphEdge(_, ?i, ?ctx, ?metafactory),
   FormalParam(?idx, ?metafactory, ?formal),
   BootstrapParam(?idx, ?i, ?actual),
   VarPointsTo(_, ?val, _, ?actual),
   isImmutableHContext(?hctx).

.decl Lambda_Method(?value:Value, ?realMethod:Method)
Lambda_Method(?value, ?realMethod) :-
   ConstantMethodHandleLambda(?value, _, _, ?realMethod).

.decl ConstructorReference(?var:Var, ?value:Value, ?i:MethodInvocation, ?realMethod:Method)

// Applications of constructor references construct values. However,
// these values do not come from a 'new' instruction in the code but
// are created here as special values, one per type.

#define ConstructorReferenceValue(type) cat(type, "::: (Mock)")

VarPointsTo(?hctx, ConstructorReferenceValue(?type), ?ctx, ?var),
ConstructorReference(?var, ConstructorReferenceValue(?type), ?i, ?realMethod),
MockValueConsMacro(ConstructorReferenceValue(?type), ?type) :-
   VarPointsTo(?hctx, ?baseVal, ?ctx, ?base),
   VirtualMethodInvocation_Base(?i, ?base),
   Lambda_Method(?baseVal, ?realMethod),
   Method_SimpleName(?realMethod, "<init>"),
   Method_DeclaringType(?realMethod, ?type),
   AssignReturnValue(?i, ?var).

// Method handles usually need reflection except they come from the constant pool.
.decl MethodHandle_Method(?mh:Value, ?method:Method)
.decl isMethodHandle(?mh:Value)

isMethodHandle(?mh),
MethodHandle_Method(?mh, ?method) :-
   MethodHandleConstant_Method(?mh, ?method).

// Method handles that interact with reflection are exprerimental, use
// corresponding command-line option to enable them.
#ifdef REFLECTION_METHOD_HANDLES

// We treat method descriptors as MethodType values (with slight
// changes, e.g. in the treatment of 'void' or constructors).

.decl MethodType_ReturnType(?descriptor:symbol, ?declType:Type, ?rType:Type)

// Return types for non-constructors.
MethodType_ReturnType(?descriptor, ?declType, ?rType) :-
  Method_Descriptor(?method, ?descriptor),
  Method_ReturnType(?method, ?rType),
  Method_SimpleName(?method, ?name),
  ?name != "<clinit>",
  ?name != "<init>",
  Method_DeclaringType(?method, ?declType).

// Return types for constructors are not "void" but the type constructed.
MethodType_ReturnType(?descriptor, ?rType, ?rType) :-
  Method_Descriptor(?method, ?descriptor),
  Method_SimpleName(?method, "<init>"),
  Method_DeclaringType(?method, ?rType).

.decl MethodType_ParamType(?descriptor:symbol, ?index:number, ?pType:Type)

MethodType_ParamType(?descriptor, ?index, ?pType) :-
  Method_Descriptor(?method, ?descriptor),
  FormalParam(?index, ?method, ?var),
  _Var_Type(?var, ?pType).

#ifdef REFLECTION

// MethodType API entry points. The actual logic: every methodType()
// invocation picks all descriptors that match.

.decl ReachableMethodTypeN(?invo:MethodInvocation, ?caller:Method, ?callerCtx:configuration.Context)

ReachableMethodTypeN(?invo, ?caller, ?callerCtx) :-
   MTEntryPoint(_, ?invo, _),
   Instruction_Method(?invo, ?caller),
   ReachableContext(?callerCtx, ?caller).

.decl MT_ReturnType(?invo:MethodInvocation, ?type:Type)
.decl MT_ParamValue(?invo:MethodInvocation, ?index:number, ?classValue:Value)

// The first argument to methodType() is always the return type.
MT_ReturnType(?invo, ?type) :-
   ReachableMethodTypeN(?invo, _, _),
   ActualParam(0, ?invo, ?param),
   VarPointsTo(_, ?classValue, _, ?param),
   ReifiedClass(?type, ?classValue).

// MethodType2, MethodType4: second parameter.
MT_ParamValue(?invo, 0, ?classValue) :-
   ( MTEntryPoint(2, ?invo, _) ; MTEntryPoint(4, ?invo, _) ),
   Instruction_Method(?invo, ?caller),
   ReachableContext(_, ?caller),
   ActualParam(1, ?invo, ?param),
   VarPointsTo(_, ?classValue, _, ?param).

// MethodType1 lacks a parameter, so we use a dummy value instead.
#define MT_NOARGS_VALUE "<mock dummy methodType() class for first argument>"
MockValueConsMacro(MT_NOARGS_VALUE, "java.lang.Class"),
MT_ParamValue(?invo, 0, MT_NOARGS_VALUE) :-
   MTEntryPoint(1, ?invo, _).

// Helper relation to treat 'void' and 'java.lang.Void' as the same
// type in descriptors.
.decl MTReturnTypeMatchesDescriptor(?invo:MethodInvocation, ?descriptor:symbol)

MTReturnTypeMatchesDescriptor(?invo, ?descriptor) :-
   MT_ReturnType(?invo, "java.lang.Void"),
   MethodType_ReturnType(?descriptor, _, "void").
MTReturnTypeMatchesDescriptor(?invo, ?descriptor) :-
   MT_ReturnType(?invo, ?rType),
   MethodType_ReturnType(?descriptor, _, ?rType).

.decl Descriptor_Arity(?descriptor:symbol, ?arity:number)

Descriptor_Arity(?descriptor, ?arity) :-
  Method_Descriptor(?method, ?descriptor),
  Method_Arity(?method, ?arity).

.decl MTCallMatchesDescriptor(?invo:MethodInvocation, ?descriptor:symbol)

// MethodType1.
MTCallMatchesDescriptor(?invo, ?descriptor) :-
   MTEntryPoint(1, ?invo, _),
   MTReturnTypeMatchesDescriptor(?invo, ?descriptor),
   MT_ParamValue(?invo, 0, MT_NOARGS_VALUE),
   Descriptor_Arity(?descriptor, 0).

// MethodType2.
MTCallMatchesDescriptor(?invo, ?descriptor) :-
   MTEntryPoint(2, ?invo, _),
   MTReturnTypeMatchesDescriptor(?invo, ?descriptor),
   MT_ParamValue(?invo, 0, ?classValue0),
   ReifiedClass(?pType0, ?classValue0),
   MethodType_ParamType(?descriptor, 0, ?pType0),
   Descriptor_Arity(?descriptor, 1).

.decl MTValue_Descriptor(?mt:Value, ?descriptor:symbol)

#define MT_VALUE(desc) cat("<mock MethodType ", cat(desc, ">"))

// Make methodType() return special descriptors.
MockValueConsMacro(MT_VALUE(?descriptor), "java.lang.invoke.MethodType"),
MTValue_Descriptor(MT_VALUE(?descriptor), ?descriptor),
VarPointsTo(?hctx, MT_VALUE(?descriptor), ?callerCtx, ?ret) :-
   ReachableMethodTypeN(?invo, ?caller, ?callerCtx),
   MTCallMatchesDescriptor(?invo, ?descriptor),
   AssignReturnValue(?invo, ?ret),
   isImmutableHContext(?hctx).

// Method lookup methods.

.decl FindVirtual(?invo:MethodInvocation)

FindVirtual(?invo) :-
   MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>"),
   Instruction_Method(?invo, ?caller),
   ReachableContext(_, ?caller).

.decl FindStatic(?invo:MethodInvocation)

FindStatic(?invo) :-
   MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>"),
   Instruction_Method(?invo, ?caller),
   ReachableContext(_, ?caller).

// Lookup rules.

.decl MethodFinder(?invo:MethodInvocation, ?ret:Var)

MethodFinder(?invo, ?ret) :-
   ( FindStatic(?invo) ; FindVirtual(?invo) ),
   VirtualMethodInvocation_Base(?invo, ?lookup),
   VarPointsTo(_, ?baseVal, _, ?lookup),
   !Value_Null(?baseVal),
   AssignReturnValue(?invo, ?ret).

.decl MHLookup(?type:Type, ?id:symbol, ?mt:Value, ?method:Method)

MHLookup(?type, ?id, ?mt, ?method) :-
   Method_DeclaringType(?method, ?type),
   Method_SimpleName(?method, ?id),
   Method_Descriptor(?method, ?descriptor),
   MTValue_Descriptor(?mt, ?descriptor).

// Mock method handle values.
#define MH(meth) cat("<computed method handle for ", cat(meth, ">"))

MockValueConsMacro(MH(?method), "java.lang.invoke.MethodHandle"),
isMethodHandle(MH(?method)),
MethodHandle_Method(MH(?method), ?method),
VarPointsTo(?hctx, MH(?method), ?ctx, ?ret) :-
   MethodFinder(?invo, ?ret),
   ActualParam(0, ?invo, ?classParam),
   VarPointsTo(?hctx, ?classValue, ?ctx, ?classParam),
   ReifiedClass(?type, ?classValue),
   ActualParam(1, ?invo, ?stringParam),
   VarPointsTo(_, ?id, _, ?stringParam),
   ActualParam(2, ?invo, ?mtParam),
   VarPointsTo(_, ?mt, _, ?mtParam),
   MHLookup(?type, ?id, ?mt, ?method).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES
