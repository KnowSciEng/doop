/*************************************************************
 * Special objects
 *
 * Some objects are so common that they heavily impact performance if
 * every allocation is distinguished or a context-sensitive heap
 * abstraction is used. In many cases, this precision is not actually
 * useful for a points-to analysis, so handling them in a less precise
 * way is beneficial.
 *************************************************************/

/**
 * Join with AssignHeapAllocation for performance.
 */
.decl HeapAllocation_Special(?heap:HeapAllocation)

HeapAllocation_Special(?heap) :-
    HeapAllocation_ContextInsensitive(?heap).

HeapAllocation_Special(?heap) :-
    HeapAllocation_Merge(?heap, _).


/**
 * Objects that should use a context-insensitive heap abstraction.
 */
.decl HeapAllocation_ContextInsensitive(?heap:HeapAllocation)

/**
 * Objects that should be merged to some heap abstraction
 * (will overlap with merely context-insensitive objects)
 */
.decl HeapAllocation_Merge(?heap:HeapAllocation, ?mergeHeap:HeapAllocation)

// The ones that absolutely have to be kept distinct
.decl HeapAllocation_Keep(?heap:HeapAllocation)

/**
 * This is the handling for objects that are explicitly allocated in
 * the program text. There will also be other objects: pseudo objects
 * (null, string-constant), reified reflection objects, string
 * constants that the analysis thought are safe to merge, yet they do
 * arise reflectively, etc.
 */
AssignNormalHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  ! HeapAllocation_Special(?heap).

AssignContextInsensitiveHeapAllocation(?mergeHeap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_Merge(?heap, ?mergeHeap).

AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_ContextInsensitive(?heap),
  !(HeapAllocation_Merge(?heap, _)). // should be mostly unnecessary, but has bitten us many times


/*************************************************************
 * Special handling for all sorts of objects. All potential
 * representatives of an object are examined, and one is picked
 * for merging. The idea is to make the rest of the logic flexible:
 * signal as many reasons as apply for merging an object with
 * others and then have a single point in the code that decides
 * which merging is best.
 *************************************************************/

// If the object is a string that should be merged, ignore other
// representatives and merge with that.
.decl HeapRepresentative(?heap:HeapAllocation, ?heapRepr:symbol)

HeapAllocation_Merge(?heap, ?heapRepr) :-
  HeapRepresentative(?heapRepr, ?heap),
  ?heapRepr = "<<string-constant>>",
  isHeapAllocation(?heapRepr).

.decl HeapIsMergedStringFactory(?heap:HeapAllocation)

HeapIsMergedStringFactory(?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  (isHeapAllocation(?heapRepr),
     ?heapRepr = "<<string-buffer>>";
     isHeapAllocation(?heapRepr),
     ?heapRepr = "<<string-builder>>").

HeapAllocation_Merge(?heap, ?heapRepr) :-
  HeapRepresentative(?heapRepr, ?heap),
  (isHeapAllocation(?heapRepr),
   ?heapRepr = "<<string-buffer>>";
   isHeapAllocation(?heapRepr),
   ?heapRepr = "<<string-builder>>").

.decl RepresentativesToPickFrom(?heapRepr:HeapAllocation, ?heap:HeapAllocation)
.decl RepresentativesToPickFromOrdinals(?heapReprOrd:number, ?heap:HeapAllocation)

RepresentativesToPickFrom(?heapRepr, ?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  !isStringConstant(?heap),
  !HeapIsMergedStringFactory(?heap),
  !HeapAllocation_Keep(?heap).

RepresentativesToPickFromOrdinals(ord(?heapRepr), ?heap) :-
    RepresentativesToPickFrom(?heapRepr, ?heap).

.decl MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd:number, ?heap:HeapAllocation)

MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap) :-
    RepresentativesToPickFromOrdinals(_, ?heap),
    ?minHeapReprOrd = min ?heapReprOrd: RepresentativesToPickFromOrdinals(?heapReprOrd, ?heap).

HeapAllocation_Merge(?heap, ?mergeHeap) :-
    isHeapAllocation(?mergeHeap),
    ord(?mergeHeap) = ?minHeapReprOrd,
    MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap).

/*************************************************************
 * String constants
 *************************************************************/

.decl ReflectionStringConstant(?heap:HeapAllocation)
.decl ReflectionSubstringObject(?heap:HeapAllocation)

#ifndef DISTINGUISH_ALL_STRING_CONSTANTS
#ifndef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS
#define DISTINGUISH_NO_STRING_CONSTANTS
HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  ?constant = "<<string-constant>>",
  isHeapAllocation(?constant),
  !HeapAllocation_Keep(?heap).
#endif
#endif // DISTINGUISH_NO_STRING_CONSTANTS mode

#ifdef DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS
ReflectionStringConstant(?heap) :-
  ClassNameMatchingStringConstant(?heap);
  MethodNameMatchingStringConstant(?heap);
  FieldNameMatchingStringConstant(?heap).

ReflectionSubstringObject(?heap) :-
  ClassNameMatchingStringConstantInexact:Type(_,?heap);
  MethodNameMatchingStringConstantInexact:Signature(_,?heap);
  FieldNameMatchingStringConstantInexact:Signature(_,?heap).

HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  !ReflectionStringConstant(?heap),
  HeapAllocation_byId["<<string-constant>>"] = ?constant,
  !HeapAllocation_Keep(?heap).
#endif // DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS

HeapAllocation_ContextInsensitive(?heap) :-
  isStringConstant(?heap),
  !HeapRepresentative(_, ?heap).



/*************************************************************
 * Class constants
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  isClassHeap(?heap).

/*************************************************************
 * Merging allocation sites per method, per class, or per package.
 *************************************************************/

// Per-method merging: auto-merge allocation sites for method that
// allocates many objects of same type. Also, enable other rules to
// explicitly ask for per-method merging, beyond the above heuristic
// (by setting "...ShouldBeMerged...").

.decl MethodAllocationMergeThreshold(?t:number)
MethodAllocationMergeThreshold(50).

.decl ExceptionType(?type:Type)

ExceptionType(?type) :-
  ?throw = "java.lang.Throwable",
  isType(?throw),
  SubtypeOf(?type, ?throw).

.decl OptAssignHeapAllocation(?inmethod:Method, ?heap:HeapAllocation)

OptAssignHeapAllocation(?inmethod, ?heap) :-
  AssignHeapAllocation(?heap, _, ?inmethod).

// There are objects, like strings, null, and class objects, that
// don't have a unique allocation site.
.decl ObjectMultipleAllocated(?heap:HeapAllocation)

ObjectMultipleAllocated(?heap) :-
  OptAssignHeapAllocation(?inmethod1, ?heap),
  OptAssignHeapAllocation(?inmethod2, ?heap),
  ?inmethod1 != ?inmethod2.

.decl MethodAndTypeToHeap(?heap:HeapAllocation, ?heapType:Type, ?method:Method)
.decl StringFactoryHeap(?heap:HeapAllocation)

MethodAndTypeToHeap(?heap, ?heaptype, ?meth) :-
  AssignHeapAllocation(?heap, _, ?meth),
  HeapAllocation_Type(?heap, ?heaptype),
  !isStringConstant(?heap),
  !StringFactoryHeap(?heap),
  !HeapAllocation_EmptyArray(?heap),
  !ObjectMultipleAllocated(?heap),
  !HeapAllocation_Keep(?heap).

.decl AllocationsPerMethodAndType(?type:Type, ?meth:Method, ?n:number)

AllocationsPerMethodAndType(?type, ?meth, ?n) :-
  MethodAndTypeToHeap(_, ?type, ?meth),
  ?n = count : MethodAndTypeToHeap(_, ?type, ?meth).

.decl AllocationShouldBeMergedPerMethod(?heaptype:Type, ?meth:Method)

AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  ?n > ?t,
  MethodAllocationMergeThreshold(?t).

.decl MethodAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?meth:Method)
.decl MethodAndTypeToMergedHeapOrdinal(?heap:number, ?heaptype:Type, ?meth:Method)

MethodAndTypeToMergedHeapOrdinal(ord(?heap), ?type, ?meth) :-
    MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

MethodAndTypeToMergedHeap(?heap, ?heaptype, ?meth) :-
  AllocationShouldBeMergedPerMethod(?heaptype, ?meth),
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth).

.decl MethodAndTypeToRepresentative(?type:Type, ?meth:Method, ?reprHeap:HeapAllocation)
.decl MinHeapOrdinalPerMethodAndType(?ord:number, ?type:Type, ?meth:Method)

MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth) :-
    MethodAndTypeToMergedHeapOrdinal(_, ?type, ?meth),
    ?minHeapOrd = min ?heapOrd: MethodAndTypeToMergedHeapOrdinal(?heapOrd, ?type, ?meth).

MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth),
  ord(?representativeHeap) = ?minHeapOrd.


/* TODO: Check if the following works too with some minor modifications
  MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap) :-
     isHeapAllocation(?representativeHeap),
     MethodAndTypeToMergedHeap(_, ?type, ?meth),
     ord(?representativeHeap) = min ord(?heap): {MethodAndTypeToMergedHeap(?heap, ?type, ?meth)}.
 */

HeapRepresentative(?representativeHeap, ?heap) :-
  MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap),
  MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

// Now, per-class merging. This is more rare and should be requested
// explicitly for a given type. Again, does not apply to types with
// special merging policies.
.decl ClassAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:ClassType)
.decl AllocationsPerClassAndType(?type:Type, ?class:ClassType, ?n:number)

ClassAndTypeToHeap(?heap, ?heaptype, ?class) :-
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth),
  Method_DeclaringType(?meth, ?class).

AllocationsPerClassAndType(?type, ?class, ?n) :-
  ClassAndTypeToHeap(_, ?type, ?class),
  ?n = count : ClassAndTypeToHeap(_, ?type, ?class).


/*************************************************************
 * Coarse-grained allocation policy
 *************************************************************/

#ifdef COARSE_GRAINED_ALLOCATION
// Very coarse-grained allocation policy
// AllocationShouldBeMergedPerPackage(?type, ?packageName) <-
//   AllocationsPerPackageAndType[?type, ?packageName] > 1.

// Coarse-grained allocation policy
//AllocationShouldBeMergedPerClass(?type, ?class) <-
//  AllocationsPerClassAndType[?type, ?class] > 1.
#endif // COARSE_GRAINED_ALLOCATION


/*************************************************************
 * Library class that should be treated specially
 *************************************************************/

#ifndef CONTEXT_SENSITIVE_LIBRARY_ANALYSIS
#include "special-library.dl"
HeapAllocation_ContextInsensitive(?heap) :-
  SpecialLibraryObject(?heap),
  !HeapRepresentative(_, ?heap).

#ifdef MERGE_LIBRARY_OBJECTS_PER_METHOD
AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  ?n > 1,
  Method_DeclaringType(?meth, ?class),
  SpecialLibraryClass(?class).
#endif
#endif

/*************************************************************
 * String buffers and builders
 *************************************************************/
.decl StringFactoryType(?type:Type)

StringFactoryType(?type) :-
  isType(?type),
  ?type = "java.lang.StringBuffer" ;
  isType(?type),
  ?type = "java.lang.StringBuilder".

StringFactoryHeap(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  StringFactoryType(?heaptype).

HeapRepresentative(?mergeHeap, ?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isType(?type),
  ?type = "java.lang.StringBuffer",
  ?mergeHeap = "<<string-buffer>>",
  isHeapAllocation(?mergeHeap),
  !HeapAllocation_Keep(?heap).

HeapRepresentative(?mergeHeap, ?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isType(?type),
  ?type = "java.lang.StringBuilder",
  ?mergeHeap = "<<string-builder>>",
  isHeapAllocation(?mergeHeap),
  !HeapAllocation_Keep(?heap).

/*************************************************************
 * Throwable
 *************************************************************/

/*
 // (Yannis) This is the original, precise and straightforward treatment
 // of throwables. They were allocated context insensitively. This still
 // produced huge ThrowPointsTo sets and caused slowdowns.
 */
#ifdef SEPARATE_EXCEPTION_OBJECTS
HeapAllocation_ContextInsensitive(?heap) <-
  HeapAllocation_Type(?heap, ?type),
  ExceptionType(?type).
#else

// The optimized treatment represents every exception (i.e., throwable)
// object by a unique representative of the same type. All exception
// objects of the same type are therefore merged. This means that points-to
// results for throwables are not accurate! Only the type will be right.

//TypeToHeap2(?heap, ?heaptype) <-
//  HeapAllocation:Type[?heap] = ?heaptype,
//  Type:Id(?throw:"java.lang.Throwable"),
//  SubtypeOf(?heaptype, ?throw),
//  ExceptionHandler:Type[_] = ?handlertype,
//  SubtypeOf(?heaptype, ?handlertype).
.decl TypeToHeap(?heap:HeapAllocation, ?type:Type)
.decl TypeToHeapOrdinal(?heap:number, ?type:Type)

TypeToHeap(?heap, ?heaptype) :-
  AssignHeapAllocation(?heap, _, _),
  HeapAllocation_Type(?heap, ?heaptype),
  ExceptionType(?heaptype).

TypeToHeapOrdinal(ord(?heap), ?heapType) :-
  TypeToHeap(?heap, ?heapType).


.decl ExceptionHeapTypeRepresentativeOrdinal(?type:Type, ?reprHeapOrd:number)

ExceptionHeapTypeRepresentativeOrdinal(?type, ?representativeHeapOrd) :-
  TypeToHeap(_, ?type),
  ?representativeHeapOrd = min ?otherHeap : TypeToHeapOrdinal(?otherHeap, ?type).

HeapRepresentative(?representativeHeap, ?heap) :-
  ExceptionHeapTypeRepresentativeOrdinal(?heaptype, ?representativeHeapOrd),
  TypeToHeap(?heap, ?heaptype),
  ord(?representativeHeap) = ?representativeHeapOrd,
  isHeapAllocation(?representativeHeap).

#endif // SEPARATE_EXCEPTION_OBJECTS
/*
// An intermediate option is to only merge exception objects of the
// same type that are thrown in the same method.
SameTypeAndMethod(?heap1, ?heap2) <-
  HeapAllocation:Type[?heap1] = ?heaptype,
  Type:Id(?throw:"java.lang.Throwable"),
  SubtypeOf(?heaptype, ?throw),
  HeapAllocation:Type[?heap2] = ?heaptype,
  AssignHeapAllocation(?heap1,_,?inmethod),
  AssignHeapAllocation(?heap2,_,?inmethod).

// Similarly quadratic but efficient.
HeapRepresentative(?representativeHeap, ?heap) <-
  agg<<?representativeHeap = min(?otherHeap)>>(SameTypeAndMethod(?otherHeap,?heap)).

*/

/*************************************************************
 * Primitive arrays
 *
 * char[] or int[] don't have object elements, so it's useless to
 * allocate them context-sensitively.
 *
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isArrayType(?type),
  ComponentType(?type, ?componentType),
  isPrimitiveType(?componentType).

/*************************************************************
 * Class without reference fields
 *
 * Treat context-insensitively always? It doesn't matter much,
 * but doesn't hurt much either.
 *************************************************************/
/*
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation:Type(?heap, ?heaptype),
  Type_HasNoReferenceField(?heaptype),
  !HeapRepresentative(_, ?heap).
  // The rules have become complex enough that they overlap.

decl Type_HasNoReferenceField(?type:Type)
decl Type_DeclaresReferenceField(?type:Type)

Type_HasNoReferenceField(?type) :-
  ?type = "java.lang.Object",
  isType(?type).

Type_HasNoReferenceField(?class) :-
  isClassType(?class),
  DirectSuperclass(?class, ?super),
  Type_HasNoReferenceField(?super),
  ! Type_DeclaresReferenceField(?class).

Type_DeclaresReferenceField(?class) :-
  isClassType(?class),
  Field_DeclaringType(?signature, ?class),
  Field_Type(?signature, ?type),
  ReferenceType(?type),
  !FieldIsStatic(?signature).

FieldIsStatic(?sig) :-
  ?static = "static",
  Modifier(?static),
  Field_Modifier(?static, ?sig).

//// Quite risky: even final fields hold interesting state.
//FieldIsStaticOrFinal?sig) <-
//  Modifier:Id(?final:"final"),
//  Field:Modifier(?final, ?sig).
*/
