.decl VPTCountPerMethod(?method:Method, ?n:number)

VPTCountPerMethod(?method, Y) :-
   Var_DeclaringMethod(?var, ?method),
   Y =  count : {mainAnalysis.VarPointsTo(_, _, _, ?var)}.

.decl CalleeCountPerMethod(?method:Method, ?n:number)

CalleeCountPerMethod(?method, Y) :-
  isMethod(?method),      
  Y =  count : {Stats_Simple_InsensCallGraphEdge(?invo, _),
  Instruction_Method(?invo, ?method)}.

.decl CallerCountPerMethod(?method:Method, ?n:number)

CallerCountPerMethod(?tomethod, Y) :-
  isMethod(?tomethod),      
  Y = count : {Stats_Simple_InsensCallGraphEdge(?invo, ?tomethod),
  Instruction_Method(?invo, _)}.
                             
.decl NeighboringMethodsInCallGraph(?method:Method, ?neighbor:Method, ?weight:number)

NeighboringMethodsInCallGraph(?method, ?method, 1) :-
   VPTCountPerMethod(?method, _).

NeighboringMethodsInCallGraph(?method, ?neigh, ?weight) :-
  mainAnalysis.CallGraphEdge(_, ?invo, _, ?method),
  Instruction_Method(?invo, ?neigh),
  CalleeCountPerMethod(?neigh, ?weight).

NeighboringMethodsInCallGraph(?neigh, ?method, ?weight) :-
  mainAnalysis.CallGraphEdge(_, ?invo, _, ?neigh),
  Instruction_Method(?invo, ?method),
  CallerCountPerMethod(?neigh, ?weight).
                     
.decl WeightedLocalVPTSize(?method:Method, ?n:number)
      
WeightedLocalVPTSize(?method, Y) :-
  isMethod(?method),      
  Y = sum ?n * 100 / ?weight: { NeighboringMethodsInCallGraph(?neigh, ?method, ?weight), VPTCountPerMethod(?neigh, ?n) }.

// .decl VarPointsToThroughInstanceField(?ctx:mainAnalysis.configuration.Context, ?var:Var, ?basevalueHctx:mainAnalysis.configuration.HContext, ?basevalue:mainAnalysis.Value, ?value:mainAnalysis.Value, ?valueHctx:mainAnalysis.configuration.HContext, ?sig:Field)

// VarPointsToThroughInstanceField(?ctx, ?var, ?basevaluehctx, ?basevalue, ?value, ?valuehctx, ?sig) :-
//   mainAnalysis.VarPointsTo(?basevaluehctx, ?basevalue, ?ctx, ?var),
//   mainAnalysis.InstanceFieldPointsTo(?valuehctx, ?value, ?sig, ?basevaluehctx, ?basevalue).
.decl CountObjectPointsToThroughField(?basevalue:mainAnalysis.Value, ?basehctx:mainAnalysis.configuration.HContext, ?n:number)
      
CountObjectPointsToThroughField(?basevalue, ?basehctx, Y) :-
  mainAnalysis.isValue(?basevalue),
  mainAnalysis.isHContext(?basehctx),           
  Y = count : {mainAnalysis.InstanceFieldPointsTo(_, _, _, ?basehctx, ?basevalue)}.

.decl LocalIFPTSize(?method:Method, ?n:number)

LocalIFPTSize(?method, Y) :-
  isMethod(?method),    
  Y = sum ?n : {Var_DeclaringMethod(?var, ?method),
  mainAnalysis.VarPointsTo(?basehctx, ?basevalue, _, ?var),
  CountObjectPointsToThroughField(?basevalue, ?basehctx, ?n)}.  

.decl MethodWeight(?method:Method, ?n:number)

MethodWeight(?method, ?n) :-      
  WeightedLocalVPTSize(?method, ?size1),
  LocalIFPTSize(?method, ?size2),
  ?n = ?size1 + ?size2.

.output VPTCountPerMethod
.output WeightedLocalVPTSize
.output LocalIFPTSize
.output MethodWeight

// .decl TwoLevelCallerMethodInCallGraph(?neighbor:Method, ?method:Method, ?weight:number)

// TwoLevelCallerMethodInCallGraph(?neigh, ?method, ?weight) :-
//   NeighboringMethodsInCallGraph(?intermediatemethod, ?method, _),
//   mainAnalysis.CallGraphEdge(_, ?invo, _, ?intermediatemethod),
//   Instruction_Method(?invo, ?neigh),
//   CalleeCountPerMethod(?neigh, ?weight).

// TwoLevelCallerMethodInCallGraph(?neigh, ?method, ?weight) :-
//    NeighboringMethodsInCallGraph(?neigh, ?method, ?weight).
