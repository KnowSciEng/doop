Instruction_Throws(?hctx, ?value, ?ctx, ?insn) :-
  Throw(?insn, ?var),
  VarPointsTo(?hctx, ?value, ?ctx, ?var).

Instruction_Throws(?hctx, ?value, ?callerCtx, ?invocation) :-
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod),
  ThrowPointsTo(?hctx, ?value, ?calleeCtx, ?tomethod).
  .plan 1:(2,1)

/**
 * Represents the exceptions a method can throw
 * TODO Implicitly thrown exceptions are not included
 */
ThrowPointsTo(?hctx, ?value, ?ctx, ?method) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Instruction_Method(?insn, ?method),
  !ExceptionHandler_InRange(_, ?insn).

ThrowPointsTo(?hctx, ?value, ?ctx, ?method) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Instruction_Method(?insn, ?method),
  ExceptionHandler_SameInsn_Repr(?insn, ?repr),
  ExceptionHandler_SameBlock_Repr(?repr, ?block),
  Value_Type(?value, ?valueType),
  !ExceptionHandler_TypeIsCaught(?valueType, ?block).

VarPointsTo(?hctx, ?value, ?ctx, ?param) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Value_Type(?value, ?valueType),
  ExceptionHandler_InRange(?handler, ?insn),
  ExceptionHandler_Type(?handler, ?handlerType),
  SubtypeOf(?valueType, ?handlerType),
  ConcreteClass(?valueType), // filtering null_type
  !ExceptionHandler_Impossible(?valueType, ?handler, ?insn),
  ExceptionHandler_FormalParam(?handler, ?param).

///////////////////////////////////////////////////////////////////////////////

/*
 * This will only used to check that an exception is *not* caught (negated).
 * Merge handlers with the same catch block for further optimization.
 */
ExceptionHandler_TypeIsCaught(?type, ?block) :-
  ExceptionHandler_InRange(?handler, ?insn),
  ExceptionHandler_SameInsn_Repr(?insn, ?repr),
  ExceptionHandler_SameBlock_Repr(?repr, ?block),
  ExceptionHandler_Type(?handler, ?handlerType),
  SubtypeOf(?type, ?handlerType),
  ConcreteClass(?type).

/*
 * Inclusion of instuction is important. E.g. handler1 covers indices 20-30,
 * handler2 covers indices 10-40. Also, Previous(handler1, handler2).
 * Instruction #25 may infer Impossible(T1, handler2). Subsequently, when
 * checking instruction #15, we would (falsely) have that handler2 is
 * impossible for type T1.
 */
ExceptionHandler_Impossible(?type, ?h2, ?insn) :-
  ExceptionHandler_InRange(?h1, ?insn),
  ExceptionHandler_InRange(?h2, ?insn),
  ExceptionHandler_Before(?h1, ?h2),
  ExceptionHandler_Type(?h1, ?h1Type),
  ExceptionHandler_Type(?h2, ?h2Type),
  SubtypeOf(?type, ?h1Type),
  SubtypeOf(?type, ?h2Type),
  ConcreteClass(?type).

///////////////////////////////////////////////////////////////////////////////

ExceptionHandler_InRange(?handler, ?instruction) :-
  Instruction_Method(?instruction, ?method),
  Instruction_Index(?instruction, ?index),
  ExceptionHandler_Method(?handler, ?method),
  ExceptionHandler_Begin(?handler, ?beginIndex),
  ?beginIndex <= ?index,
  ExceptionHandler_End(?handler, ?endIndex),
  ?endIndex > ?index.

/*
 * Previous(h1, h2) has different semantics compared to Index[h1] < Index[h2].
 * This is due to catch clauses with multiple exceptions.
 * E.g. catch(IOException|SQLException ex)
 */
ExceptionHandler_Before(?previous, ?handler) :-
  ExceptionHandler_Previous(?handler, ?previous).

ExceptionHandler_Before(?before, ?handler) :-
  ExceptionHandler_Before(?middle, ?handler),
  ExceptionHandler_Previous(?middle, ?before).

/*
 * An instruction may be in range of multiple handlers. Pick the first one as a
 * representative and have it handling all (concrete) types of those handlers.
 */
ExceptionHandler_SameInsn_PartialOrder(?h1, ?h2, ?insn) :-
  ExceptionHandler_InRange(?h1, ?insn),
  ExceptionHandler_InRange(?h2, ?insn),
  ExceptionHandler_Before(?h1, ?h2).

ExceptionHandler_SameInsn_Repr(?insn, ?handler) :-
  ExceptionHandler_InRange(?handler, ?insn),
  !ExceptionHandler_SameInsn_PartialOrder(_, ?handler, ?insn).

/*
 * In Jimple, multiple handlers share the same catch block. Also, additional
 * handlers/catch blocks might be added (e.g. to handle exitmonitor commands).
 * NOTE_ there are cases where_
 * Previous(h1, h2), Repr[h1] = block1, Repr[h2] = block2 *but* Index[block1] > Index[block2]
 */
ExceptionHandler_SameBlock_PartialOrder(?h1, ?h2) :-
  ExceptionHandler_Before(?h1, ?h2),
  ExceptionHandler_Index(?h1, ?h1Index),
  ExceptionHandler_Index(?h2, ?h2Index),
  ?h1Index = ?h2Index.

ExceptionHandler_SameBlock_Repr(?handler, ?handler) :-
  isExceptionHandler(?handler),
  !ExceptionHandler_SameBlock_PartialOrder(_, ?handler).

ExceptionHandler_SameBlock_Repr(?handler, ?repr) :-
  ExceptionHandler_SameBlock_PartialOrder(?repr, ?handler),
  !ExceptionHandler_SameBlock_PartialOrder(_, ?repr).
