#include "../../main/single-phase-analysis.dl"
#include "../../main/configuration.dl"
//#include "partitioning.dl"

.type Partition

.comp PartitionedTwoObjectSensitivePlusHeapConfiguration : AbstractConfiguration {

  .type Context  = [ partition: Partition, value1:mainAnalysis.Value, value2:mainAnalysis.Value ]
  .type HContext = [ partition: Partition, value:mainAnalysis.Value ]

  .decl PartitionForValue(value: mainAnalysis.Value, partition: Partition)
  .decl ValueInAllPartitions(value: mainAnalysis.Value)
  .decl NotValueInAllPartitions(value: mainAnalysis.Value)
  .decl TypeInAllPartitions(type: Type)
  .decl NotTypeInAllPartitions(type: Type)
  .decl PartitionForInvocation(invo: Instruction, partition: Partition)
  .decl PartitionForMethod(method: Method, partition: Partition)
  .decl MethodInAllPartitions(method: Method)
  .decl PartitionForResolvedInvocation(type: Type, invo: Instruction, partition: Partition)
  .decl MatchingMethodForInvocationAndType(type: Type, invocation: Instruction, method: Method)
  .decl ValidCtxVar(ctx: Context, var: Var)
  .decl CollapsedVarPointsTo(hctx: HContext, heap: mainAnalysis.Value, ctx: Context, var: Var)
  .decl isPartition(partition: Partition)

  .output CollapsedVarPointsTo
  // horrible indexing, but there will only be a handful of such contexts
  ImmutableContextFromHContext(hctx, ctx) :-
    isHContext(hctx),
    isImmutableContext(ctx),
    hctx = [partition, hctxVal],
    ctx = [partition, ctxVal1, ctxVal2],
    ctxVal1 = ctxVal1,
    ctxVal2 = ctxVal2,
    hctxVal = hctxVal.

  ImmutableContextFromContext(ctx1, ctx2) :-
    isContext(ctx1),
    isImmutableContext(ctx2),
    ctx1 = [partition, ctx1Val1, ctx1Val2],
    ctx2 = [partition, ctx2Val1, ctx2Val2],
    ctx1Val1 = ctx1Val1,
    ctx1Val2 = ctx1Val2,
    ctx2Val1 = ctx2Val1,
    ctx2Val2 = ctx2Val2.

  ImmutableHContextFromContext(ctx, hctx) :-
    isContext(ctx),
    isImmutableHContext(hctx),
    ctx = [partition, ctxVal1, ctxVal2],
    hctx = [partition, hctxVal],
    ctxVal1 = ctxVal1,
    ctxVal2 = ctxVal2,
    hctxVal = hctxVal.

  CompatibleHContexts(hctx1, hctx2) :-
      isHContext(hctx1),
      isHContext(hctx2),
      hctx1 = [partition, hctxv1],
      hctx2 = [partition, hctxv2],
      hctxv1 = hctxv1,
      hctxv2 = hctxv2.

  CompatibleContextAndHContext(ctx, hctx) :-
      isContext(ctx),
      isHContext(hctx),
      ctx = [partition, ctxv1, ctxv2],
      hctx = [partition, hctxv],
      ctxv1 = ctxv1,
      ctxv2 = ctxv2,
      hctxv = hctxv.

  // Merge optimization hack

  MatchingMethodForInvocationAndType(type, invocation, tomethod) :-
    basic.ResolveInvocation(type, invocation, tomethod).

  MatchingMethodForInvocationAndType(type, invocation, tomethod) :-
    SpecialMethodInvocation_Base(invocation, base),
    MethodInvocation_Method(invocation, tomethod),
    Var_Type(base, basetype),
    basic.SubtypeOf(type, basetype).

  PartitionForValue(value, partitionId) :-
    mainAnalysis.Value_Type(value, valueClass),
    TypeToPartitionId(valueClass, partitionId).

  ValueInAllPartitions(value) :-
    Value_DeclaringType(value, valueClass),
    TypeInAllPartitions(valueClass).

  NotValueInAllPartitions(value) :-
    Value_DeclaringType(value, valueClass),
    NotTypeInAllPartitions(valueClass).

  TypeInAllPartitions(type) :-
    isType(type),
    match("java\.util.*", type).

  NotTypeInAllPartitions(type) :-
    isType(type),
    !TypeInAllPartitions(type).

  PartitionForInvocation(invo, partitionId) :-
    Instruction_Method(invo, inmethod),
    Method_DeclaringType(inmethod, inClass),
    TypeToPartitionId(inClass, partitionId).

  PartitionForMethod(method, partitionId) :-
    Method_DeclaringType(method, inClass),
    TypeToPartitionId(inClass, partitionId).

  MethodInAllPartitions(method) :-
    Method_DeclaringType(method, type),
    TypeInAllPartitions(type).

  PartitionForResolvedInvocation(type, invo, partitionId) :-
    MatchingMethodForInvocationAndType(type, invo, tomethod),
    Method_DeclaringType(tomethod, toclass),
    TypeToPartitionId(toclass, partitionId).

  /// Base the decision on the partition of the target method
  isContext(calleeCtx),
  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, _),
    mainAnalysis.Value_Type(value, valuetype),
      (TypeInAllPartitions(valuetype) ;
      (PartitionForResolvedInvocation(valuetype, invo, partition),
       PartitionForInvocation(invo, partition))),
    hctx = [__partition, __value1],
    calleeCtx = [__partition, __value1, value].

  ContextResponse(callerCtx, hctx, invo,value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, _),
    mainAnalysis.Value_Type(value, valuetype),
    !(PartitionForResolvedInvocation(valuetype, invo, _)),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  ContextResponse(callerCtx, hctx, invo, value, calleeCtx) :-
    ContextRequest(callerCtx, hctx, invo, value, _),
    mainAnalysis.Value_Type(value, valuetype),
    PartitionForResolvedInvocation(valuetype, invo, partId),
    ((!PartitionForInvocation(invo, partId)) ;
     (!PartitionForInvocation(invo, _))),
    !TypeInAllPartitions(valuetype),
    ImmutableContextFromHContext(hctx, calleeCtx).

  // and for static methods
  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    ((PartitionForMethod(tomethod, partition),
    PartitionForInvocation(invo, partition));
    MethodInAllPartitions(tomethod)),
    calleeCtx = callerCtx.

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    !PartitionForMethod(tomethod, _),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).

  StaticContextResponse(callerCtx, invo, calleeCtx) :-
    StaticContextRequest(callerCtx, invo),
    MethodInvocation_Method(invo, tomethod),
    ((PartitionForMethod(tomethod, topartition),
     PartitionForInvocation(invo, invopartition),
     topartition != invopartition) ;
    !(PartitionForInvocation(invo, _))),
    !MethodInAllPartitions(tomethod),
    ImmutableContextFromContext(callerCtx, calleeCtx).

  ThreadStartContextResponse(callerCtx, hctx, value, newCtx) :-
    ThreadStartContextRequest(callerCtx, hctx, value),
    hctx = [partition, hctxValue],
    newCtx = [partition, hctxValue, value].

  StartupContextResponse(hctx, value, newCtx) :-
    StartupContextRequest(hctx, value),
    hctx = [partition, hctxValue],
    newCtx = [partition, hctxValue, value].

  FinalizerRegisterContextResponse(callerCtx, inmethod, value, newCtx) :-
    FinalizerRegisterContextRequest(callerCtx, inmethod, value),
    callerCtx = [partition, callerCtxValue1, callerCtxValue2],
    newCtx = [partition, callerCtxValue2, value],
    callerCtxValue1 = callerCtxValue1.

  InitContextResponse(value, ctx) :-
    InitContextRequest(value),
    isPartition(partition),
    ctx = [partition, value, value].

  InitHContextResponse(value, hctx) :-
    InitHContextRequest(value),
    isPartition(partition),
    hctx = [partition, value].


  // What are the necessary parameters for this analysis
  isHContext(hctx),
  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value,var),
    ctx = [partition, ctxv1, ctxv2],
    (PartitionForValue(value, partition);
     ValueInAllPartitions(value)),
    hctx = [partition, ctxv2],
    ctxv1 = ctxv1.

  isHContext(hctx),
  RecordContextResponse(ctx, value, var, hctx) :-
    RecordContextRequest(ctx, value, var),
    PartitionForValue(value, partId),
    ctx = [partId2, ctxv1, ctxv2],
    partId != partId2,
    NotValueInAllPartitions(value),
    ImmutableHContextFromContext(ctx, hctx),
    ctxv1 = ctxv1,
    ctxv2 = ctxv2.

  // Post-processing
 ValidCtxVar(ctx, var) :-
    mainAnalysis.ReachableContext(ctx, meth),
    Method_DeclaringType(meth, intype),
    Var_DeclaringMethod(var,meth),
    ((!TypeToPartitionId(intype, _));
     (TypeToPartitionId(intype, partition),
      ctx = [partition, ctxv1, ctxv2],
      ctxv1 = ctxv1,
      ctxv2 = ctxv2)).

  CollapsedVarPointsTo(hctx, heap, ctx, var) :-
    mainAnalysis.VarPointsTo(hctx, heap, ctx, var),
    ValidCtxVar(ctx, var).

  .decl TypeToPartitionId(type: Type, id: Partition)
  .input TypeToPartitionId(IO="file", filename="TypeToPartitionId.facts", delimiter=",")

  isPartition(?partition) :-
    TypeToPartitionId(_, ?partition).
}
