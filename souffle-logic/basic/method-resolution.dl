MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    MethodImplemented(?simplename, ?descriptor, ?type, ?method).

MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    (DirectSuperclass(?type, ?supertype) ;
     DirectSuperinterface(?type, ?supertype)),
    MethodLookup(?simplename, ?descriptor, ?supertype, ?method),
    ! MethodImplemented(?simplename, ?descriptor, ?type, _).

/**
 * Arrays
 *
 * TODO MethodLookup of clone in an array type now results in
 *      Object.clone. This is not according to the spec, but in the
 *      Sun JVM arrays don't have a declared clone method either. The
 *      bytecode does indicate a call to clone in the array class, but
 *      the Jimple code turns this into a call of
 *      java.lang.Object.clone()
 *
 * TODO Alternative, better implementation: just make java.lang.Object
 *      a direct superclass of array types, something we should do
 *      anyway.
 */
MethodLookup(?simplename, ?descriptor, ?arraytype, ?method) :-
    isArrayType(?arraytype),
    isType(?objectType),
    MethodImplemented(?simplename, ?descriptor, ?objectType, ?method),
    ?objectType = "java.lang.Object".

MethodImplemented(?simplename, ?descriptor, ?type, ?method) :-
    Method_SimpleName(?method, ?simplename),
    Method_Descriptor(?method, ?descriptor),
    Method_DeclaringType(?method, ?type),
    ! Method_Modifier("abstract", ?method).

#ifndef FEATHERWEIGHT_ANALYSIS

// Logic that finds overridden methods with covariant return types.
// Covariant methods are found locally in each class by matching
// bridge methods (generated by javac) with normal methods.

.decl MethodMightBeCovariantBridge(?bridge:Method, ?meth:Method)

MethodMightBeCovariantBridge(?bridge, ?meth) :-
   Method_Modifier("bridge", ?bridge),
   Method_SimpleName(?bridge, ?sameName),
   ?sameName != "<clinit>",
   ?sameName != "<init>",
   Method_SimpleName(?meth, ?sameName),
   !Method_Modifier("bridge", ?meth),
   Method_DeclaringType(?bridge, ?type),
   Method_DeclaringType(?meth, ?type).

.decl MethodNotCovariantBridge(?meth1:Method, ?meth2:Method)

// REVIEW: using _Var_Type instead of Var_Type to avoid
// recursion-through-negation.
MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, ?formal1),
   _Var_Type(?formal1, ?type1),
   FormalParam(?sameIndex, ?meth2, ?formal2),
   _Var_Type(?formal2, ?type2),
   ?type1 != ?type2.

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, _),
   !FormalParam(?sameIndex, ?meth2, _).

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth2, _),
   !FormalParam(?sameIndex, ?meth1, _).

.decl Method_CovariantBridge(?bridge:Method, ?cometh:Method)

Method_CovariantBridge(?bridge, ?cometh) :-
   MethodMightBeCovariantBridge(?bridge, ?cometh),
   !MethodNotCovariantBridge(?bridge, ?cometh),
   Method_ReturnType(?bridge, ?retType),
   Method_ReturnType(?cometh, ?coRetType),
   SubtypeOfDifferent(?coRetType, ?retType).

// Register covariant methods in MethodImplemented.
MethodImplemented(?name, ?descriptor, ?type, ?comethod) :-
    MethodImplemented(?name, _, ?type, ?comethod),
    Method_CovariantBridge(?method, ?comethod),
    Method_SimpleName(?method, ?name),
    Method_Descriptor(?method, ?descriptor).

#endif // FEATHERWEIGHT_ANALYSIS

ResolveInvocation(?type, ?invocation, ?tomethod) :-
    VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
    VirtualMethodInvocation_Descriptor(?invocation, ?descriptor),
    VirtualMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype),
    MethodLookup(?simplename, ?descriptor, ?type, ?tomethod),
    SubtypeOf(?type, ?basetype).

ResolveInvocation(?basetype, ?invocation, ?tomethod) :-
    SuperMethodInvocation_SimpleName(?invocation, ?simplename),
    SuperMethodInvocation_Descriptor(?invocation, ?descriptor),
    SuperMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype),
    DirectSuperclass(?basetype, ?supertype),
    MethodLookup(?simplename, ?descriptor, ?supertype, ?tomethod).

OverridableMethod(?type, ?method) :-
    MethodLookup(_, _, ?type, ?method),
    ! Method_Modifier("static", ?method),
    ! Method_Modifier("final", ?method),
    Method_Modifier("public", ?method),
    Subclassable(?type).

OverridableMethod(?type, ?method) :-
    MethodLookup(_, _, ?type, ?method),
    ! Method_Modifier("static", ?method),
    ! Method_Modifier("final", ?method),
    Method_Modifier("protected", ?method),
    Subclassable(?type).

ClassConstructor(method, type) :-
    MethodLookup(_, _, type, method),
    isMethod(method),
    match(".*<init>.*", method).

// This shouldn't be too expensive, once MethodLookup has been computed,
// and it's a useful concept.
.decl MethodOverridesOther(?methodSub:Method, ?methodSuper:Method)
MethodOverridesOther(?methSub, ?methSuper) :-
  SubtypeOf(?subtype, ?supertype),
  Method_DeclaringType(?methSuper, ?supertype),
  Method_SimpleName(?methSuper, ?simplename),
  Method_Descriptor(?methSuper, ?descriptor),
  MethodLookup(?simplename, ?descriptor, ?subtype, ?methSub),
  ?methSub != ?methSuper.

.decl ConcreteMethodDeclared(?meth:Method, ?class:ClassType)
ConcreteMethodDeclared(?meth, ?class) :-
  isClassType(?class),
  Method_DeclaringType(?meth, ?class),
  !Method_Modifier("abstract", ?meth).

.decl MethodDeclaredOrInherited(?meth:Method, ?class:ClassType)
MethodDeclaredOrInherited(?meth, ?class) :-
//  isClassType(?class),
  Method_DeclaringType(?meth, ?class).

// This keeps the superclass signature of the method. Does not guarantee
// there is a concrete implementation until we do "MethodLookup".
MethodDeclaredOrInherited(?meth, ?class) :-
  MethodDeclaredOrInherited(?meth, ?superClass),
  DirectSuperclass(?class, ?superClass).

// Inherit default methods from interfaces.
MethodDeclaredOrInherited(?meth, ?class) :-
  MethodDeclaredOrInherited(?meth, ?superInterface),
  !Method_Modifier("abstract", ?meth),
  DirectSuperinterface(?class, ?superInterface).

// REVIEW: a little wasteful, but guessing it doesn't matter.
.decl MethodsOfSameOrSuperType(?method1:Method, ?method2:Method)
MethodsOfSameOrSuperType(?method1, ?method2) :-
  MethodDeclaredOrInherited(?method1, ?class),
  MethodDeclaredOrInherited(?method2, ?class).

.decl MethodsOfSameNonSDKType(?method1:Method, ?method2:Method, ?class:Type)
MethodsOfSameNonSDKType(?method1, ?method2, ?class) :-
  !match("java.*", ?class),
  !match("sun.*", ?class),
  Method_DeclaringType(?method1, ?class),
  Method_DeclaringType(?method2, ?class).
